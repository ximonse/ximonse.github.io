<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Notes - S√∂k och Klunga</title>
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
    <!-- Removed Konva - not needed for simple resize system -->
    <!-- Removed problematic node-editing extension -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }
        
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: transparent;
            border-bottom: 1px solid rgba(221, 221, 221, 0.2);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            opacity: 0.8;
            gap: 5px;
            flex-wrap: nowrap;
            overflow: hidden;
        }
        
        .search-box {
            flex: 0 0 280px;
            min-width: 200px;
        }
        
        .tag-filter-box {
            flex: 0 0 200px;
            min-width: 150px;
        }
        
        
        .tag-filter-input {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #495057;
            box-sizing: border-box;
        }
        
        .tag-filter-input:focus {
            border-color: #adb5bd;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
        }
        
        .layout-selector {
            flex: 0.5;
            margin-right: 20px;
        }
        
        .layout-selector select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #495057;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #adb5bd;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
        }
        
        /* Unified Toolbar Button Styling */
        .toolbar-btn {
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .toolbar-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .search-select-btn {
            margin-left: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .add-card-btn {
            padding: 10px 20px;
            border-radius: 20px;
        }
        
        /* Project Selector Styling */
        .project-selector {
            position: relative;
            display: inline-block;
            flex-shrink: 0;
        }
        
        .project-button {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(145deg, #007acc 0%, #005a9e 100%);
            color: white;
            border: 1px solid #005a9e;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 122, 204, 0.2);
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .project-button:hover {
            background: linear-gradient(145deg, #005a9e 0%, #004578 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 204, 0.3);
        }
        
        .project-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 122, 204, 0.2);
        }
        
        .project-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            min-width: 220px;
            display: none;
            margin-top: 2px;
        }
        
        .project-dropdown.show {
            display: block;
        }
        
        .project-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #495057;
            transition: background-color 0.2s ease;
        }
        
        .project-dropdown-item:hover {
            background: #f8f9fa;
        }
        
        .project-dropdown-item:last-child {
            border-bottom: none;
        }
        
        .project-dropdown-item.active {
            background: #e3f2fd;
            color: #1976d2;
            font-weight: 500;
        }
        
        
        .menu-dropdown {
            position: relative;
            display: inline-block;
        }
        
        
        
        .menu-button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            min-width: 220px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            z-index: 10000;
            border: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .dropdown-content button {
            background: none;
            border: none;
            color: #2d3748;
            padding: 10px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: 0;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .dropdown-content button:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .dropdown-content button:last-child {
            border-radius: 0 0 8px 8px;
        }
        
        .dropdown-content button:hover {
            background: linear-gradient(90deg, #f7fafc 0%, #edf2f7 100%);
            color: #1a202c;
            transform: translateX(2px);
        }
        
        .dropdown-content button:active {
            background: linear-gradient(90deg, #e2e8f0 0%, #cbd5e0 100%);
        }
        
        .menu-dropdown:hover .dropdown-content,
        .menu-dropdown.active .dropdown-content,
        .dropdown-content:hover {
            display: block;
        }
        
        /* Ensure the dropdown stays open when hovering the content area */
        .menu-dropdown {
            position: relative;
        }
        
        .dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
        }
        
        /* On desktop, keep hover behavior smooth */
        @media (min-width: 769px) {
            .menu-dropdown:hover .dropdown-content {
                display: block;
            }
        }
        
        #cy {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            transition: left 0.3s ease;
        }
        
        /* Canvas stays full width - toolbar floats on top */
        
        .search-results-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 122, 204, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10100;
            cursor: pointer;
            user-select: none;
        }
        
        .search-results-info.visible {
            opacity: 1;
        }
        
        .search-results-info.sync-success {
            background: rgba(40, 167, 69, 0.9);
            color: white;
        }
        
        .search-results-info.sync-error {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }
        
        .search-results-info.sync-loading {
            background: rgba(0, 122, 204, 0.9);
            color: white;
        }
        
        .search-results-info.sync-info {
            background: rgba(23, 162, 184, 0.9);
            color: white;
        }
        
        .selection-info {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 10100;
            max-width: 300px;
            line-height: 1.4;
        }
        
        .selection-info.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* The invisible ruler for measuring text height */
        #text-ruler {
            position: absolute;
            left: -1000px; /* Position off-screen */
            top: -1000px;
            visibility: hidden;
            white-space: pre-wrap; /* Respect newlines and wrap text */
            word-wrap: break-word;
        }
        
        /* Enhanced box selection styling */
        .cy-box-selection {
            background-color: rgba(33, 150, 243, 0.1) !important;
            border: 2px dashed rgba(33, 150, 243, 0.6) !important;
            border-radius: 4px !important;
        }
        
        /* Dark Theme CSS */
        body.dark-theme {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .dark-theme .toolbar {
            background: transparent;
            border-bottom: 1px solid rgba(74, 85, 104, 0.3);
        }
        
        .dark-theme .tag-filter-input,
        .dark-theme .search-input {
            background: linear-gradient(145deg, #4a5568 0%, #3a4458 100%);
            border: 1px solid #5a6572;
            color: #f7fafc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .tag-filter-input:focus,
        .dark-theme .search-input:focus {
            border-color: #6b7280;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            background: linear-gradient(145deg, #5a6572 0%, #4a5568 100%);
        }
        
        /* Dark theme unified toolbar buttons */
        .dark-theme .toolbar-btn {
            background: linear-gradient(145deg, #4a5568 0%, #3a4458 100%);
            color: #f7fafc;
            border: 1px solid #5a6572;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .toolbar-btn:hover {
            background: linear-gradient(145deg, #5a6572 0%, #4a5568 100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        .dark-theme .dropdown-content {
            background: rgba(45, 55, 72, 0.75);
            color: #e2e8f0;
            border: 1px solid #4a5568;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .dropdown-content button {
            color: #e2e8f0;
        }
        
        .dark-theme .dropdown-content button:hover {
            background: linear-gradient(90deg, #4a5568 0%, #3a4458 100%);
            color: #f7fafc;
        }
        
        .dark-theme .dropdown-content button:active {
            background: linear-gradient(90deg, #2d3748 0%, #1a202c 100%);
        }
        
        .dark-theme .search-results-info {
            background: rgba(77, 166, 255, 0.9);
            color: #1a1a1a;
        }
        
        .dark-theme .selection-info {
            background: rgba(102, 179, 255, 0.9);
            color: #1a1a1a;
        }
        
        .dark-theme .mobile-btn {
            background: #4da6ff;
            color: #1a1a1a;
        }
        
        /* Dark theme f√∂r Cytoscape korten */
        body.dark-theme #cy {
            background: linear-gradient(45deg, #2d2d2d 25%, transparent 25%), 
                        linear-gradient(-45deg, #2d2d2d 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #2d2d2d 75%), 
                        linear-gradient(-45deg, transparent 75%, #2d2d2d 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #1a1a1a;
        }
        
        /* Sepia Theme CSS */
        body.sepia-theme {
            background: #f4f1e8;
            color: #5d4e37;
        }
        
        .sepia-theme .toolbar {
            background: transparent;
            border-bottom: 1px solid rgba(200, 168, 130, 0.3);
        }
        
        .sepia-theme .tag-filter-input,
        .sepia-theme .search-input {
            background: linear-gradient(145deg, #e8d7c3 0%, #d6c1a0 100%);
            border: 1px solid #c8a882;
            color: #5d4e37;
            box-shadow: 0 2px 4px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .tag-filter-input:focus,
        .sepia-theme .search-input:focus {
            border-color: #a89471;
            box-shadow: 0 4px 8px rgba(139, 117, 86, 0.3);
            background: linear-gradient(145deg, #d6c1a0 0%, #c2a788 100%);
        }
        
        /* Sepia theme unified toolbar buttons */
        .sepia-theme .toolbar-btn {
            background: linear-gradient(145deg, #e8d7c3 0%, #d6c1a0 100%);
            color: #5d4e37;
            border: 1px solid #c8a882;
            box-shadow: 0 2px 4px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .toolbar-btn:hover {
            background: linear-gradient(145deg, #d6c1a0 0%, #c2a788 100%);
            box-shadow: 0 4px 8px rgba(139, 117, 86, 0.3);
        }
        
        .sepia-theme .dropdown-content {
            background: rgba(244, 241, 232, 0.75);
            color: #5d4e37;
            border: 1px solid #c8a882;
            box-shadow: 0 10px 40px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .dropdown-content button {
            color: #5d4e37;
        }
        
        .sepia-theme .dropdown-content button:hover {
            background: linear-gradient(90deg, #e8d7c3 0%, #d6c1a0 100%);
            color: #4a3d2a;
        }
        
        .sepia-theme .dropdown-content button:active {
            background: linear-gradient(90deg, #d6c1a0 0%, #c2a788 100%);
        }
        
        .sepia-theme .search-results-info {
            background: rgba(139, 117, 86, 0.9);
            color: #f4f1e8;
        }
        
        .sepia-theme .selection-info {
            background: rgba(160, 130, 98, 0.9);
            color: #f4f1e8;
        }
        
        .sepia-theme .mobile-btn {
            background: #8b7556;
            color: #f4f1e8;
        }
        
        /* Sepia theme f√∂r Cytoscape korten */
        body.sepia-theme #cy {
            background: linear-gradient(45deg, #e8d7c3 25%, transparent 25%), 
                        linear-gradient(-45deg, #e8d7c3 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #e8d7c3 75%), 
                        linear-gradient(-45deg, transparent 75%, #e8d7c3 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #f4f1e8;
        }
        
        /* Dark Theme - Enhanced selection visibility */
        .dark-theme .cy {
            /* Override default Cytoscape styling for better dark theme contrast */
        }
        
        /* Card Colors - Light Theme */
        .light-theme .card-color-1 { background-color: #ffebee !important; } /* Soft Red */
        .light-theme .card-color-2 { background-color: #e3f2fd !important; } /* Soft Blue */
        .light-theme .card-color-3 { background-color: #e8f5e8 !important; } /* Soft Green */
        .light-theme .card-color-4 { background-color: #fff3e0 !important; } /* Soft Orange */
        .light-theme .card-color-5 { background-color: #f3e5f5 !important; } /* Soft Purple */
        
        /* Card Colors - Dark Theme */
        .dark-theme .card-color-1 { background-color: #4a2c2a !important; } /* Dark Red */
        .dark-theme .card-color-2 { background-color: #1e3a5f !important; } /* Dark Blue */
        .dark-theme .card-color-3 { background-color: #2d4a2d !important; } /* Dark Green */
        .dark-theme .card-color-4 { background-color: #4a3429 !important; } /* Dark Orange */
        .dark-theme .card-color-5 { background-color: #3d2a4a !important; } /* Dark Purple */
        
        /* Card Colors - Sepia Theme */
        .sepia-theme .card-color-1 { background-color: #f4e6d7 !important; } /* Sepia Red */
        .sepia-theme .card-color-2 { background-color: #e6d7c3 !important; } /* Sepia Blue */
        .sepia-theme .card-color-3 { background-color: #e8e6d7 !important; } /* Sepia Green */
        .sepia-theme .card-color-4 { background-color: #f0e6d2 !important; } /* Sepia Orange */
        .sepia-theme .card-color-5 { background-color: #ede6d7 !important; } /* Sepia Purple */
        
        /* Color Picker Popup */
        .color-picker-popup {
            position: fixed;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 2000;
        }
        
        .dark-theme .color-picker-popup {
            background: #2d2d2d;
            border-color: #555;
            color: #e0e0e0;
        }
        
        .sepia-theme .color-picker-popup {
            background: #e8d7c3;
            border-color: #c8a882;
            color: #5d4e37;
        }
        
        .color-picker-grid {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .color-picker-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        
        .color-picker-dot:hover {
            transform: scale(1.1);
        }
        
        /* Dark theme adjustments for dot text */
        .dark-theme .color-picker-dot {
            color: #fff !important;
            border-color: #666;
        }
        
        /* Sepia theme adjustments for dot text */
        .sepia-theme .color-picker-dot {
            color: #5d4e37 !important;
            border-color: #8B7355;
        }
        
        /* Ensure numbers are visible with stronger contrast */
        .color-picker-dot {
            text-shadow: 0 0 3px rgba(0,0,0,0.7);
        }
        
        .dark-theme .color-picker-dot {
            text-shadow: 0 0 3px rgba(0,0,0,0.9);
        }
        
        /* Color picker dot colors - Light theme */
        .color-picker-dot.card-color-1 { background-color: #d4f2d4; } /* Gr√∂n */
        .color-picker-dot.card-color-2 { background-color: #ffe4b3; } /* Orange */
        .color-picker-dot.card-color-3 { background-color: #ffc1cc; } /* R√∂d */
        .color-picker-dot.card-color-4 { background-color: #fff7b3; } /* Gul */
        .color-picker-dot.card-color-5 { background-color: #f3e5f5; } /* Lila */
        .color-picker-dot.card-color-6 { background-color: #c7e7ff; } /* Bl√• */
        .color-picker-dot.card-color-7 { background-color: #e0e0e0; } /* Gr√• */
        .color-picker-dot.card-color-8 { background-color: #ffffff; } /* Vit */
        
        /* Dark theme color picker dots */
        .dark-theme .color-picker-dot.card-color-1 { background-color: #3d5a3d; } /* M√∂rk Gr√∂n */
        .dark-theme .color-picker-dot.card-color-2 { background-color: #5a4d3a; } /* M√∂rk Orange */
        .dark-theme .color-picker-dot.card-color-3 { background-color: #5a3c3a; } /* M√∂rk R√∂d */
        .dark-theme .color-picker-dot.card-color-4 { background-color: #5a5a3a; } /* M√∂rk Gul */
        .dark-theme .color-picker-dot.card-color-5 { background-color: #4a3d5a; } /* M√∂rk Lila */
        .dark-theme .color-picker-dot.card-color-6 { background-color: #2e4a6f; } /* M√∂rk Bl√• */
        .dark-theme .color-picker-dot.card-color-7 { background-color: #555555; } /* M√∂rk Gr√• */
        .dark-theme .color-picker-dot.card-color-8 { background-color: #8a8a8a; } /* Ljusgr√• */
        
        /* Sepia theme color picker dots */
        .sepia-theme .color-picker-dot.card-color-1 { background-color: #ded6c7; } /* Sepia Gr√∂n */
        .sepia-theme .color-picker-dot.card-color-2 { background-color: #e6d6c2; } /* Sepia Orange */
        .sepia-theme .color-picker-dot.card-color-3 { background-color: #ead6c7; } /* Sepia R√∂d */
        .sepia-theme .color-picker-dot.card-color-4 { background-color: #ebe2d6; } /* Sepia Gul */
        .sepia-theme .color-picker-dot.card-color-5 { background-color: #e2d6c7; } /* Sepia Lila */
        .sepia-theme .color-picker-dot.card-color-6 { background-color: #d6c7b3; } /* Sepia Bl√• */
        .sepia-theme .color-picker-dot.card-color-7 { background-color: #c0b8a8; } /* Sepia Gr√• */
        .sepia-theme .color-picker-dot.card-color-8 { background-color: #f5f2e8; } /* Sepia Vit */
        
        .color-picker-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .color-picker-cancel {
            text-align: center;
            margin-top: 10px;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .dark-theme .color-picker-cancel {
            background: #555;
            color: #e0e0e0;
        }
        
        .sepia-theme .color-picker-cancel {
            background: #d7c8a8;
            color: #5d4e37;
        }
        
        .color-picker-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .color-picker-grid {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ddd;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .color-dot:hover {
            transform: scale(1.1);
            border-color: #333;
        }
        
        .dark-theme .color-dot {
            border-color: #555;
        }
        
        .dark-theme .color-dot:hover {
            border-color: #bbb;
        }
        
        .sepia-theme .color-dot {
            border-color: #c8a882;
        }
        
        .sepia-theme .color-dot:hover {
            border-color: #8b7556;
        }
        
        .color-picker-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .color-picker-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .color-picker-btn.remove {
            background: #ff6b6b;
            color: white;
        }
        
        .color-picker-btn.cancel {
            background: #6c757d;
            color: white;
        }
        
        /* Context Menu */
        .context-menu {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            min-width: 150px;
            overflow: hidden;
        }
        
        .dark-theme .context-menu {
            background: #2d2d2d;
            border-color: #555;
        }
        
        .sepia-theme .context-menu {
            background: #e8d7c3;
            border-color: #c8a882;
        }
        
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }
        
        .context-menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .dark-theme .context-menu-item {
            color: #e0e0e0;
            border-bottom-color: #444;
        }
        
        .dark-theme .context-menu-item:hover {
            background-color: #3a3a3a;
        }
        
        .sepia-theme .context-menu-item {
            color: #5d4e37;
            border-bottom-color: #d4c3a7;
        }
        
        .sepia-theme .context-menu-item:hover {
            background-color: #d4c3a7;
        }
        
        /* Mobile controls - floating buttons */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        /* Make toolbar mobile-friendly with icons */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 3px;
                padding: 5px;
                min-height: auto;
            }
            
            .search-box, .tag-filter-box {
                flex: 1 1 40%;
                min-width: 100px;
            }
            
            /* Convert google drive button to icon on mobile */
            .google-drive-btn {
                padding: 8px;
                font-size: 18px;
                min-width: auto;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            
            .menu-button {
                padding: 8px 12px;
                font-size: 16px;
            }
            
            .menu-button span:last-child {
                margin-left: 3px; /* Less space for arrow */
            }
        }
        
        /* Annotation Toolbar */
        .annotation-toolbar {
            position: fixed;
            top: 60px;
            left: 0;
            bottom: 0;
            width: 80px;
            padding: 20px 8px;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.08);
            display: none;
            z-index: 1001;
            overflow-y: auto;
        }

        .annotation-toolbar.active {
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            width: 25px;
            opacity: 0.9;
            padding: 8px 0;
        }

        .annotation-tool-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .annotation-tool-group:last-child {
            margin-bottom: 0;
        }

        .annotation-tool {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            user-select: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            opacity: 0.8;
        }

        .annotation-tool:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .annotation-tool.active {
            opacity: 1;
            transform: scale(1.3);
            color: #007bff;
        }

        .annotation-separator {
            width: 1px;
            height: 20px;
            background: #ddd;
            margin: 0 4px;
        }

        .dark-theme .annotation-toolbar.active {
            background: rgba(45, 55, 72, 0.3);
            color: #e0e0e0;
        }

        .dark-theme .annotation-tool {
            color: #e0e0e0;
        }

        .dark-theme .annotation-tool.active {
            color: #4da6ff;
        }

        .sepia-theme .annotation-toolbar.active {
            background: rgba(244, 241, 232, 0.3);
            color: #5d4e37;
        }

        .sepia-theme .annotation-tool {
            color: #5d4e37;
        }

        .sepia-theme .annotation-tool.active {
            color: #8b7556;
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(128, 128, 128, 0.7);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
            opacity: 0.8;
        }
        
        .mobile-btn:hover {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(1.05);
            opacity: 1;
        }
        
        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Dark theme discrete mobile buttons */
        .dark-theme .mobile-btn {
            background: rgba(80, 80, 80, 0.8);
            color: #e0e0e0;
        }
        
        .dark-theme .mobile-btn:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Sepia theme discrete mobile buttons */
        .sepia-theme .mobile-btn {
            background: rgba(139, 117, 86, 0.7);
            color: #f4f1e8;
        }
        
        .sepia-theme .mobile-btn:hover {
            background: rgba(109, 90, 68, 0.9);
        }
        
        /* Show mobile controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: flex !important;
            }
        }
        
        /* Alternative: Show on small screens */
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex !important;
            }
        }
        
        /* Desktop zoom-out button - smaller and more discrete */
        .desktop-zoom-btn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(128, 128, 128, 0.7); /* Discrete gray with transparency */
            color: white;
            border: none;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            transition: all 0.2s ease;
            opacity: 0.8;
        }
        
        .desktop-zoom-btn:hover {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(1.05);
            opacity: 1;
        }
        
        .desktop-zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* Dark theme discrete zoom button */
        .dark-theme .desktop-zoom-btn {
            background: rgba(80, 80, 80, 0.8);
            color: #e0e0e0;
        }
        
        .dark-theme .desktop-zoom-btn:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Sepia theme discrete zoom button */
        .sepia-theme .desktop-zoom-btn {
            background: rgba(139, 117, 86, 0.7);
            color: #f4f1e8;
        }
        
        .sepia-theme .desktop-zoom-btn:hover {
            background: rgba(109, 90, 68, 0.9);
        }
        
        /* Hide desktop button on mobile (where mobile-controls are shown) */
        @media (hover: none) and (pointer: coarse) {
            .desktop-zoom-btn {
                display: none !important;
            }
        }
        
        @media (max-width: 768px) {
            .desktop-zoom-btn {
                display: none !important;
            }
        }

        /* Column View Styles */
        .column-view {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f5f5f5;
            overflow-y: auto;
            padding: 20px;
            z-index: 1;
        }

        .column-container {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .column-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .column-card:hover {
            border-color: #aaa;
        }

        .column-card.search-match {
            border-color: #28a745;
            background: #f8fff9;
        }

        .column-card.selected {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .column-card-content {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .column-card-content h1 {
            font-size: 1.3em;
            margin: 0.5em 0 0.3em 0;
            font-weight: bold;
        }

        .column-card-content h2 {
            font-size: 1.1em;
            margin: 0.4em 0 0.2em 0;
            font-weight: bold;
        }

        .column-card-content h3 {
            font-size: 1em;
            margin: 0.3em 0 0.1em 0;
            font-weight: bold;
        }

        .column-card-image {
            max-width: 100%;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .column-card-annotation {
            font-style: italic;
            color: #666;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .column-card-tags {
            margin-top: 15px;
            font-size: 0.85em;
            color: #666;
        }

        .column-card-tags .tag {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
        }

        /* Dark theme for column view */
        .dark-theme .column-view {
            background: #2d3748;
        }

        .dark-theme .column-card {
            background: #4a5568;
            border-color: #718096;
            color: white;
        }

        .dark-theme .column-card:hover {
            border-color: #a0aec0;
        }

        .dark-theme .column-card.search-match {
            border-color: #48bb78;
            background: #2f4f3f;
        }

        .dark-theme .column-card.selected {
            border-color: #63b3ed;
            background: #2c5aa0;
        }

        /* Sepia theme for column view */
        .sepia-theme .column-view {
            background: #f4f1e8;
        }

        .sepia-theme .column-card {
            background: #faf8f1;
            border-color: #d4c4a8;
            color: #5d4e37;
        }

        .sepia-theme .column-card:hover {
            border-color: #b8a082;
        }

        .sepia-theme .column-card.search-match {
            border-color: #8fbc8f;
            background: #f0f8f0;
        }

        .sepia-theme .column-card.selected {
            border-color: #6b8db5;
            background: #e8f0f8;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <!-- Project Selector -->
        <div class="project-selector">
            <button class="project-button" id="projectButton" onclick="toggleProjectDropdown()">
                <span id="projectName">Nytt projekt</span>
                <span>‚ñº</span>
            </button>
            <div class="project-dropdown" id="projectDropdown">
                <div class="project-dropdown-item" onclick="renameProject()">
                    <span>‚úèÔ∏è</span>
                    <span>Byt namn p√• projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="createNewProject()">
                    <span>‚ûï</span>
                    <span>Nytt projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="showProjectList()">
                    <span>üìÇ</span>
                    <span>√ñppna projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="manageProjects()">
                    <span>üóÇÔ∏è</span>
                    <span>Hantera projekt</span>
                </div>
            </div>
        </div>
        
        <div class="search-box">
            <input type="text" class="search-input" placeholder='S√∂k: "bias and social" OR "not psychology"' id="searchInput">
            <button class="search-select-btn toolbar-btn" id="searchSelectBtn" onclick="selectSearchResults()" style="display: none;">
                üìç Markera funna
            </button>
        </div>
        <div class="tag-filter-box">
            <input type="text" class="tag-filter-input" placeholder='Tags: tech AND psychology NOT done' id="tagFilterInput">
        </div>
        <button class="toolbar-btn" id="annotationToggleBtn" onclick="toggleAnnotationToolbar()" title="Aktivera/inaktivera annotation-verktyg">
            ‚¨ú‚Üí‚≠ï
        </button>
        <button class="toolbar-btn" id="imageUploadBtn" onclick="triggerImageUpload()" title="Tre bildval: Kamera, Galleri, Filv√§ljare">
            üì∑ Bilder
        </button>
        <button class="toolbar-btn" id="viewToggleBtn" onclick="toggleView()" title="V√§xla mellan br√§dvy och kolumnvy">
            üìã Kolumnvy
        </button>
        
        <!-- Mobile controls (hidden on desktop) -->
        <div class="mobile-controls">
            <button class="mobile-btn zoom-out-btn" onclick="zoomOutToCenter()" title="Zooma ut centralt">üîç‚àí</button>
            <button class="mobile-btn new-card-btn" onclick="addNewCard()" title="Nytt kort">‚ûï</button>
        </div>
        <div class="menu-dropdown">
            <button class="menu-button toolbar-btn">
                ‚öôÔ∏è Meny
                <span>‚ñº</span>
            </button>
            <div class="dropdown-content">
                <button onclick="saveBoard()">üíæ Spara (LocalStorage)</button>
                <button onclick="saveWithTimestamp()">üíæ Spara fil</button>
                <button onclick="saveAs()">üíæ Spara som...</button>
                <button onclick="loadBoard()">üìÇ Ladda fil</button>
                <button onclick="exportToJSON()">üìã Exportera JSON</button>
                <button onclick="importFromJSON()">üìÅ Importera JSON</button>
                <button onclick="importFromExtractor()">üì• Fr√•n PDF-Extractor</button>
                <button onclick="toggleGoogleDriveAuth()" id="googleDriveBtn">üîó Google Drive</button>
                <button onclick="toggleMetadataView()" id="metadataBtn">üîç Metadata</button>
                <button onclick="debugDumpPositions()">üêõ Debug Positioner</button>
                <button onclick="toggleDarkTheme()" id="themeBtn">üåô M√∂rkt Tema</button>
                <button onclick="clearBoard()">üóëÔ∏è Rensa</button>
            </div>
        </div>
        
        <!-- Keyboard commands dropdown -->
        <div class="menu-dropdown">
            <button class="menu-button toolbar-btn">
                ‚å®Ô∏è
                <span>‚ñº</span>
            </button>
            <div class="dropdown-content">
                <button onclick="executeCommand('H')">H</button>
                <button onclick="executeCommand('V')">V</button>
                <button onclick="executeCommand('G+V')">G+V</button>
                <button onclick="executeCommand('G+H')">G+H</button>
                <button onclick="executeCommand('G+T')">G+T</button>
                <button onclick="executeCommand('QQ')">QQ</button>
                <button onclick="executeCommand('Q')">Q</button>
                <button onclick="executeCommand('C')">C</button>
                <button onclick="executeCommand('T')">üé® T</button>
                <button onclick="showSortMenu(event)">üìä Sortera</button>
                <button onclick="executeCommand('Pin')">üìå Pin</button>
                <button onclick="executeCommand('Unpin')">üîì Unpin</button>
                <button onclick="executeCommand('Delete')">üóëÔ∏è Delete</button>
                <button onclick="executeCommand('Ctrl+Z')">Ctrl+Z</button>
                <button onclick="executeCommand('Ctrl+Y')">Ctrl+Y</button>
                <button onclick="executeCommand('Ctrl+A')">Ctrl+A</button>
                <button onclick="executeCommand('Ctrl+S')">Ctrl+S</button>
            </div>
        </div>
    </div>
    
    <div class="search-results-info" id="searchInfo"></div>
    <div class="selection-info" id="selectionInfo"></div>
    
    <!-- The invisible ruler -->
    <div id="text-ruler"></div>
    
    <!-- Desktop zoom-out button -->
    <button class="desktop-zoom-btn" onclick="zoomOutToCenter()" title="Zooma ut f√∂r att visa alla kort">üîç</button>
    
    <div id="cy"></div>
    
    <!-- Column view container -->
    <div id="columnView" class="column-view" style="display: none;">
        <div class="column-container" id="columnContainer">
            <!-- Column view cards will be rendered here -->
        </div>
    </div>

    <!-- Annotation Toolbar -->
    <div class="annotation-toolbar" id="annotationToolbar">
        <div class="annotation-tool-group">
            <div class="annotation-tool active" data-tool="select" title="V√§lj och flytta">üîç V√§lj</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="rect" title="Rektangel">‚¨ú</div>
            <div class="annotation-tool" data-tool="circle" title="Cirkel">‚≠ï</div>
            <div class="annotation-tool" data-tool="triangle" title="Triangel">üî∫</div>
            <div class="annotation-tool" data-tool="diamond" title="Diamant">‚óÜ</div>
            <div class="annotation-tool" data-tool="star" title="Stj√§rna">‚≠ê</div>
            <div class="annotation-tool" data-tool="hexagon" title="Hexagon">‚¨¢</div>
        </div>
        <div class="annotation-tool-group">
            <div class="annotation-tool" data-tool="text-small" title="Liten text">üÖ∞Ô∏è S</div>
            <div class="annotation-tool" data-tool="text-medium" title="Medium text">üÖ∞Ô∏è M</div>
            <div class="annotation-tool" data-tool="text-large" title="Stor text">üÖ∞Ô∏è L</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="arrow" title="Pil mellan objekt">‚Üí</div>
            <div class="annotation-tool" data-tool="line" title="Linje mellan objekt">‚ûñ</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="resize" title="Aktivera storleks√§ndring (h√∂gerklick p√• figur)">‚ÜóÔ∏è</div>
        </div>
        <div class="annotation-tool-group">
            <div class="annotation-tool" data-tool="color-red" title="R√∂d f√§rg" style="background: #ff6b6b; color: white;">‚óè</div>
            <div class="annotation-tool" data-tool="color-blue" title="Bl√• f√§rg" style="background: #4ecdc4; color: white;">‚óè</div>
            <div class="annotation-tool" data-tool="color-green" title="Gr√∂n f√§rg" style="background: #45b7d1; color: white;">‚óè</div>
            <div class="annotation-tool" data-tool="color-yellow" title="Gul f√§rg" style="background: #f9ca24; color: white;">‚óè</div>
            <div class="annotation-tool" data-tool="color-purple" title="Lila f√§rg" style="background: #a55eea; color: white;">‚óè</div>
        </div>
    </div>

    <!-- Hidden file inputs for image upload -->
    <input type="file" id="hiddenCameraInput" accept="image/*" multiple capture="camera" style="display: none;">
    <input type="file" id="hiddenGalleryInput" accept="image/*" multiple style="display: none;">

    <script>
        // Global variables
        let cy;
        let searchActive = false;
        let copiedCards = []; // Store copied cards for arrangement commands
        
        // Annotation system variables
        let annotationMode = 'select';
        let annotationColor = '#ff6b6b';
        let connectionStartNode = null;
        let annotationToolbarVisible = false;
        let resizeMode = false;
        
        // Mouse position tracking
        let lastMousePosition = { x: null, y: null };

        // IMAGE HANDLING SYSTEM - Integration with existing architecture
        
        // Detect if user is on mobile/tablet device
        function isMobileDevice() {
            const result = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
            console.log('DEBUG isMobileDevice:', result, 'userAgent:', navigator.userAgent, 'maxTouchPoints:', navigator.maxTouchPoints);
            return result;
        }
        
        // Direct image upload - use the three-choice function directly
        function triggerImageUpload() {
            document.getElementById('hiddenGalleryInput').click();
        }

        // Process uploaded images
        function handleImageFiles(files) {
            Array.from(files).forEach(file => {
                if (file && file.type.startsWith('image/')) {
                    processImage(file).then(imageData => {
                        createImageNode(imageData, file.name);
                    }).catch(err => {
                        console.error('Image processing failed:', err);
                    });
                }
            });
        }

        // Process image to 800px width with S-curve + strong light-gray whitening for handwritten notes (~35-90 KB)
        function processImage(file) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Scale to 800px width for better quality, maintain aspect ratio
                    const ratio = 800 / img.width;
                    canvas.width = 800;
                    canvas.height = Math.round(img.height * ratio);
                    
                    // Draw image to canvas
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Enhance for handwritten notes - moderate contrast improvement
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Simple contrast enhancement without aggressive processing
                        let r = data[i];
                        let g = data[i + 1];
                        let b = data[i + 2];
                        
                        // Calculate grayscale value for contrast enhancement
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // Gentle contrast curve - improve readability without artifacts
                        let enhanced;
                        if (gray < 128) {
                            // Darken text slightly
                            enhanced = gray * 0.8;
                        } else {
                            // Lighten background slightly
                            enhanced = gray + (255 - gray) * 0.3;
                        }
                        
                        // Apply enhancement proportionally to preserve color balance
                        const factor = enhanced / Math.max(gray, 1);
                        
                        data[i] = Math.min(255, Math.max(0, r * factor));
                        data[i + 1] = Math.min(255, Math.max(0, g * factor));
                        data[i + 2] = Math.min(255, Math.max(0, b * factor));
                        // Alpha channel (data[i + 3]) remains unchanged
                    }
                    
                    // Apply the enhanced image data back to canvas
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Try WebP for best quality/size ratio, fallback to PNG, then JPEG
                    let base64;
                    let format = 'unknown';
                    
                    try {
                        // Try WebP first (best compression + quality)
                        base64 = canvas.toDataURL('image/webp', 0.95);
                        if (base64.startsWith('data:image/webp')) {
                            format = 'WebP 95%';
                        } else {
                            throw new Error('WebP not supported');
                        }
                    } catch {
                        try {
                            // Fallback to PNG
                            base64 = canvas.toDataURL('image/png');
                            format = 'PNG (lossless)';
                            
                            // If PNG too large, use max JPEG
                            if (base64.length > 300000) { // ~225KB in base64
                                base64 = canvas.toDataURL('image/jpeg', 1.0);
                                format = 'JPEG 100%';
                            }
                        } catch {
                            // Final fallback
                            base64 = canvas.toDataURL('image/jpeg', 1.0);
                            format = 'JPEG 100%';
                        }
                    }
                    
                    console.log(`üì∑ Using ${format} (${Math.round(base64.length/1024)} KB)`);
                    
                    resolve({
                        data: base64,
                        width: canvas.width,
                        height: canvas.height,
                        originalName: file.name
                    });
                };
                
                img.onerror = () => reject('Image loading failed');
                img.src = URL.createObjectURL(file);
            });
        }

        // Create image node integrated with existing system
        function createImageNode(imageData, filename) {
            const position = getArrangementPosition();
            const nodeId = generateCardId();
            
            // Calculate proper aspect ratio height
            const ratio = imageData.height / imageData.width;
            const calculatedHeight = Math.round(300 * ratio);
            
            cy.add({
                group: 'nodes',
                data: {
                    id: nodeId,
                    type: 'image', // New node type
                    imageData: imageData.data,
                    imageWidth: imageData.width,  // Store original dimensions
                    imageHeight: imageData.height, // Store original dimensions
                    calculatedHeight: calculatedHeight, // Pre-calculated height for arrangement
                    annotation: '',
                    searchableText: '',
                    originalFileName: filename,
                    title: '', // No visible title for images
                    text: '', // Keep consistent with existing structure
                    tags: [],
                    isManualCard: true // Integrate with existing categorization
                },
                position: position
            });

            console.log(`üì∑ Created image node: ${filename} (${Math.round(imageData.data.length/1024)} KB) - ${imageData.width}x${imageData.height} ‚Üí 300x${calculatedHeight}`);
        }

        // Handle paste events (Ctrl+V) for images
        function handlePasteImage(event) {
            const items = event.clipboardData?.items;
            if (!items) return;

            for (let item of items) {
                if (item.type.startsWith('image/')) {
                    event.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        processImage(file).then(imageData => {
                            createImageNode(imageData, 'pasted-image-' + Date.now() + '.jpg');
                        }).catch(err => {
                            console.error('Paste image processing failed:', err);
                        });
                    }
                    break;
                }
            }
        }

        // Handle canvas long press - different behavior for mobile vs desktop
        function handleCanvasLongPress(clientX, clientY) {
            if (isMobileDevice()) {
                // Mobile/tablet: Show image source menu at touch position
                showImageSourceMenu(clientX, clientY);
            } else {
                // Desktop: Paste clipboard content
                pasteClipboardContent(clientX, clientY);
            }
        }
        
        // Paste clipboard content (text or image) at specific position (desktop only)
        async function pasteClipboardContent(clientX, clientY) {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (let item of clipboardItems) {
                    // Check for image first
                    for (let type of item.types) {
                        if (type.startsWith('image/')) {
                            const blob = await item.getAsType(type);
                            const position = getCanvasPosition(clientX, clientY);
                            processImage(blob).then(imageData => {
                                createImageNodeAtPosition(imageData, 'pasted-' + Date.now() + '.jpg', position);
                            }).catch(err => {
                                console.error('Image paste processing failed:', err);
                            });
                            return;
                        }
                    }
                }
                
                // If no image, try text
                const text = await navigator.clipboard.readText();
                if (text && text.trim()) {
                    const position = getCanvasPosition(clientX, clientY);
                    createTextNodeAtPosition(text.trim(), position);
                }
            } catch (err) {
                console.error('Kunde inte komma √•t urklipp:', err);
            }
        }
        
        // Get canvas position from client coordinates
        function getCanvasPosition(clientX, clientY) {
            const cyContainer = document.getElementById('cy');
            const rect = cyContainer.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            
            // Convert to Cytoscape coordinates
            const pan = cy.pan();
            const zoom = cy.zoom();
            
            return {
                x: (relativeX - pan.x) / zoom,
                y: (relativeY - pan.y) / zoom
            };
        }
        
        // Create text node at specific position
        function createTextNodeAtPosition(text, position) {
            const cardId = generateCardId();
            cy.add({
                group: 'nodes',
                data: {
                    id: cardId,
                    label: text,
                    isManualCard: true,
                    tags: [],
                    annotation: '',
                    searchableText: text
                },
                position: position
            });
        }
        
        // Create image node at specific position
        function createImageNodeAtPosition(imageData, filename, position) {
            const calculatedHeight = Math.round((imageData.height / imageData.width) * 300);
            const cardId = generateCardId();
            
            cy.add({
                group: 'nodes',
                data: {
                    id: cardId,
                    label: 'üìù',
                    type: 'image',
                    imageData: imageData.data,
                    imageWidth: imageData.width,
                    imageHeight: imageData.height,
                    calculatedHeight: calculatedHeight,
                    annotation: '',
                    searchableText: '',
                    originalFileName: filename,
                    title: '',
                    text: '',
                    tags: [],
                    isManualCard: true
                },
                position: position
            });
        }


        // Generate unique timestamp-based card ID
        function generateCardId() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            
            const baseId = `${year}${month}${day}-${hour}${minute}${second}`;
            
            // Check if ID already exists, if so add letter suffix
            let uniqueId = baseId;
            let suffix = 'a';
            
            while (cy && cy.getElementById(uniqueId).length > 0) {
                uniqueId = `${baseId}-${suffix}`;
                suffix = String.fromCharCode(suffix.charCodeAt(0) + 1);
                
                // Fallback to numbers if we run out of letters (very unlikely)
                if (suffix > 'z') {
                    const timestamp = Date.now();
                    uniqueId = `${baseId}-${timestamp.toString(36).slice(-3)}`;
                    break;
                }
            }
            
            return uniqueId;
        }
        
        // ====================================================================================================
        // üîß FALLBACK RESIZE FUNCTIONALITY
        // ====================================================================================================
        
        function setupFallbackResize() {
            console.log('üõ†Ô∏è Setting up simple resize with Ctrl+click...');
            
            // Add Ctrl+click OR right-click resize for annotation nodes
            cy.on('cxttap', 'node', function(evt) {
                const node = evt.target;
                console.log('üñ±Ô∏è Right-click on node:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'resizeMode:', resizeMode, 'classes:', node.classes());
                
                if (node.data('isAnnotation') && resizeMode) {
                    console.log('üéØ Processing right-click resize for annotation node...');
                    evt.stopPropagation();
                    evt.preventDefault();
                    
                    const currentWidth = node.data('customWidth') || 120;
                    const currentHeight = node.data('customHeight') || 120;
                    
                    console.log('üìê Current size:', currentWidth, 'x', currentHeight);
                    
                    // Simple resize: cycle through 4 sizes
                    let newWidth, newHeight;
                    
                    if (currentWidth <= 80) {
                        newWidth = 120;
                        newHeight = 120;
                    } else if (currentWidth <= 120) {
                        newWidth = 160;
                        newHeight = 160;
                    } else if (currentWidth <= 160) {
                        newWidth = 200;
                        newHeight = 200;
                    } else {
                        newWidth = 80;
                        newHeight = 80;
                    }
                    
                    console.log('üìè Resizing to:', newWidth, 'x', newHeight);
                    
                    // Update the data properties and force style refresh
                    node.data('customWidth', newWidth);
                    node.data('customHeight', newHeight);
                    
                    // Force Cytoscape to recalculate styles by triggering style refresh
                    node.removeStyle('width height');
                    node.trigger('data');
                    cy.style().update();
                    
                    console.log(`‚úÖ Resized annotation ${node.id()} to ${newWidth}x${newHeight}`);
                    return false;
                }
            });
            
            // Backup: Also try Ctrl+click 
            cy.on('click', 'node', function(evt) {
                const node = evt.target;
                console.log('üñ±Ô∏è Node clicked:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'resizeMode:', resizeMode, 'ctrlKey:', evt.originalEvent?.ctrlKey);
                
                if (node.data('isAnnotation') && resizeMode && evt.originalEvent?.ctrlKey) {
                    console.log('üéØ Processing Ctrl+click resize for annotation node...');
                    evt.stopPropagation();
                    evt.preventDefault();
                    
                    const currentWidth = node.data('customWidth') || 120;
                    const currentHeight = node.data('customHeight') || 120;
                    
                    console.log('üìê Current size:', currentWidth, 'x', currentHeight);
                    
                    // Simple resize: cycle through 4 sizes
                    let newWidth, newHeight;
                    
                    if (currentWidth <= 80) {
                        newWidth = 120;
                        newHeight = 120;
                    } else if (currentWidth <= 120) {
                        newWidth = 160;
                        newHeight = 160;
                    } else if (currentWidth <= 160) {
                        newWidth = 200;
                        newHeight = 200;
                    } else {
                        newWidth = 80;
                        newHeight = 80;
                    }
                    
                    console.log('üìè Resizing to:', newWidth, 'x', newHeight);
                    
                    // Update the data properties and force style refresh
                    node.data('customWidth', newWidth);
                    node.data('customHeight', newHeight);
                    
                    // Force Cytoscape to recalculate styles by triggering style refresh
                    node.removeStyle('width height');
                    node.trigger('data');
                    cy.style().update();
                    
                    console.log(`‚úÖ Resized annotation ${node.id()} to ${newWidth}x${newHeight}`);
                    return false; // Prevent further event handling
                }
            });
            
            console.log('‚úÖ Fallback resize setup complete - Ctrl+click annotations in resize mode');
        }
        
        // ====================================================================================================
        // üé® ANNOTATION SYSTEM FUNCTIONS
        // ====================================================================================================
        
        // Toggle annotation toolbar visibility
        function toggleAnnotationToolbar() {
            annotationToolbarVisible = !annotationToolbarVisible;
            const toolbar = document.getElementById('annotationToolbar');
            const toggleBtn = document.getElementById('annotationToggleBtn');
            
            if (annotationToolbarVisible) {
                toolbar.classList.add('active');
                toggleBtn.style.background = '#28a745';
                console.log('üé® Annotation toolbar activated');
            } else {
                toolbar.classList.remove('active');
                toggleBtn.style.background = '';
                setAnnotationMode('select');
                console.log('üìê Annotation toolbar deactivated');
            }
        }
        
        // Set annotation mode and update UI
        function setAnnotationMode(mode) {
            annotationMode = mode;
            connectionStartNode = null;
            
            // Update tool buttons
            document.querySelectorAll('.annotation-tool').forEach(tool => {
                tool.classList.remove('active');
            });
            
            const activeTool = document.querySelector(`[data-tool="${mode}"]`);
            if (activeTool) {
                activeTool.classList.add('active');
            }
            
            console.log('üéØ Annotation mode set to:', mode);
        }
        
        // Set annotation color
        function setAnnotationColor(color) {
            annotationColor = color;
            console.log('üé® Annotation color set to:', color);
        }
        
        // Toggle resize mode for annotations
        function toggleResizeMode() {
            resizeMode = !resizeMode;
            
            console.log('‚ÜóÔ∏è Resize mode:', resizeMode ? 'enabled' : 'disabled');
            
            // Show user-friendly status message
            if (window.showBriefMessage) {
                if (resizeMode) {
                    window.showBriefMessage('‚ÜóÔ∏è Storleks√§ndring aktiverad - H√∂gerklicka p√• annotations f√∂r att √§ndra storlek');
                } else {
                    window.showBriefMessage('üìê Storleks√§ndring avst√§ngd');
                }
            }
        }
        
        // Create geometric shape annotation
        function createShapeAnnotation(shape, position) {
            const id = generateCardId();
            const shapes = {
                'rect': { shape: 'rectangle', label: '' },
                'circle': { shape: 'ellipse', label: '' },
                'triangle': { shape: 'triangle', label: '' },
                'diamond': { shape: 'diamond', label: '' },
                'star': { shape: 'star', label: '' },
                'hexagon': { shape: 'hexagon', label: '' }
            };
            
            const shapeInfo = shapes[shape] || shapes.rect;
            
            cy.add({
                data: {
                    id: id,
                    label: shapeInfo.label,
                    isAnnotation: true,
                    annotationType: 'shape',
                    shape: shape
                },
                position: position,
                classes: 'annotation-shape'
            });
            
            // Apply color immediately
            const node = cy.getElementById(id);
            node.style('background-color', annotationColor);
            
            console.log(`üî∑ Created ${shape} annotation at`, position);
            return node;
        }
        
        // Create text annotation
        function createTextAnnotation(size, position) {
            const id = generateCardId();
            const sizes = {
                'text-small': { fontSize: '16px', label: 'Liten text' },
                'text-medium': { fontSize: '22px', label: 'Medium text' },
                'text-large': { fontSize: '28px', label: 'Stor text' }
            };
            
            const sizeInfo = sizes[size] || sizes['text-medium'];
            
            cy.add({
                data: {
                    id: id,
                    label: sizeInfo.label,
                    isAnnotation: true,
                    annotationType: 'text',
                    textSize: size
                },
                position: position,
                classes: 'annotation-text'
            });
            
            const node = cy.getElementById(id);
            node.style({
                'font-size': sizeInfo.fontSize,
                'background-color': annotationColor,
                'shape': 'rectangle'
            });
            
            console.log(`üìù Created ${size} text annotation at`, position);
            return node;
        }
        
        // Create connection (arrow or line) between nodes
        function createConnection(sourceNode, targetNode, type) {
            const id = generateCardId();
            const isArrow = type === 'arrow';
            
            cy.add({
                data: {
                    id: id,
                    source: sourceNode.id(),
                    target: targetNode.id(),
                    isAnnotation: true,
                    annotationType: 'connection',
                    connectionType: type
                },
                classes: 'annotation-connection'
            });
            
            const edge = cy.getElementById(id);
            edge.style({
                'line-color': annotationColor,
                'target-arrow-color': annotationColor,
                'target-arrow-shape': isArrow ? 'triangle' : 'none',
                'curve-style': 'bezier',
                'width': 3
            });
            
            console.log(`üîó Created ${type} connection between`, sourceNode.id(), 'and', targetNode.id());
            return edge;
        }
        
        // Edit annotation text function
        function editAnnotationText(node) {
            const currentText = node.data('label') || 'Text';
            
            // Create overlay for editing
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 400px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera annotation text</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editAnnotationText" 
                        style="width: 100%; height: 120px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="text-align: right;">
                    <button id="cancelAnnotationEdit" style="margin-right: 10px; padding: 8px 16px; 
                           background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="saveAnnotationEdit" style="padding: 8px 16px; 
                           background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Spara</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on text area and select all
            const textArea = document.getElementById('editAnnotationText');
            textArea.focus();
            textArea.select();
            
            // Event listeners
            document.getElementById('saveAnnotationEdit').addEventListener('click', function() {
                const newText = textArea.value.trim();
                if (newText) {
                    node.data('label', newText);
                    console.log('‚úÖ Updated annotation text to:', newText);
                }
                document.body.removeChild(overlay);
            });
            
            document.getElementById('cancelAnnotationEdit').addEventListener('click', function() {
                document.body.removeChild(overlay);
            });
            
            // Close on ESC key
            overlay.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                }
            });
            
            // Close on overlay click (outside dialog)
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        // MINIMAL UNDO/REDO SYSTEM - Define early so functions can use it
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 20;
        
        // Generate unique timestamp-based ID for new cards
        function generateUniqueId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() +
                            (now.getMonth() + 1).toString().padStart(2, '0') +
                            now.getDate().toString().padStart(2, '0') + '-' +
                            now.getHours().toString().padStart(2, '0') +
                            now.getMinutes().toString().padStart(2, '0') +
                            now.getSeconds().toString().padStart(2, '0');
            
            return timestamp + '-copy';
        }
        
        // Save current state for undo
        function saveState() {
            try {
                const state = {
                    timestamp: Date.now(),
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        data: node.data(),
                        position: { x: node.position().x, y: node.position().y },
                        selected: node.selected(),
                        classes: node.classes().join(' ')
                    }))
                };
                
                undoStack.push(state);
                if (undoStack.length > MAX_UNDO_STEPS) {
                    undoStack.shift(); // Remove oldest
                }
                redoStack = []; // Clear redo when new action
                console.log('State saved, undo stack size:', undoStack.length);
            } catch (error) {
                console.warn('Failed to save state:', error);
            }
        }
        
        // Restore state for undo/redo
        function restoreState(state) {
            if (!state || !state.cards) return false;
            
            try {
                // Clear current state
                cy.nodes().remove();
                
                // Recreate all cards from saved state
                state.cards.forEach(cardState => {
                    const newNode = cy.add({
                        data: cardState.data,
                        position: cardState.position
                    });
                    
                    // Restore classes (like 'pinned')
                    if (cardState.classes) {
                        newNode.addClass(cardState.classes);
                    }
                    
                    // Make draggable
                    newNode.grabify();
                    
                    // Restore selection
                    if (cardState.selected) {
                        newNode.select();
                    }
                });
                
                console.log('State restored');
                return true;
            } catch (error) {
                console.warn('Failed to restore state:', error);
                return false;
            }
        }
        
        // Get arrangement position based on mouse or fallback to screen center
        function getArrangementPosition() {
            // If we have a valid mouse position, use it
            if (lastMousePosition.x !== null && lastMousePosition.y !== null) {
                // Convert browser coordinates to cytoscape model coordinates
                const cyContainer = cy.container();
                const containerRect = cyContainer.getBoundingClientRect();
                const relativeX = lastMousePosition.x - containerRect.left;
                const relativeY = lastMousePosition.y - containerRect.top;
                
                // Convert to cytoscape world coordinates
                const pan = cy.pan();
                const zoom = cy.zoom();
                const modelX = (relativeX - pan.x) / zoom;
                const modelY = (relativeY - pan.y) / zoom;
                
                console.log('Mouse position conversion:', {
                    mouse: lastMousePosition,
                    container: containerRect,
                    relative: {x: relativeX, y: relativeY},
                    pan, zoom,
                    model: {x: modelX, y: modelY}
                });
                
                return { x: modelX, y: modelY };
            }
            
            // Fallback to visible viewport center (better for mobile)
            const viewportCenter = cy.pan();
            const zoom = cy.zoom();
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Calculate center of visible viewport in model coordinates  
            const visibleCenterX = (-viewportCenter.x + containerWidth/2) / zoom;
            const visibleCenterY = (-viewportCenter.y + containerHeight/2) / zoom;
            
            console.log('Using visible viewport center:', {
                x: visibleCenterX,
                y: visibleCenterY,
                pan: viewportCenter,
                zoom: zoom,
                container: {w: containerWidth, h: containerHeight}
            });
            
            return {
                x: visibleCenterX,
                y: visibleCenterY
            };
        }
        
        // Text measurement using invisible ruler
        let textRuler = null;
        
        function initTextRuler() {
            textRuler = document.getElementById('text-ruler');
        }
        
        // Memoization cache for getMeasuredTextHeight
        const heightCache = new Map();
        
        // Generate content hash for memoization
        function getContentHash(node) {
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = node.data('tags') || [];
            const isImported = node.data('export_source') === 'pdf_extractor' || 
                             node.data('source_file') || 
                             node.data('matched_terms');
            const isWelcomeCard = node.id().startsWith('welcome-');
            
            // Create hash from content and styling factors
            return `${title}|${text}|${tags.join(',')}|${isImported}|${isWelcomeCard}`;
        }
        
        // Clear cache for a specific node (when content changes)
        function clearNodeCache(node) {
            // Remove all cached entries that might match this node
            // We need to remove by pattern since content might have changed
            const nodeId = node.id();
            const keysToDelete = [];
            for (const key of heightCache.keys()) {
                // Simple heuristic: if cache gets too large, clear it periodically
                if (heightCache.size > 500) {
                    heightCache.clear();
                    break;
                }
            }
        }
        
        /**
         * Measures the actual rendered height of a node's text using the invisible ruler (with memoization).
         * @param {object} node The Cytoscape node.
         * @returns {number} The measured height of the text in pixels.
         */
        function getMeasuredTextHeight(node) {
            // SPECIAL HANDLING FOR IMAGE NODES
            if (node.data('type') === 'image' && node.data('imageData')) {
                // Use pre-calculated height if available (for new images)
                const preCalculated = node.data('calculatedHeight');
                if (preCalculated) {
                    return preCalculated;
                }
                
                // For imported images, calculate from stored dimensions
                const imageWidth = node.data('imageWidth');
                const imageHeight = node.data('imageHeight');
                if (imageWidth && imageHeight) {
                    const ratio = imageHeight / imageWidth;
                    return Math.round(300 * ratio); // 300px width, maintain aspect ratio
                }
                
                // Last resort: Use a reasonable default to avoid creating Image objects
                // which can be expensive and cause performance issues
                return 260; // Safe default for images - avoid creating Image objects
            }
            
            // NORMAL TEXT NODE PROCESSING
            // Check cache first
            const hash = getContentHash(node);
            if (heightCache.has(hash)) {
                return heightCache.get(hash);
            }
            
            if (!textRuler) initTextRuler();
            
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = node.data('tags') || [];
            
            // Get the final text content without custom wrapping
            let rawText = text.replace(/\*\*|`|\*|\[|\]/g, '').replace(/^- /gm, '‚Ä¢ ');
            
            // Add tags to the measurement
            let tagDisplay = '';
            if (tags.length > 0) {
                tagDisplay = '\n\n' + tags.map(tag => `#${tag}`).join(' ');
            }
            
            const mainText = title ? `${title.toUpperCase()}\n\n${rawText}` : rawText;
            const fullLabel = mainText + tagDisplay;

            // Use EXACT same text-max-width calculation as Cytoscape will use
            const nodeWidth = 300; // Fixed width for all cards
            const textMaxWidth = nodeWidth - 15;

            // Style the ruler to match the node's text properties EXACTLY
            textRuler.style.width = `${textMaxWidth}px`;
            textRuler.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            
            // Use same font-size logic as the Cytoscape style
            const isImported = node.data('export_source') === 'pdf_extractor' || 
                             node.data('source_file') || 
                             node.data('matched_terms');
            const isWelcomeCard = node.id().startsWith('welcome-');
            
            // Imported cards and welcome cards get 18px, all others get 23px
            textRuler.style.fontSize = (isImported || isWelcomeCard) ? '18px' : '23px';
            textRuler.style.lineHeight = '1.2';
            textRuler.style.padding = '0';
            textRuler.style.margin = '0';
            textRuler.style.border = 'none';
            textRuler.style.textAlign = 'center'; // Match Cytoscape text alignment
            textRuler.style.wordWrap = 'break-word';
            
            // Set the text and measure
            textRuler.textContent = fullLabel;
            const measuredTextHeight = textRuler.offsetHeight;
            
            // Add padding that Cytoscape applies to cards
            // Cards need minimum padding for visual breathing room
            const minCardHeight = 140; // 140px minimum height
            
            // Dynamic padding: less padding for longer text, more for short text
            let paddingBuffer;
            if (measuredTextHeight <= 50) {
                paddingBuffer = 25; // Short text needs more padding
            } else if (measuredTextHeight <= 100) {
                paddingBuffer = 20; // Medium text gets normal padding
            } else if (measuredTextHeight <= 200) {
                paddingBuffer = 15; // Long text needs less extra padding
            } else {
                paddingBuffer = 10; // Very long text needs minimal padding
            }
            
            const totalHeight = Math.max(minCardHeight, measuredTextHeight + paddingBuffer);
            
            // Cache the result
            heightCache.set(hash, totalHeight);
            
            return totalHeight;
        }
        
        // Subtle orphan prevention - use non-breaking spaces to keep last 2-3 words together
        function preventOrphansSubtly(text) {
            const words = text.split(' ');
            
            // If text is short, don't modify
            if (words.length <= 4) return text;
            
            // Join last 2-3 words with non-breaking spaces to prevent orphan words
            const lastWords = words.slice(-3); // Last 3 words
            const beforeWords = words.slice(0, -3); // Everything before last 3 words
            
            // Use non-breaking space (Unicode 00A0) to keep last words together
            const joinedLastWords = lastWords.join('\u00A0');
            
            return beforeWords.length > 0 ? 
                beforeWords.join(' ') + ' ' + joinedLastWords : 
                joinedLastWords;
        }
        
        // Sample data - strukturerade kort med titel och text (arrangerade med G+V layout)
        const initialCards = [
            {
                id: 'welcome-1',
                title: 'üëã V√§lkommen till Spatial Notes!',
                text: 'Visuell anteckningsapp d√§r du organiserar tankar i 2D-rum.\n\nBETA-VERSION: Allt funkar inte hundra. Spara ofta!\n\nH√§lsningar Ximon\n\nMail: spatial-notes@ximon.se\n\n(r√§kna inte med svar)',
                tags: ['v√§lkommen'],
                x: 667,
                y: 193
            },
            {
                id: 'welcome-2', 
                title: 'üéØ Grundl√§ggande',
                text: 'SKAPA KORT: Klicka "Nytt kort" eller dubbelklicka i tom yta\n\nTA BORT: V√§lj kort ‚Üí Delete-tangent\n\nMARKERA: Klicka kort (h√•ll Ctrl f√∂r flera) eller dra-markera\n\nFLYTTA: H√•ll nere muspekare p√• det du vill flytta och flytta muspeklaren\n\n√ÖNGRA/G√ñR OM: Ctrl+Z / Ctrl+Y',
                tags: ['grunderna'],
                x: 987,
                y: 204
            },
            {
                id: 'welcome-3',
                title: 'üìê Arrangera Kort',
                text: 'Markera flera kort, tryck sedan:\n\nH = Horisontell rad (20% mellanrum)\nV = Vertikal kolumn (20% mellanrum)\n\nG+V = Grid Vertical (max 6 bred, 20% mellanrum)\nG+H = Grid Horizontal (rader, 20% mellan rader)\nG+T = Grid Tight (max 6 bred, 40px √∂verlapp)\n\nQ = Kluster (sporadisk skr√§ph√∂g)\nQQ = Stack (prydlig h√∂g, dubbla Q)\nAlt+S = Stack (samma som QQ)\n\nKorten arrangeras runt muspekaren!',
                tags: ['arrangemang'],
                x: 1307,
                y: 247
            },
            {
                id: 'welcome-4',
                title: 'üìå Pinna Kort',
                text: 'PINNA: H√∂gerklicka kort ‚Üí "Pinna kort"\n\nUNPINNA: H√∂gerklicka ‚Üí "Ta bort pinning"\n\nF√ñRDELAR:\n\nPinnae kort stannar p√• plats\n\nKopiera kort och pinna originalen\n\nFlytta kopior medan original √§r s√§kra\n\nPerfekt f√∂r att organisera id√©er!',
                tags: ['pinning'],
                x: 667,
                y: 642
            },
            {
                id: 'welcome-5',
                title: 'üöÄ Next Level: Kopiera + Arrangera',
                text: '1. Markera kort du vill kopiera\n\n2. Tryck C f√∂r att kopiera\n\n3. Anv√§nd H, G+V, G+H, G+T eller Q\n\nKopiorna arrangeras runt muspekaren!',
                tags: ['kopiera', 'avancerat'],
                x: 987,
                y: 598
            },
            {
                id: 'welcome-6',
                title: 'üî• The Shit: S√∂k + Arrangera',
                text: '1. S√ñK: Skriv i s√∂krutan f√∂r att hitta kort\n\n2. MARKERA: Tryck Enter f√∂r att v√§lja alla s√∂kresultat\n\n3. ARRANGERA: Anv√§nd H, G+V, G+H, G+T eller Q f√∂r att arrangera\n\n4. KOPIERA: Eller tryck C och arrangera kopior!\n\nDu kan ocks√• s√∂ka ‚Üí kopiera ‚Üí arrangera. Epic!',
                tags: ['s√∂kning', 'expert'],
                x: 1307,
                y: 728
            }
        ];
        

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                
                elements: initialCards.map((card, index) => ({
                    data: {
                        id: card.id,
                        title: card.title || '',
                        text: card.text || '', 
                        tags: card.tags || [],
                        searchMatch: false,
                        // Hidden metadata for advanced analysis
                        export_timestamp: card.export_timestamp || null,
                        export_session: card.export_session || null,
                        export_source: card.export_source || null,
                        source_file: card.source_file || null,
                        page_number: card.page_number || null,
                        matched_terms: card.matched_terms || null,
                        card_index: card.card_index || null
                    },
                    position: {
                        x: card.x !== undefined ? card.x : (200 + (index % 3) * 300),
                        y: card.y !== undefined ? card.y : (200 + Math.floor(index / 3) * 200)
                    }
                })),
                
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#ffffff',
                            'border-width': 2,
                            'border-color': '#ddd',
                            'width': function(node) {
                                // Skip width override for annotation nodes (they have their own sizing)
                                if (node.data('isAnnotation')) {
                                    return node.data('customWidth') || 120;
                                }
                                // Fixed width for all cards to ensure consistency
                                return 300;
                            },
                            'height': function(node) {
                                // Skip height override for annotation nodes (they have their own sizing)
                                if (node.data('isAnnotation')) {
                                    return node.data('customHeight') || 120;
                                }
                                
                                const isManualCard = node.data('isManualCard') || false;
                                
                                if (isManualCard) {
                                    // Same padding logic as other cards, but with double padding
                                    const measuredHeight = getMeasuredTextHeight(node);
                                    return Math.max(140, measuredHeight + 40); // Double padding for larger text
                                }
                                
                                // Use the ruler to get exact height for other cards
                                const measuredHeight = getMeasuredTextHeight(node);
                                return Math.max(140, measuredHeight + 10); // Standard padding, 140px minimum
                            },
                            'shape': 'round-rectangle',
                            'label': function(node) {
                                const title = node.data('title') || '';
                                const text = node.data('text') || '';
                                const tags = node.data('tags') || [];
                                const isManualCard = node.data('isManualCard') || false;
                                
                                
                                // Simple markdown conversion for display
                                let displayText = text;
                                displayText = displayText.replace(/\*\*(.*?)\*\*/g, '$1'); // Remove **bold**
                                displayText = displayText.replace(/\*(.*?)\*/g, '$1'); // Remove *italic*
                                displayText = displayText.replace(/`(.*?)`/g, '$1'); // Remove `code`
                                displayText = displayText.replace(/^- /gm, '‚Ä¢ '); // Convert - to bullets
                                
                                // Apply subtle orphan prevention using non-breaking spaces
                                displayText = preventOrphansSubtly(displayText);
                                
                                // Add tags at the bottom if they exist (filter out PDF filename tags)
                                let tagDisplay = '';
                                if (tags.length > 0) {
                                    // Filter out tags that look like PDF filenames (author-year-title format)
                                    const visibleTags = tags.filter(tag => {
                                        // Hide tags that match PDF filename pattern: Author-YYYY-title-words
                                        const pdfPattern = /^[A-Za-z\-]+\-\d{4}\-[a-z\-]+$/;
                                        return !pdfPattern.test(tag);
                                    });
                                    
                                    if (visibleTags.length > 0) {
                                        tagDisplay = '\n\n' + visibleTags.map(tag => `#${tag}`).join(' ');
                                    }
                                }
                                
                                // For manually created cards, show ONLY text (no title processing)
                                // For imported cards, show title in caps + text
                                const mainText = (isManualCard || !title) ? displayText : `${title.toUpperCase()}\n\n${displayText}`;
                                return mainText + tagDisplay;
                            },
                            'text-wrap': 'wrap',
                            'text-max-width': 285, // Fixed 285px for all cards to match getMeasuredTextHeight ruler
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': function(node) {
                                const isImported = node.data('export_source') === 'pdf_extractor' || 
                                                 node.data('source_file') || 
                                                 node.data('matched_terms');
                                const isWelcomeCard = node.id().startsWith('welcome-');
                                
                                // Imported cards and welcome cards get 18px
                                if (isImported || isWelcomeCard) {
                                    return 18;
                                }
                                
                                // ALL other cards (manual) get 23px
                                return 23;
                            },
                            'font-family': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                            'color': '#333'
                        }
                    },
                    {
                        selector: 'node.search-match',
                        style: {
                            'background-color': '#fff9c4',
                            'border-color': '#f57f17',
                            'border-width': 2
                        }
                    },
                    {
                        selector: 'node.tag-filtered',
                        style: {
                            'background-color': '#f0f0f0',
                            'border-color': '#ddd',
                            'opacity': 0.3
                        }
                    },
                    {
                        selector: 'node.search-non-match',
                        style: {
                            'opacity': 0.3
                        }
                    },
                    {
                        selector: 'node:selected',
                        style: {
                            'border-color': '#1565c0',
                            'border-width': 4
                        }
                    },
                    {
                        selector: 'node.pinned',
                        style: {
                            'border-color': '#2e7d32',
                            'border-width': 4,
                            'background-color': '#c8e6c9'
                        }
                    },
                    // ====================================================================================================
                    // üì∑ IMAGE NODE STYLES - Post-it feel (~10cm) with image background
                    // ====================================================================================================
                    {
                        selector: 'node[type="image"]',
                        style: {
                            'width': 300, // Same as regular cards
                            'height': function(node) {
                                // Use the same logic as getMeasuredTextHeight for consistency
                                return getMeasuredTextHeight(node);
                            },
                            'background-image': 'data(imageData)',
                            'background-fit': 'cover',
                            'background-color': function(node) {
                                // Support color styling for image cards
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                    return colorValue;
                                }
                                return '#ffffff'; // Default white background
                            },
                            'border-width': function(node) {
                                // Thicker border when colored to show the color better
                                const cardColor = node.data('cardColor');
                                return cardColor ? 6 : 3;
                            },
                            'border-color': function(node) {
                                // Use the card color for border, or default gray
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                    return colorValue;
                                }
                                return '#ddd';
                            },
                            'shape': 'round-rectangle',
                            'label': function(node) {
                                // Only show annotation icon if present, no filename
                                const hasAnnotation = (node.data('annotation') || '').length > 0;
                                return hasAnnotation ? 'üìù' : '';
                            },
                            'text-valign': 'bottom',
                            'text-halign': 'center',
                            'text-background-color': 'rgba(255, 255, 255, 0.9)',
                            'text-background-padding': '4px',
                            'text-background-shape': 'round-rectangle',
                            'font-size': '14px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': 280
                        }
                    },
                    {
                        selector: 'node[type="image"]:selected',
                        style: {
                            'border-color': '#1565c0',
                            'border-width': 5
                        }
                    },
                    {
                        selector: 'node[type="image"].search-match',
                        style: {
                            'border-color': '#f57f17',
                            'border-width': 4
                        }
                    },
                    // ====================================================================================================
                    // üé® ANNOTATION STYLES
                    // ====================================================================================================
                    {
                        selector: 'node.annotation-shape',
                        style: {
                            'width': function(node) {
                                // Allow dynamic width for annotation shapes
                                return node.data('customWidth') || 120;
                            },
                            'height': function(node) {
                                // Allow dynamic height for annotation shapes
                                return node.data('customHeight') || 120;
                            },
                            'background-color': '#ff6b6b',
                            'border-width': 3,
                            'border-color': '#444',
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '32px',
                            'color': '#333',
                            'text-wrap': 'none',
                            'z-index': function(node) {
                                // Cytoscape z-index must be non-negative integers
                                // 0 = background, 1 = normal, 2 = foreground
                                const zIndex = node.data('customZIndex');
                                if (zIndex === -1) return 0; // Background
                                if (zIndex === 0) return 1;  // Normal
                                if (zIndex === 1) return 2;  // Foreground
                                return 1; // Default to normal
                            },
                            'shape': function(node) {
                                const shape = node.data('shape') || 'rectangle';
                                const shapeMap = {
                                    'rect': 'rectangle',
                                    'circle': 'ellipse',
                                    'triangle': 'triangle',
                                    'diamond': 'diamond',
                                    'star': 'star',
                                    'hexagon': 'hexagon'
                                };
                                return shapeMap[shape] || 'rectangle';
                            }
                        }
                    },
                    {
                        selector: 'node.annotation-text',
                        style: {
                            'width': function(node) {
                                // Allow dynamic width for annotation text
                                return node.data('customWidth') || 180;
                            },
                            'height': function(node) {
                                // Allow dynamic height for annotation text
                                return node.data('customHeight') || 90;
                            },
                            'background-color': '#fff',
                            'border-width': 2,
                            'border-color': '#ccc',
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '18px',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': function(node) {
                                // Adjust text width based on node width
                                const width = node.data('customWidth') || 180;
                                return (width - 10) + 'px';
                            },
                            'shape': 'rectangle'
                        }
                    },
                    {
                        selector: 'edge.annotation-connection',
                        style: {
                            'width': 6,
                            'line-color': '#ff6b6b',
                            'target-arrow-color': '#ff6b6b',
                            'curve-style': 'bezier',
                            'control-point-step-size': 40
                        }
                    }
                ],
                
                layout: {
                    name: 'preset'
                },
                
                // Enable panning and zooming
                zoomingEnabled: true,
                userZoomingEnabled: true,
                wheelSensitivity: 0.3,
                minZoom: 0.1,
                maxZoom: 3,
                panningEnabled: false,  // Start with panning disabled
                userPanningEnabled: true,  // Keep user controls available
                boxSelectionEnabled: true,
                selectionType: 'additive',  // Allow multiple selection
                
                // Configure user interaction
                autoungrabify: false,
                autounselectify: false
            });
            
            // Make nodes draggable
            cy.nodes().grabify();
            
            // Save state before dragging starts (for undo support)
            cy.on('grab', 'node', function(evt) {
                saveState();
            });
            
            // Double-click to edit card
            cy.on('dblclick', 'node', function(evt) {
                const node = evt.target;
                console.log('üñ±Ô∏è Double-click on node:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'classes:', node.classes());
                
                if (node.data('isAnnotation') && node.hasClass('annotation-text')) {
                    console.log('üìù Opening text editor for annotation text...');
                    editAnnotationText(node);
                } else {
                    console.log('üìù Opening card editor for regular node...');
                    editCard(node);
                }
            });
            
            // Right-click context menu
            cy.on('cxttap', 'node', function(evt) {
                evt.preventDefault();
                const node = evt.target;
                showContextMenu(evt.originalEvent || evt, node);
            });
            
            // Touch and hold to edit card on mobile
            let touchTimer = null;
            let touchedNode = null;
            
            cy.on('touchstart', 'node', function(evt) {
                touchedNode = evt.target;
                touchTimer = setTimeout(() => {
                    if (touchedNode) {
                        editCard(touchedNode);
                        touchedNode = null;
                    }
                }, 1000); // 1 second hold
            });
            
            cy.on('touchend touchmove', 'node', function(evt) {
                if (touchTimer) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
                if (evt.type === 'touchend') {
                    touchedNode = null;
                }
            });
            
            // Update selection info when selection changes
            cy.on('select unselect', 'node', function(evt) {
                updateSelectionInfo();
            });
            
            // ====================================================================================================
            // üé® ANNOTATION EVENT HANDLERS
            // ====================================================================================================
            
            // Canvas click for creating annotations
            cy.on('tap', function(evt) {
                if (!annotationToolbarVisible || annotationMode === 'select') return;
                
                // Only create on background, not on nodes
                if (evt.target === cy) {
                    const position = evt.position || evt.cyPosition;
                    
                    if (['rect', 'circle', 'triangle', 'diamond', 'star', 'hexagon'].includes(annotationMode)) {
                        createShapeAnnotation(annotationMode, position);
                    } else if (['text-small', 'text-medium', 'text-large'].includes(annotationMode)) {
                        createTextAnnotation(annotationMode, position);
                    }
                }
            });
            
            // Node click for connections
            cy.on('tap', 'node', function(evt) {
                if (!annotationToolbarVisible) return;
                
                const node = evt.target;
                
                if (annotationMode === 'arrow' || annotationMode === 'line') {
                    if (!connectionStartNode) {
                        // First click - select start node
                        connectionStartNode = node;
                        node.style('border-color', '#ff0000');
                        node.style('border-width', '4px');
                        console.log('üéØ Connection start node selected:', node.id());
                    } else if (connectionStartNode !== node) {
                        // Second click - create connection
                        createConnection(connectionStartNode, node, annotationMode);
                        
                        // Reset start node styling
                        connectionStartNode.style('border-color', '');
                        connectionStartNode.style('border-width', '');
                        connectionStartNode = null;
                        
                        console.log('‚úÖ Connection created');
                    }
                }
            });
            
            // Track mouse position for arrangement positioning
            cy.on('mousemove', function(evt) {
                lastMousePosition.x = evt.originalEvent.clientX;
                lastMousePosition.y = evt.originalEvent.clientY;
            });
            
            // Also track mouse on the container directly
            document.addEventListener('mousemove', function(evt) {
                lastMousePosition.x = evt.clientX;
                lastMousePosition.y = evt.clientY;
                // Debug: uncomment to see if mouse tracking works
                // console.log('Mouse moved to:', evt.clientX, evt.clientY);
            });
            
            // ====================================================================================================
            // üé® ANNOTATION TOOLBAR EVENT LISTENERS
            // ====================================================================================================
            
            // Add click listeners to annotation tools
            document.querySelectorAll('.annotation-tool').forEach(tool => {
                tool.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const toolType = tool.dataset.tool;
                    
                    if (toolType.startsWith('color-')) {
                        // Color selection
                        const colors = {
                            'color-red': '#ff6b6b',
                            'color-blue': '#4ecdc4', 
                            'color-green': '#45b7d1',
                            'color-yellow': '#f9ca24',
                            'color-purple': '#a55eea'
                        };
                        setAnnotationColor(colors[toolType]);
                    } else if (toolType === 'resize') {
                        // Toggle resize mode
                        toggleResizeMode();
                        tool.classList.toggle('active', resizeMode);
                    } else {
                        // Tool selection
                        setAnnotationMode(toolType);
                    }
                });
            });
            
            // Starta med panorering p√•, s√• att zoom fungerar direkt
            cy.panningEnabled(true);
            
            // Auto-center on mobile devices after initial load
            if (window.matchMedia && window.matchMedia("(max-width: 768px)").matches) {
                setTimeout(() => {
                    cy.fit(null, 50); // Fit all nodes with 50px padding
                    cy.center(); // Center the view
                    console.log('Mobile auto-center applied');
                }, 500); // Small delay to ensure nodes are rendered
            }
            
            // Re-center when orientation changes on mobile
            window.addEventListener('orientationchange', function() {
                if (window.matchMedia && window.matchMedia("(max-width: 768px)").matches) {
                    setTimeout(() => {
                        cy.fit(null, 50);
                        cy.center();
                        console.log('Mobile orientation-change auto-center applied');
                    }, 300);
                }
            });

            // Hantera Ctrl+drag f√∂r att v√§xla mellan panorering och markeringsruta
            cy.on('mousedown', function(evt) {
                if (evt.originalEvent.ctrlKey) {
                    // Med Ctrl nedtryckt: aktivera panorering, inaktivera markeringsruta
                    cy.boxSelectionEnabled(false);
                    cy.panningEnabled(true);
                } else {
                    // Utan Ctrl: inaktivera panorering, aktivera markeringsruta
                    cy.boxSelectionEnabled(true);
                    cy.panningEnabled(false);
                }
            });

            cy.on('mouseup', function(evt) {
                // √Öterst√§ll alltid till att panorering √§r p√•, s√• att zoom fungerar igen
                cy.panningEnabled(true);
                cy.boxSelectionEnabled(true);
            });

            // ====================================================================================================
            // üì∑ IMAGE SYSTEM EVENT LISTENERS - Integration with existing architecture
            // ====================================================================================================
            
            // File input change handlers
            document.getElementById('hiddenCameraInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleImageFiles(e.target.files);
                    // Reset input to allow same file again
                    e.target.value = '';
                }
            });
            
            document.getElementById('hiddenGalleryInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleImageFiles(e.target.files);
                    // Reset input to allow same file again
                    e.target.value = '';
                }
            });
            
            // Paste event listener for Ctrl+V images
            document.addEventListener('paste', handlePasteImage);
            
            // Long press on canvas to paste clipboard content (text or image)
            let canvasPressTimer = null;
            const cyContainer = document.getElementById('cy');
            
            // Canvas background long press using Cytoscape events
            let backgroundTouchTimer = null;
            let backgroundTouchPos = null;
            
            // Touch handling on canvas background (not on nodes)
            cy.on('touchstart', function(evt) {
                console.log('DEBUG touchstart:', evt.target, 'target===cy:', evt.target === cy, 'touches:', evt.originalEvent?.touches?.length);
                if (!evt.target || evt.target === cy) { // Background touch
                    const touch = evt.originalEvent.touches[0];
                    backgroundTouchPos = { clientX: touch.clientX, clientY: touch.clientY };
                    let backgroundTouchStartTime = Date.now();
                    console.log('DEBUG background touchstart, pos:', backgroundTouchPos);
                    
                    backgroundTouchTimer = setTimeout(() => {
                        console.log('DEBUG LONG PRESS timeout fired, isMobileDevice():', isMobileDevice(), 'backgroundTouchPos:', backgroundTouchPos);
                        if (isMobileDevice() && backgroundTouchPos) {
                            // Check if we have selected cards
                            const selectedNodes = cy.$('node:selected');
                            console.log('DEBUG selectedNodes.length:', selectedNodes.length);
                            if (selectedNodes.length > 0) {
                                // Show mobile card menu for selected cards
                                console.log('DEBUG calling showMobileCardMenu with pos:', backgroundTouchPos, 'nodeId:', selectedNodes[0].id());
                                showMobileCardMenu(backgroundTouchPos, selectedNodes[0].id());
                            } else {
                                // Show image source menu if no cards selected
                                console.log('DEBUG calling showImageSourceMenu');
                                showImageSourceMenu(backgroundTouchPos.clientX, backgroundTouchPos.clientY);
                            }
                        }
                        backgroundTouchStartTime = null; // Mark as long press handled
                    }, 1000);
                    
                    // Store start time for short tap detection
                    evt._boardTouchStartTime = backgroundTouchStartTime;
                }
            });
            
            cy.on('touchend', function(evt) {
                if (backgroundTouchTimer) {
                    clearTimeout(backgroundTouchTimer);
                    backgroundTouchTimer = null;
                }
                
                if (backgroundTouchPos && evt._boardTouchStartTime && (!evt.target || evt.target === cy)) {
                    const tapDuration = Date.now() - evt._boardTouchStartTime;
                    console.log('DEBUG board background touch end, duration:', tapDuration);
                    
                    if (tapDuration < 300) { // Short tap
                        console.log('DEBUG board background short tap - deselecting all cards');
                        cy.nodes().unselect();
                    }
                }
                
                backgroundTouchPos = null;
            });
            
            cy.on('touchmove', function(evt) {
                if (backgroundTouchTimer) {
                    clearTimeout(backgroundTouchTimer);
                    backgroundTouchTimer = null;
                    backgroundTouchPos = null;
                }
            });
            
            // Desktop mouse handling on background
            cy.on('mousedown', function(evt) {
                if (!evt.target || evt.target === cy) { // Background click
                    const mouseEvent = evt.originalEvent;
                    let mouseDownTime = Date.now();
                    
                    canvasPressTimer = setTimeout(() => {
                        if (!isMobileDevice()) {
                            pasteClipboardContent(mouseEvent.clientX, mouseEvent.clientY);
                        }
                        mouseDownTime = null; // Mark as long press handled
                    }, 1000);
                    
                    evt._mouseDownTime = mouseDownTime;
                }
            });
            
            cy.on('mouseup', function(evt) {
                if (canvasPressTimer) {
                    clearTimeout(canvasPressTimer);
                    canvasPressTimer = null;
                }
                
                if (evt._mouseDownTime && (!evt.target || evt.target === cy)) {
                    const clickDuration = Date.now() - evt._mouseDownTime;
                    console.log('DEBUG board background click end, duration:', clickDuration);
                    
                    if (clickDuration < 300) { // Short click
                        console.log('DEBUG board background short click - deselecting all cards');
                        cy.nodes().unselect();
                    }
                }
            });
            
            cy.on('mousemove', function(evt) {
                if (canvasPressTimer) {
                    clearTimeout(canvasPressTimer);
                    canvasPressTimer = null;
                }
            });
            
            // Drag and drop support (bonus functionality)
            // cyContainer already declared above
            cyContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
            
            cyContainer.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type.startsWith('image/')
                );
                
                if (files.length > 0) {
                    handleImageFiles(files);
                    console.log(`üì∑ ${files.length} bild(er) droppade`);
                }
            });
            
            // Background click events temporarily disabled to test zoom
            // TODO: Re-enable with zoom preservation
            
            // Disable context menu on right click
            cy.container().addEventListener('contextmenu', function(evt) {
                evt.preventDefault();
            });
            
            // ====================================================================================================
            // üéØ SIMPLE RESIZE SYSTEM
            // ====================================================================================================
            
            // Setup simple resize functionality using mouse events
            console.log('üîÑ Setting up simple resize functionality...');
            setupFallbackResize();
            
            
        }
        
        // Boolean search functionality
        function performSearch(query) {
            if (!query.trim()) {
                clearSearch();
                return;
            }
            
            searchActive = true;
            let matchCount = 0;
            
            cy.nodes().forEach(node => {
                const title = (node.data('title') || '').toLowerCase();
                const text = (node.data('text') || '').toLowerCase();
                const tags = (node.data('tags') || []).join(' ').toLowerCase();
                const hiddenTags = (node.data('hidden_tags') || []).join(' ').toLowerCase();
                
                // IMAGE SEARCH INTEGRATION - Add image annotation and filename to searchable text
                const imageAnnotation = (node.data('annotation') || '').toLowerCase();
                const originalFileName = (node.data('originalFileName') || '').toLowerCase();
                const searchableImageText = imageAnnotation + ' ' + originalFileName;
                
                const searchableText = title + ' ' + text + ' ' + tags + ' ' + hiddenTags + ' ' + searchableImageText;
                
                const matches = evaluateBooleanQuery(query.toLowerCase(), searchableText);
                
                if (matches) {
                    node.addClass('search-match');
                    node.removeClass('search-non-match'); // Remove blur if it was there
                    node.data('searchMatch', true);
                    // Don't select directly - let ESC convert to selected
                    matchCount++;
                } else {
                    node.removeClass('search-match');
                    node.addClass('search-non-match'); // Add blur for non-matches
                    node.data('searchMatch', false);
                    node.unselect(); // Avmarkera kortet
                }
            });
            
            // Show search results info
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `${matchCount} kort hittade`;
            searchInfo.classList.add('visible');
            
            // Show/hide mobile select button
            const selectBtn = document.getElementById('searchSelectBtn');
            if (matchCount > 0) {
                selectBtn.style.display = 'inline-block';
            } else {
                selectBtn.style.display = 'none';
            }
        }
        
        // Boolean query evaluation
        function evaluateBooleanQuery(query, searchableText) {
            // Handle different boolean operators
            
            // Split by OR first (lowest precedence)
            if (query.includes(' or ')) {
                const orParts = query.split(' or ');
                return orParts.some(part => evaluateBooleanQuery(part.trim(), searchableText));
            }
            
            // Handle NOT operations - improved logic
            if (query.includes(' not ')) {
                const notIndex = query.indexOf(' not ');
                const beforeNot = query.substring(0, notIndex).trim();
                const afterNot = query.substring(notIndex + 5).trim(); // ' not '.length = 5
                
                // If there's something before NOT, it must match
                let beforeMatches = true;
                if (beforeNot) {
                    beforeMatches = evaluateBooleanQuery(beforeNot, searchableText);
                }
                
                // The part after NOT must NOT match
                const afterMatches = evaluateBooleanQuery(afterNot, searchableText);
                
                return beforeMatches && !afterMatches;
            }
            
            // Handle AND operations (default behavior and explicit)
            const andParts = query.includes(' and ') ? 
                query.split(' and ') : 
                query.split(' ').filter(term => term.length > 0);
                
            return andParts.every(term => {
                term = term.trim();
                if (term.startsWith('"') && term.endsWith('"')) {
                    // Exact phrase search
                    const phrase = term.slice(1, -1);
                    return searchableText.includes(phrase);
                } else {
                    // Regular word search
                    return searchableText.includes(term);
                }
            });
        }
        
        // Pin/unpin functionality
        function pinCard(node) {
            node.addClass('pinned');
            node.data('pinned', true);
        }
        
        function unpinCard(node) {
            node.removeClass('pinned');
            node.data('pinned', false);
        }
        
        // Context Menu System
        function showContextMenu(event, node) {
            // Remove any existing context menu
            hideContextMenu();
            
            // Get mouse position
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.position = 'fixed';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.zIndex = '3000';
            
            // Pin/Unpin option
            const isPinned = node.hasClass('pinned');
            const pinOption = document.createElement('div');
            pinOption.className = 'context-menu-item';
            pinOption.innerHTML = isPinned ? 'üìå Ta bort pinning' : 'üìå Pinna kort';
            pinOption.onclick = () => {
                if (isPinned) {
                    unpinCard(node);
                } else {
                    pinCard(node);
                }
                hideContextMenu();
            };
            menu.appendChild(pinOption);
            
            // Color option
            const colorOption = document.createElement('div');
            colorOption.className = 'context-menu-item';
            colorOption.innerHTML = 'üé® F√§rga kort';
            colorOption.onclick = () => {
                hideContextMenu();
                // If the right-clicked node is selected, color all selected nodes
                // Otherwise, color just the right-clicked node
                const selectedNodes = cy.$('node:selected');
                const nodesToColor = node.selected() && selectedNodes.length > 1 ? selectedNodes : [node];
                showColorPicker(event, nodesToColor);
            };
            menu.appendChild(colorOption);
            
            // Remove color option (if card has color)
            if (node.data('cardColor')) {
                const removeColorOption = document.createElement('div');
                removeColorOption.className = 'context-menu-item';
                removeColorOption.innerHTML = '‚ùå Ta bort f√§rg';
                removeColorOption.onclick = () => {
                    // If the right-clicked node is selected, remove color from all selected nodes
                    // Otherwise, remove color from just the right-clicked node
                    const selectedNodes = cy.$('node:selected');
                    const nodesToProcess = node.selected() && selectedNodes.length > 1 ? selectedNodes : [node];
                    nodesToProcess.forEach(n => removeCardColor(n));
                    hideContextMenu();
                };
                menu.appendChild(removeColorOption);
            }
            
            // Resize option for annotation/geometric shapes
            if (node.data('isAnnotation') && node.data('annotationType') !== 'connection') {
                const resizeOption = document.createElement('div');
                resizeOption.className = 'context-menu-item';
                resizeOption.innerHTML = '‚ÜóÔ∏è √Ñndra storlek';
                resizeOption.onclick = () => {
                    hideContextMenu();
                    showResizeDialog(node);
                };
                menu.appendChild(resizeOption);
                
                // Font size option for geometric shapes
                const fontSizeOption = document.createElement('div');
                fontSizeOption.className = 'context-menu-item';
                fontSizeOption.innerHTML = 'üî§ √Ñndra fontstorlek';
                fontSizeOption.onclick = () => {
                    hideContextMenu();
                    showFontSizeDialog(node);
                };
                menu.appendChild(fontSizeOption);
            }
            
            // Arrow visibility toggle (global option)
            const arrowToggleOption = document.createElement('div');
            arrowToggleOption.className = 'context-menu-item';
            const arrowsVisible = !window.arrowsHidden;
            arrowToggleOption.innerHTML = arrowsVisible ? 'üëÅÔ∏è D√∂lj pilar' : 'üëÅÔ∏è Visa pilar';
            arrowToggleOption.onclick = () => {
                hideContextMenu();
                toggleArrowVisibility();
            };
            menu.appendChild(arrowToggleOption);
            
            // Remove arrows between selected cards (if multiple cards selected)
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length > 1) {
                const removeArrowsOption = document.createElement('div');
                removeArrowsOption.className = 'context-menu-item';
                removeArrowsOption.innerHTML = 'üóëÔ∏è Ta bort pilar mellan markerade';
                removeArrowsOption.onclick = () => {
                    hideContextMenu();
                    removeArrowsBetweenSelected();
                };
                menu.appendChild(removeArrowsOption);
                
                // Bulk tag option for multiple selected cards
                const bulkTagOption = document.createElement('div');
                bulkTagOption.className = 'context-menu-item';
                bulkTagOption.innerHTML = 'üè∑Ô∏è L√§gg till tagg p√• alla markerade';
                bulkTagOption.onclick = () => {
                    hideContextMenu();
                    showBulkTagDialog(selectedNodes);
                };
                menu.appendChild(bulkTagOption);
            }
            
            document.body.appendChild(menu);
            
            // Close menu on click elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }
        
        function hideContextMenu() {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
        }
        
        // Resize dialog for geometric shapes
        function showResizeDialog(node) {
            // Get current size or defaults
            const currentWidth = node.data('customWidth') || 120;
            const currentHeight = node.data('customHeight') || 120;
            const currentZIndex = node.data('customZIndex') || -1;
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; text-align: center;">‚ÜóÔ∏è √Ñndra storlek & lager</h3>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Bredd (px):</label>
                    <input type="number" id="resizeWidth" value="${currentWidth}" min="20" max="500" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">H√∂jd (px):</label>
                    <input type="number" id="resizeHeight" value="${currentHeight}" min="20" max="500" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Lagerh√∂jd:</label>
                    <select id="layerSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="-1" ${currentZIndex === -1 ? 'selected' : ''}>üîª Bakgrund (under kort)</option>
                        <option value="0" ${currentZIndex === 0 ? 'selected' : ''}>üìÑ Normal niv√•</option>
                        <option value="1" ${currentZIndex === 1 ? 'selected' : ''}>üî∫ F√∂rgrund (√∂ver kort)</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">Bakgrund: figurerna hamnar under korten som underl√§gg</small>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="keepAspectRatio" checked>
                        <span>Beh√•ll proportioner</span>
                    </label>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelResize" style="padding: 10px 20px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="applyResize" style="padding: 10px 20px; border: none; background: #007acc; color: white; border-radius: 4px; cursor: pointer;">Till√§mpa</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus first input
            const widthInput = document.getElementById('resizeWidth');
            const heightInput = document.getElementById('resizeHeight');
            const aspectCheckbox = document.getElementById('keepAspectRatio');
            widthInput.focus();
            
            // Keep aspect ratio functionality
            const originalAspectRatio = currentWidth / currentHeight;
            
            widthInput.addEventListener('input', () => {
                if (aspectCheckbox.checked) {
                    heightInput.value = Math.round(widthInput.value / originalAspectRatio);
                }
            });
            
            heightInput.addEventListener('input', () => {
                if (aspectCheckbox.checked) {
                    widthInput.value = Math.round(heightInput.value * originalAspectRatio);
                }
            });
            
            // Handle buttons
            document.getElementById('cancelResize').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('applyResize').onclick = () => {
                const newWidth = parseInt(widthInput.value) || currentWidth;
                const newHeight = parseInt(heightInput.value) || currentHeight;
                const newZIndex = parseInt(document.getElementById('layerSelect').value);
                
                // Apply resize and layer change
                resizeAnnotationNode(node, newWidth, newHeight, newZIndex);
                
                document.body.removeChild(overlay);
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyResize').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }
        
        // Apply resize and layer change to annotation node
        function resizeAnnotationNode(node, newWidth, newHeight, newZIndex = null) {
            console.log('üîß Resizing annotation node:', node.id(), 'to', newWidth, 'x', newHeight, 'z-index:', newZIndex);
            
            // Store the new size and layer in node data
            node.data('customWidth', newWidth);
            node.data('customHeight', newHeight);
            if (newZIndex !== null) {
                node.data('customZIndex', newZIndex);
            }
            
            // Update the visual properties using Cytoscape style
            cy.batch(() => {
                const styleUpdate = {
                    'width': newWidth + 'px',
                    'height': newHeight + 'px'
                };
                
                if (newZIndex !== null) {
                    // Convert internal z-index to Cytoscape z-index
                    let cyZIndex = 1; // default
                    if (newZIndex === -1) cyZIndex = 0; // Background
                    if (newZIndex === 0) cyZIndex = 1;  // Normal
                    if (newZIndex === 1) cyZIndex = 2;  // Foreground
                    styleUpdate['z-index'] = cyZIndex;
                }
                
                node.style(styleUpdate);
            });
            
            const layerName = newZIndex === -1 ? 'bakgrund' : newZIndex === 0 ? 'normal' : 'f√∂rgrund';
            console.log('‚úÖ Resize and layer change applied successfully, now in:', layerName);
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Font size dialog for geometric shapes
        function showFontSizeDialog(node) {
            // Get current font size or default
            const currentFontSize = node.style('font-size') || '16px';
            const currentFontSizeValue = parseInt(currentFontSize.replace('px', ''));
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 350px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">üî§ √Ñndra fontstorlek</h3>
                <div style="margin: 20px 0;">
                    <label for="fontSizeInput" style="display: block; margin-bottom: 5px; font-weight: bold;">Fontstorlek (px):</label>
                    <input type="number" id="fontSizeInput" value="${currentFontSizeValue}" min="8" max="72" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <div style="text-align: right; margin-top: 25px;">
                    <button id="cancelFontSize" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">Avbryt</button>
                    <button id="applyFontSize" style="padding: 8px 16px; border: none; border-radius: 5px; background: #007bff; color: white; cursor: pointer;">Till√§mpa</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the input
            document.getElementById('fontSizeInput').focus();
            document.getElementById('fontSizeInput').select();
            
            // Cancel button
            document.getElementById('cancelFontSize').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            // Apply button
            document.getElementById('applyFontSize').onclick = () => {
                const fontSizeInput = document.getElementById('fontSizeInput');
                const newFontSize = parseInt(fontSizeInput.value) || currentFontSizeValue;
                
                // Apply font size change
                changeFontSize(node, newFontSize);
                
                document.body.removeChild(overlay);
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyFontSize').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }
        
        // Apply font size change to geometric shape
        function changeFontSize(node, newFontSize) {
            console.log('üî§ Changing font size for node:', node.id(), 'to', newFontSize + 'px');
            
            // Store the new font size in node data for persistence
            node.data('customFontSize', newFontSize);
            
            // Update the visual properties using Cytoscape style
            cy.batch(() => {
                node.style('font-size', newFontSize + 'px');
            });
            
            console.log('‚úÖ Font size changed successfully to:', newFontSize + 'px');
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Arrow visibility toggle
        function toggleArrowVisibility() {
            console.log('üëÅÔ∏è Toggling arrow visibility...');
            
            const edges = cy.edges();
            const currentOpacity = edges.length > 0 ? edges[0].style('opacity') : 1;
            const newOpacity = currentOpacity == 0 ? 1 : 0;
            
            cy.batch(() => {
                edges.style('opacity', newOpacity);
            });
            
            // Store visibility state globally
            window.arrowsHidden = newOpacity == 0;
            
            console.log('‚úÖ Arrows', newOpacity == 0 ? 'hidden' : 'visible');
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Remove arrows between selected cards
        function removeArrowsBetweenSelected() {
            const selectedNodes = cy.$('node:selected');
            const selectedNodeIds = new Set(selectedNodes.map(node => node.id()));
            
            console.log('üóëÔ∏è Removing arrows between', selectedNodes.length, 'selected cards...');
            
            // Find edges that connect any two selected nodes
            const edgesToRemove = cy.edges().filter(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                return selectedNodeIds.has(sourceId) && selectedNodeIds.has(targetId);
            });
            
            console.log('Found', edgesToRemove.length, 'arrows to remove between selected cards');
            
            if (edgesToRemove.length > 0) {
                cy.batch(() => {
                    edgesToRemove.remove();
                });
                
                console.log('‚úÖ Removed', edgesToRemove.length, 'arrows between selected cards');
                
                // Save the board to persist changes
                saveBoard();
            } else {
                console.log('‚ÑπÔ∏è No arrows found between selected cards');
            }
        }
        
        // Bulk tag dialog for multiple selected cards
        function showBulkTagDialog(selectedNodes) {
            console.log('üè∑Ô∏è Opening bulk tag dialog for', selectedNodes.length, 'cards');
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">üè∑Ô∏è L√§gg till tagg</h3>
                <p style="color: #666; margin-bottom: 20px;">L√§gg till samma tagg p√• alla ${selectedNodes.length} markerade kort</p>
                <div style="margin: 20px 0;">
                    <label for="bulkTagInput" style="display: block; margin-bottom: 5px; font-weight: bold;">Tagg namn:</label>
                    <input type="text" id="bulkTagInput" placeholder="skriv tagg h√§r..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                    <small style="color: #888; display: block; margin-top: 5px;">Tips: anv√§nd inga mellanslag, t.ex. "viktigt" eller "projekt2025"</small>
                </div>
                <div style="text-align: right; margin-top: 25px;">
                    <button id="cancelBulkTag" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">Avbryt</button>
                    <button id="applyBulkTag" style="padding: 8px 16px; border: none; border-radius: 5px; background: #007bff; color: white; cursor: pointer;">L√§gg till tagg</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the input
            const tagInput = document.getElementById('bulkTagInput');
            tagInput.focus();
            
            // Cancel button
            document.getElementById('cancelBulkTag').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            // Apply button
            document.getElementById('applyBulkTag').onclick = () => {
                const tagName = tagInput.value.trim();
                if (tagName) {
                    applyBulkTag(selectedNodes, tagName);
                    document.body.removeChild(overlay);
                } else {
                    tagInput.style.borderColor = 'red';
                    tagInput.focus();
                }
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyBulkTag').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }
        
        // Apply bulk tag to multiple cards
        function applyBulkTag(selectedNodes, tagName) {
            console.log('üè∑Ô∏è Applying tag "' + tagName + '" to', selectedNodes.length, 'cards');
            
            let addedCount = 0;
            let skippedCount = 0;
            
            selectedNodes.forEach(node => {
                const currentTags = node.data('tags') || [];
                
                // Check if tag already exists (case insensitive)
                const tagExists = currentTags.some(tag => 
                    tag.toLowerCase() === tagName.toLowerCase()
                );
                
                if (!tagExists) {
                    // Add the tag
                    const newTags = [...currentTags, tagName];
                    node.data('tags', newTags);
                    
                    // Apply auto-gray coloring for #done tags
                    applyAutoDoneColoring(node);
                    
                    addedCount++;
                    console.log(`Added tag "${tagName}" to card: ${node.data('title') || node.id()}`);
                } else {
                    skippedCount++;
                    console.log(`Tag "${tagName}" already exists on card: ${node.data('title') || node.id()}`);
                }
            });
            
            // Show success message
            const searchInfo = document.getElementById('searchInfo');
            let message = `üè∑Ô∏è Tagg "${tagName}" tillagd p√• ${addedCount} kort`;
            if (skippedCount > 0) {
                message += ` (${skippedCount} kort hade redan taggen)`;
            }
            
            searchInfo.textContent = message;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 3000);
            
            console.log(`‚úÖ Bulk tag completed: ${addedCount} added, ${skippedCount} skipped`);
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Color picker system
        function showColorPicker(event, nodes) {
            console.log('showColorPicker called with', nodes.length, 'nodes');
            
            // Remove any existing color picker
            hideColorPicker();
            
            // Get mouse position or use event position
            const x = event.clientX || event.pageX || window.innerWidth / 2;
            const y = event.clientY || event.pageY || window.innerHeight / 2;
            console.log('Color picker position:', x, y);
            
            // Create color picker popup
            const picker = document.createElement('div');
            picker.className = 'color-picker-popup';
            picker.style.position = 'fixed';
            picker.style.left = x + 'px';
            picker.style.top = y + 'px';
            picker.style.zIndex = '4000';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'color-picker-title';
            title.textContent = `V√§lj f√§rg f√∂r ${nodes.length} kort`;
            picker.appendChild(title);
            
            // Create color grid
            const colorGrid = document.createElement('div');
            colorGrid.className = 'color-picker-grid';
            
            // Add the 8 color options
            for (let i = 1; i <= 8; i++) {
                const colorDot = document.createElement('div');
                colorDot.className = `color-picker-dot card-color-${i}`;
                colorDot.textContent = i; // Add number inside the dot
                colorDot.style.lineHeight = '26px'; // Center vertically
                colorDot.style.textAlign = 'center'; // Center horizontally
                colorDot.style.fontSize = '14px';
                colorDot.style.fontWeight = 'bold';
                colorDot.style.color = '#333';
                colorDot.style.textShadow = '0 0 3px rgba(255,255,255,0.8)';
                colorDot.onclick = () => {
                    console.log(`Clicked color ${i}, applying to ${nodes.length} cards`);
                    // Apply color to all nodes
                    nodes.forEach(node => {
                        console.log(`Setting color card-color-${i} on node:`, node.id());
                        node.data('cardColor', `card-color-${i}`);
                        // Update cytoscape styling immediately
                        const colorValue = getCardColorValue(`card-color-${i}`, getCurrentTheme());
                        console.log(`Color value:`, colorValue);
                        node.style('background-color', colorValue);
                    });
                    hideColorPicker();
                    console.log(`Applied color ${i} to ${nodes.length} cards`);
                };
                colorGrid.appendChild(colorDot);
            }
            
            picker.appendChild(colorGrid);
            
            // Add cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'color-picker-cancel';
            cancelBtn.textContent = 'Avbryt';
            cancelBtn.onclick = hideColorPicker;
            picker.appendChild(cancelBtn);
            
            console.log('Adding picker to body:', picker);
            document.body.appendChild(picker);
            console.log('Picker added, should be visible now');
            
            // Close picker on click elsewhere
            setTimeout(() => {
                currentClickHandler = function(e) {
                    if (!picker.contains(e.target)) {
                        hideColorPicker();
                    }
                };
                document.addEventListener('click', currentClickHandler);
            }, 100);
        }
        
        let currentClickHandler = null;
        
        function hideColorPicker() {
            const existingPicker = document.querySelector('.color-picker-popup');
            if (existingPicker) {
                existingPicker.remove();
            }
            // Remove the click handler if it exists
            if (currentClickHandler) {
                document.removeEventListener('click', currentClickHandler);
                currentClickHandler = null;
            }
            console.log('Color picker hidden and event listeners cleaned up');
        }
        
        function removeCardColor(node) {
            node.removeData('cardColor');
            // Reset to default theme color
            const theme = getCurrentTheme();
            const defaultColor = theme === 'dark' ? '#2a2a2a' : (theme === 'sepia' ? '#f5f5dc' : '#ffffff');
            node.style('background-color', defaultColor);
            console.log('Removed color from card:', node.id());
        }
        
        function getCurrentTheme() {
            if (document.body.classList.contains('dark-theme')) return 'dark';
            if (document.body.classList.contains('sepia-theme')) return 'sepia';
            return 'light';
        }
        
        // Multi-card paste dialog
        function showMultiCardPasteDialog() {
            // Remove any existing dialog
            const existingDialog = document.querySelector('.multi-card-paste-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'multi-card-paste-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 5000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                width: 90%;
                max-width: 600px;
                max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">Skapa flera kort fr√•n text</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    Klistra in text. Tv√• tomma rader = nytt kort.<br>
                    Sista raden med #tagg1 #tagg2 blir riktiga taggar.
                </p>
                <textarea id="multiCardText" placeholder="F√∂rsta anteckningen h√§r...

Andra anteckningen...
#work #urgent

Tredje anteckningen...
#personal #todo" style="
                    width: 100%;
                    height: 300px;
                    padding: 10px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-family: monospace;
                    font-size: 14px;
                    resize: vertical;
                    box-sizing: border-box;
                "></textarea>
                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelMultiCard" style="
                        padding: 8px 16px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Avbryt</button>
                    <button id="createMultiCards" style="
                        padding: 8px 16px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Skapa kort</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus textarea
            const textarea = document.getElementById('multiCardText');
            textarea.focus();
            
            // Event handlers
            document.getElementById('cancelMultiCard').onclick = () => {
                overlay.remove();
            };
            
            document.getElementById('createMultiCards').onclick = () => {
                const text = textarea.value.trim();
                if (text) {
                    createMultipleCardsFromText(text);
                    overlay.remove();
                } else {
                    alert('Skriv in lite text f√∂rst!');
                }
            };
            
            // Close on Escape
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
        }
        
        // Parse and create multiple cards from text
        function createMultipleCardsFromText(text) {
            // Split on double line breaks (two consecutive newlines)
            const blocks = text.split(/\n\s*\n/).filter(block => block.trim());
            
            console.log('Found', blocks.length, 'text blocks');
            
            let createdCount = 0;
            const startPosition = { x: 200, y: 200 };
            
            blocks.forEach((block, index) => {
                const lines = block.trim().split('\n');
                const lastLine = lines[lines.length - 1].trim();
                
                let cardText = '';
                let tags = [];
                
                // Check if last line contains tags (starts with # and has #words)
                if (lastLine.startsWith('#') && lastLine.includes('#')) {
                    // Extract tags from last line: #tagg1 #tagg2 #tagg3
                    const tagMatches = lastLine.match(/#\w+/g);
                    if (tagMatches) {
                        tags = tagMatches.map(tag => tag.substring(1)); // Remove # prefix
                        // Card text is everything except the last line
                        cardText = lines.slice(0, -1).join('\n').trim();
                    } else {
                        // Last line starts with # but no valid tags, include it in text
                        cardText = lines.join('\n').trim();
                    }
                } else {
                    // No tags, all lines become card text
                    cardText = lines.join('\n').trim();
                }
                
                // Skip empty cards
                if (!cardText) return;
                
                // Create card
                const cardId = generateCardId();
                const position = {
                    x: startPosition.x + (index * 50), // Offset each card
                    y: startPosition.y + (index * 50)
                };
                
                const nodeData = {
                    id: cardId,
                    text: cardText,
                    isManualCard: true,
                    tags: tags
                };
                
                const newNode = cy.add({
                    group: 'nodes',
                    data: nodeData,
                    position: position
                });
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(newNode);
                
                createdCount++;
                console.log(`Created card ${index + 1}: "${cardText.substring(0, 30)}..." with tags:`, tags);
            });
            
            // Show success message
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `Skapade ${createdCount} kort fr√•n texten`;
                statusDiv.classList.add('visible');
                setTimeout(() => {
                    statusDiv.classList.remove('visible');
                }, 3000);
            }
            
            console.log(`Multi-card paste complete: ${createdCount} cards created`);
        }
        
        
        // Clear search
        function clearSearch() {
            searchActive = false;
            
            cy.nodes().removeClass('search-match');
            cy.nodes().removeClass('search-non-match'); // Remove blur from non-matches
            cy.nodes().data('searchMatch', false);
            cy.nodes().unselect(); // Avmarkera alla kort n√§r s√∂kning rensas
            
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.classList.remove('visible');
            
            // Hide mobile select button
            const selectBtn = document.getElementById('searchSelectBtn');
            selectBtn.style.display = 'none';
        }
        
        // Tag filtering functions with Boolean logic
        function performTagFilter(filterText) {
            if (!filterText.trim()) {
                clearTagFilter();
                return;
            }
            
            const query = filterText.toLowerCase().trim();
            let matchCount = 0;
            
            cy.nodes().forEach(node => {
                const nodeTags = node.data('tags') || [];
                const nodeTagsLower = nodeTags.map(tag => tag.toLowerCase());
                
                // Create searchable tag string (space-separated for boolean evaluation)
                const searchableTagText = nodeTagsLower.join(' ');
                
                // Use boolean evaluation on tags
                const matches = evaluateBooleanTagQuery(query, searchableTagText, nodeTagsLower);
                
                if (matches) {
                    node.removeClass('tag-filtered');
                    matchCount++;
                } else {
                    node.addClass('tag-filtered');
                }
            });
            
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `${matchCount} kort matchade tag-filter: "${filterText}"`;
            searchInfo.classList.add('visible');
        }
        
        // Boolean query evaluation specifically for tags
        function evaluateBooleanTagQuery(query, searchableTagText, nodeTagsArray) {
            // Handle different boolean operators for tags
            
            // Split by OR first (lowest precedence)
            if (query.includes(' or ')) {
                const orParts = query.split(' or ');
                return orParts.some(part => evaluateBooleanTagQuery(part.trim(), searchableTagText, nodeTagsArray));
            }
            
            // Handle NOT operations
            if (query.includes(' not ')) {
                const notIndex = query.indexOf(' not ');
                const beforeNot = query.substring(0, notIndex).trim();
                const afterNot = query.substring(notIndex + 5).trim(); // ' not '.length = 5
                
                // If there's something before NOT, it must match
                let beforeMatches = true;
                if (beforeNot) {
                    beforeMatches = evaluateBooleanTagQuery(beforeNot, searchableTagText, nodeTagsArray);
                }
                
                // The part after NOT must NOT match
                const afterMatches = evaluateBooleanTagQuery(afterNot, searchableTagText, nodeTagsArray);
                
                return beforeMatches && !afterMatches;
            }
            
            // Handle AND operations (default behavior and explicit)
            const andParts = query.includes(' and ') ? 
                query.split(' and ') : 
                query.split(' ').filter(term => term.length > 0);
                
            return andParts.every(term => {
                term = term.trim();
                
                if (term.startsWith('"') && term.endsWith('"')) {
                    // Exact tag search - must match complete tag
                    const exactTag = term.slice(1, -1);
                    return nodeTagsArray.some(tag => tag === exactTag);
                } else {
                    // Partial tag search - can be part of any tag
                    return nodeTagsArray.some(tag => tag.includes(term));
                }
            });
        }
        
        function clearTagFilter() {
            cy.nodes().removeClass('tag-filtered');
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.classList.remove('visible');
        }
        
        // Multi-selection functions
        function pinSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            selectedNodes.forEach(node => {
                if (!node.hasClass('pinned')) {
                    pinCard(node);
                }
            });
            if (selectedNodes.length > 0) {
                console.log(`Pinned ${selectedNodes.length} cards`);
                updateSelectionInfo(); // Update after pinning
            }
        }
        
        function unpinSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            selectedNodes.forEach(node => {
                if (node.hasClass('pinned')) {
                    unpinCard(node);
                }
            });
            if (selectedNodes.length > 0) {
                console.log(`Unpinned ${selectedNodes.length} cards`);
                updateSelectionInfo(); // Update after unpinning
            }
        }
        
        function deleteSelectedCards() {
            // Get all selected nodes and edges
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            const selectedEdges = cy.$('edge:selected');
            console.log(`Delete attempt on ${selectedNodes.length} selected nodes and ${selectedEdges.length} selected edges`);
            
            if (selectedNodes.length === 0 && selectedEdges.length === 0) return;
            
            // Save state for undo before deleting
            saveState();
            
            // Delete selected edges (arrows) first - they have no protection
            if (selectedEdges.length > 0) {
                const edgeCount = selectedEdges.length;
                cy.batch(() => {
                    selectedEdges.remove();
                });
                console.log(`‚úÖ Deleted ${edgeCount} selected arrows`);
                
                // Save the board to persist changes
                saveBoard();
            }
            
            // Filter out ALL pinned cards using proper filtering
            const unpinnedNodes = selectedNodes.filter(function(node) {
                const hasClass = node.hasClass('pinned');
                const hasData = node.data('pinned');
                const isPinned = hasClass || hasData;
                
                console.log(`Node ${node.id()}: hasClass=${hasClass}, hasData=${hasData}, isPinned=${isPinned}`);
                return !isPinned;
            });
            
            const pinnedNodes = selectedNodes.filter(function(node) {
                const hasClass = node.hasClass('pinned');
                const hasData = node.data('pinned');
                return hasClass || hasData;
            });
            
            console.log(`Unpinned to delete: ${unpinnedNodes.length}, Pinned to skip: ${pinnedNodes.length}`);
            
            // Only delete unpinned nodes
            if (unpinnedNodes.length > 0) {
                const count = unpinnedNodes.length;
                unpinnedNodes.remove();
                console.log(`Successfully deleted ${count} unpinned cards`);
                updateSelectionInfo(); // Update after deletion
            }
            
            // Show message if user tried to delete pinned cards
            if (pinnedNodes.length > 0) {
                const pinnedCount = pinnedNodes.length;
                console.log(`PROTECTED: Skipped ${pinnedCount} pinned cards - unpin them first to delete`);
                
                // Show a brief visual feedback
                const searchInfo = document.getElementById('searchInfo');
                if (searchInfo) {
                    searchInfo.textContent = `üîí ${pinnedCount} pinnade kort skyddade - ta bort pinning f√∂rst`;
                    searchInfo.classList.add('visible');
                    setTimeout(() => {
                        searchInfo.classList.remove('visible');
                    }, 4000);
                }
            }
        }
        
        // ========================================
        // SORTING SYSTEM - EASY TO FIND
        // ========================================
        // Global sorting state
        let sortMode = null; // null, 'textLength-asc', 'textLength-desc', 'alphabetic-asc', 'alphabetic-desc', 'color', 'date-asc', 'date-desc', 'temporal-asc', 'temporal-desc', 'tagCount'
        
        function showSortMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Column view: no selection required, automatic sorting
            if (isColumnView) {
                // Show column view specific sort menu
                showColumnViewSortMenu(event);
                return;
            }
            
            // Board view: Check if we have selected nodes
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) {
                alert('Markera minst 2 kort f√∂r att sortera');
                return;
            }
            
            // Create sort menu
            const sortMenu = document.createElement('div');
            sortMenu.id = 'sortMenu';
            sortMenu.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: white; border: 2px solid #007acc; border-radius: 8px;
                padding: 15px; z-index: 10001; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            sortMenu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; text-align: center; color: #007acc;">üìä Sortera ${selectedNodes.length} kort</h3>
                <p style="margin: 0 0 15px 0; text-align: center; font-size: 14px; color: #666;">
                    V√§lj sortering, tryck sedan H/V/G+V/G+H/G+T f√∂r layout
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="setSortMode('textLength-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìù Text: Kort ‚Üí L√•ng</button>
                    <button onclick="setSortMode('textLength-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìù Text: L√•ng ‚Üí Kort</button>
                    <button onclick="setSortMode('alphabetic-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üî§ A ‚Üí Z</button>
                    <button onclick="setSortMode('alphabetic-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üî§ Z ‚Üí A</button>
                    <button onclick="setSortMode('color')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üé® F√§rg 1‚Üí6</button>
                    <button onclick="setSortMode('date-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÖ Skapande: √Ñldst ‚Üí Nyast</button>
                    <button onclick="setSortMode('date-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÖ Skapande: Nyast ‚Üí √Ñldst</button>
                    <button onclick="setSortMode('temporal-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üïí Datum: Tidigare ‚Üí Senare</button>
                    <button onclick="setSortMode('temporal-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üïí Datum: Senare ‚Üí Tidigare</button>
                    <button onclick="setSortMode('tagCount')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üè∑Ô∏è F√§rre ‚Üí Fler taggar</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="closeSortMenu()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                </div>
            `;
            
            document.body.appendChild(sortMenu);
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeSortOnClick(e) {
                    if (!sortMenu.contains(e.target)) {
                        closeSortMenu();
                        document.removeEventListener('click', closeSortOnClick);
                    }
                });
            }, 100);
        }
        
        function setSortMode(mode) {
            sortMode = mode;
            console.log('Sort mode set to:', mode);
            closeSortMenu();
            
            if (isColumnView) {
                // Column view: apply sorting immediately
                setColumnViewSortFromBoardMode(mode);
            } else {
                // Board view: show instruction
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Sorteringsl√§ge: ${getSortModeDescription(mode)}. Tryck H/V/G+V/G+H/G+T f√∂r layout.`;
                    statusDiv.classList.add('visible');
                    
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        if (sortMode === mode) { // Only hide if we're still in same sort mode
                            statusDiv.classList.remove('visible');
                        }
                    }, 5000);
                }
            }
        }

        // Column view specific sort menu
        function showColumnViewSortMenu(event) {
            // Create sort menu
            const sortMenu = document.createElement('div');
            sortMenu.id = 'sortMenu';
            sortMenu.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: white; border: 2px solid #007acc; border-radius: 8px;
                padding: 15px; z-index: 10001; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            sortMenu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; text-align: center; color: #007acc;">üìä Kolumnvy Sortering</h3>
                <p style="margin: 0 0 15px 0; text-align: center; font-size: 14px; color: #666;">
                    V√§lj sortering - appliceras automatiskt p√• alla kort
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="setColumnViewSort('alphabetical')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üî§ A ‚Üí Z</button>
                    <button onclick="setColumnViewSort('reverse-alphabetical')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üî§ Z ‚Üí A</button>
                    <button onclick="setColumnViewSort('creation')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÖ Skapande: √Ñldst ‚Üí Nyast</button>
                    <button onclick="setColumnViewSort('reverse-creation')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÖ Skapande: Nyast ‚Üí √Ñldst</button>
                    <button onclick="setColumnViewSort('tags')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üè∑Ô∏è Tags</button>
                    <button onclick="setColumnViewSort('color')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üé® F√§rg 1‚Üí6</button>
                    <button onclick="setColumnViewSort('tagged-date')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÜ @datum √Ñldst ‚Üí Nyast</button>
                    <button onclick="setColumnViewSort('reverse-tagged-date')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">üìÜ @datum Nyast ‚Üí √Ñldst</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="closeSortMenu()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                </div>
            `;
            
            document.body.appendChild(sortMenu);
        }

        // Convert board sort mode to column sort mode
        function setColumnViewSortFromBoardMode(boardMode) {
            let columnMode = 'creation'; // default
            
            switch(boardMode) {
                case 'alphabetic-asc':
                    columnMode = 'alphabetical';
                    break;
                case 'alphabetic-desc':
                    columnMode = 'reverse-alphabetical';
                    break;
                case 'date-asc':
                    columnMode = 'creation';
                    break;
                case 'date-desc':
                    columnMode = 'reverse-creation';
                    break;
                case 'tagCount':
                    columnMode = 'tags';
                    break;
                default:
                    columnMode = 'creation';
            }
            
            setColumnViewSort(columnMode);
        }
        
        function closeSortMenu() {
            const sortMenu = document.getElementById('sortMenu');
            if (sortMenu) {
                document.body.removeChild(sortMenu);
            }
        }
        
        function getSortModeDescription(mode) {
            switch(mode) {
                case 'textLength-asc': return 'Text kort ‚Üí l√•ng';
                case 'textLength-desc': return 'Text l√•ng ‚Üí kort';
                case 'alphabetic-asc': return 'Alfabetisk A ‚Üí Z';
                case 'alphabetic-desc': return 'Alfabetisk Z ‚Üí A';
                case 'color': return 'F√§rg 1 ‚Üí 6';
                case 'date-asc': return 'Skapande: √Ñldst ‚Üí nyast';
                case 'date-desc': return 'Skapande: Nyast ‚Üí √§ldst';
                case 'temporal-asc': return 'Datum: Tidigare ‚Üí senare';
                case 'temporal-desc': return 'Datum: Senare ‚Üí tidigare';
                case 'tagCount': return 'F√§rre ‚Üí fler taggar';
                default: return 'Ok√§nt';
            }
        }
        
        function sortNodes(nodes) {
            if (!sortMode) return nodes;
            
            return nodes.sort((a, b) => {
                switch(sortMode) {
                    case 'textLength-asc':
                        const aTextLength = (a.data('text') || '').length;
                        const bTextLength = (b.data('text') || '').length;
                        return aTextLength - bTextLength;
                        
                    case 'textLength-desc':
                        const aTextLengthDesc = (a.data('text') || '').length;
                        const bTextLengthDesc = (b.data('text') || '').length;
                        return bTextLengthDesc - aTextLengthDesc;
                        
                    case 'alphabetic-asc':
                        const aText = (a.data('text') || '').toLowerCase();
                        const bText = (b.data('text') || '').toLowerCase();
                        return aText.localeCompare(bText, 'sv');
                        
                    case 'alphabetic-desc':
                        const aTextDesc = (a.data('text') || '').toLowerCase();
                        const bTextDesc = (b.data('text') || '').toLowerCase();
                        return bTextDesc.localeCompare(aTextDesc, 'sv');
                        
                    case 'color':
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Same color order as background-color: r√∂d, orange, gul, lila, bl√•, vit, gr√∂n, gr√•
                        const colorOrder = {
                            'card-color-3': 1, // r√∂d
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // bl√•
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // gr√∂n
                            'card-color-7': 8, // gr√•
                            '': 9              // of√§rgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        return aPriority - bPriority;
                        
                    case 'date-asc':
                        const aDate = extractDateFromId(a.id());
                        const bDate = extractDateFromId(b.id());
                        return aDate - bDate;
                        
                    case 'date-desc':
                        const aDateDesc = extractDateFromId(a.id());
                        const bDateDesc = extractDateFromId(b.id());
                        return bDateDesc - aDateDesc;
                        
                    case 'temporal-asc':
                        const aTemporalDate = getEarliestDateFromContent(a);
                        const bTemporalDate = getEarliestDateFromContent(b);
                        return aTemporalDate - bTemporalDate;
                        
                    case 'temporal-desc':
                        const aTemporalDateDesc = getEarliestDateFromContent(a);
                        const bTemporalDateDesc = getEarliestDateFromContent(b);
                        return bTemporalDateDesc - aTemporalDateDesc;
                        
                    case 'tagCount':
                        const aTagCount = (a.data('tags') || []).length;
                        const bTagCount = (b.data('tags') || []).length;
                        return aTagCount - bTagCount;
                        
                    default:
                        return 0;
                }
            });
        }
        
        // Get nodes sorted by arrow connections (topological sort)
        function getArrowBasedOrder(selectedNodes) {
            console.log('üîç getArrowBasedOrder called with:', selectedNodes.length, 'nodes');
            
            // Get all edges connecting the selected nodes
            const nodeIds = new Set(selectedNodes.map(node => node.id()));
            console.log('üìù Selected node IDs:', Array.from(nodeIds));
            
            const allEdges = cy.edges();
            console.log('üìä Total edges in graph:', allEdges.length);
            
            const relevantEdges = allEdges.filter(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                const isRelevant = nodeIds.has(sourceId) && nodeIds.has(targetId);
                if (isRelevant) {
                    console.log('‚úÖ Found relevant edge:', sourceId, '‚Üí', targetId);
                }
                return isRelevant;
            });
            
            console.log('üîó Relevant edges found:', relevantEdges.length);
            
            if (relevantEdges.length === 0) {
                console.log('‚ùå No arrows between selected nodes, returning original order');
                return selectedNodes; // No arrows, return original order
            }
            
            // Build adjacency list for topological sort
            const adjList = new Map();
            const inDegree = new Map();
            
            // Initialize all selected nodes
            selectedNodes.forEach(node => {
                const id = node.id();
                adjList.set(id, []);
                inDegree.set(id, 0);
            });
            
            // Build graph from edges
            relevantEdges.forEach(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                
                console.log('üîß Building edge:', sourceId, '‚Üí', targetId);
                adjList.get(sourceId).push(targetId);
                inDegree.set(targetId, inDegree.get(targetId) + 1);
            });
            
            console.log('üìà In-degrees:', Object.fromEntries(inDegree));
            
            // Kahn's algorithm for topological sorting
            const queue = [];
            const sortedOrder = [];
            
            // Find nodes with no incoming edges
            for (const [nodeId, degree] of inDegree) {
                if (degree === 0) {
                    console.log('üöÄ Starting node (no incoming edges):', nodeId);
                    queue.push(nodeId);
                }
            }
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                sortedOrder.push(currentId);
                console.log('‚úîÔ∏è Processing node:', currentId);
                
                // Process neighbors
                const neighbors = adjList.get(currentId) || [];
                neighbors.forEach(neighborId => {
                    inDegree.set(neighborId, inDegree.get(neighborId) - 1);
                    console.log('üìâ Reduced in-degree for', neighborId, 'to', inDegree.get(neighborId));
                    if (inDegree.get(neighborId) === 0) {
                        console.log('üöÄ Adding to queue:', neighborId);
                        queue.push(neighborId);
                    }
                });
            }
            
            // Handle cycles - add remaining nodes
            selectedNodes.forEach(node => {
                if (!sortedOrder.includes(node.id())) {
                    console.log('‚ö†Ô∏è Adding remaining node (possible cycle):', node.id());
                    sortedOrder.push(node.id());
                }
            });
            
            // Convert back to node objects in sorted order
            const nodeMap = new Map(selectedNodes.map(node => [node.id(), node]));
            const sortedNodes = sortedOrder.map(id => nodeMap.get(id)).filter(Boolean);
            
            console.log('üéØ Final sorted order:', sortedOrder);
            console.log('‚úÖ Arrow-based sorting complete:', relevantEdges.length, 'edges found, sorted', sortedNodes.length, 'nodes');
            return sortedNodes;
        }

        function extractDateFromId(nodeId) {
            // Try to extract timestamp from ID like "20250810-143052"
            const match = nodeId.match(/(\d{8}-\d{6})/);
            if (match) {
                const dateStr = match[1];
                const year = parseInt(dateStr.substr(0, 4));
                const month = parseInt(dateStr.substr(4, 2)) - 1; // Month is 0-indexed
                const day = parseInt(dateStr.substr(6, 2));
                const hour = parseInt(dateStr.substr(9, 2));
                const minute = parseInt(dateStr.substr(11, 2));
                const second = parseInt(dateStr.substr(13, 2));
                return new Date(year, month, day, hour, minute, second).getTime();
            }
            
            // Fallback for older IDs - return very old date
            return new Date(2020, 0, 1).getTime();
        }

        // ========================================
        // DATE-BASED AUTO-MARKING SYSTEM
        // ========================================
        
        // Parse date from @YYMMDD format (e.g., @250816)
        function parseDateFromContent(content) {
            const datePatterns = [];
            
            // Pattern 1: @YYMMDD (e.g., @250816)
            const yymmddPattern = /@(\d{6})/g;
            let match;
            while ((match = yymmddPattern.exec(content)) !== null) {
                const dateStr = match[1];
                const year = 2000 + parseInt(dateStr.substr(0, 2));
                const month = parseInt(dateStr.substr(2, 2)) - 1; // Month is 0-indexed
                const day = parseInt(dateStr.substr(4, 2));
                
                // Validate date
                if (month >= 0 && month <= 11 && day >= 1 && day <= 31) {
                    datePatterns.push({
                        type: 'date',
                        date: new Date(year, month, day),
                        match: match[0]
                    });
                }
            }
            
            // Pattern 2: @YYwWW (e.g., @25w33)
            const weekPattern = /@(\d{2})w(\d{1,2})/g;
            while ((match = weekPattern.exec(content)) !== null) {
                const year = 2000 + parseInt(match[1]);
                const week = parseInt(match[2]);
                
                // Calculate date from week number
                if (week >= 1 && week <= 53) {
                    const weekDate = getDateFromWeek(year, week);
                    datePatterns.push({
                        type: 'week',
                        date: weekDate,
                        week: week,
                        year: year,
                        match: match[0]
                    });
                }
            }
            
            return datePatterns;
        }
        
        // Get date from ISO week number
        function getDateFromWeek(year, week) {
            const januaryFirst = new Date(year, 0, 1);
            const daysToFirstMonday = (8 - januaryFirst.getDay()) % 7;
            const firstMonday = new Date(year, 0, 1 + daysToFirstMonday);
            const targetDate = new Date(firstMonday.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);
            return targetDate;
        }
        
        // Get ISO week number from date
        function getWeekNumber(date) {
            const target = new Date(date.valueOf());
            const dayNr = (date.getDay() + 6) % 7;
            target.setDate(target.getDate() - dayNr + 3);
            const firstThursday = target.valueOf();
            target.setMonth(0, 1);
            if (target.getDay() !== 4) {
                target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
            }
            return 1 + Math.ceil((firstThursday - target) / 604800000);
        }
        
        // Check if node has todo tag in tags array
        function hasTodoTag(node) {
            const tags = node.data('tags') || [];
            return tags.some(tag => tag.toLowerCase() === 'todo');
        }

        function hasDoneTag(node) {
            const tags = node.data('tags') || [];
            return tags.some(tag => tag.toLowerCase() === 'done');
        }

        // Automatically assign gray color to cards with #done tags
        function applyAutoDoneColoring(node) {
            if (hasDoneTag(node)) {
                // Set gray color (card-color-7) for done tasks
                node.data('cardColor', 'card-color-7');
                
                // Update cytoscape styling immediately
                const colorValue = getCardColorValue('card-color-7', getCurrentTheme());
                node.style('background-color', colorValue);
                
                console.log(`Auto-colored card ${node.id()} gray for #done tag`);
            }
        }
        
        // Calculate temporal relevance and get marking intensity
        function getTemporalMarking(datePatterns, hasTodo, hasDone, today = new Date()) {
            if (!datePatterns || datePatterns.length === 0) {
                return null;
            }
            
            const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const currentWeek = getWeekNumber(today);
            const currentYear = today.getFullYear();
            
            let strongestMarking = null;
            
            datePatterns.forEach(pattern => {
                let marking = null;
                
                if (pattern.type === 'date') {
                    const targetDate = new Date(pattern.date.getFullYear(), pattern.date.getMonth(), pattern.date.getDate());
                    const daysDiff = Math.floor((targetDate - todayStart) / (24 * 60 * 60 * 1000));
                    
                    if (daysDiff === 0) {
                        // Today - strongest marking
                        marking = { intensity: 1.0, color: 'today', reason: 'Today' };
                    } else if (daysDiff === 1 && hasTodo) {
                        // Tomorrow + #todo - strong marking
                        marking = { intensity: 0.9, color: 'tomorrow-todo', reason: 'Tomorrow + #todo' };
                    } else if (daysDiff >= 2 && daysDiff <= 14) {
                        // 2-14 days future - gradual fade
                        const intensity = 0.8 - ((daysDiff - 2) / 12) * 0.6; // 0.8 -> 0.2
                        marking = { intensity, color: 'future', reason: `${daysDiff} days ahead` };
                    } else if (daysDiff < 0 && hasDone) {
                        // Past + #done - light green marking
                        marking = { intensity: 0.7, color: 'past-done', reason: 'Past + #done' };
                    } else if (daysDiff < 0 && hasTodo) {
                        // Past + #todo - black marking (highest intensity for past)
                        marking = { intensity: 0.85, color: 'past-todo', reason: 'Past + #todo' };
                    }
                } else if (pattern.type === 'week') {
                    if (pattern.year === currentYear && pattern.week === currentWeek) {
                        // Current week - strong marking
                        marking = { intensity: 0.8, color: 'current-week', reason: 'Current week' };
                    } else if (pattern.year === currentYear && pattern.week === currentWeek + 1) {
                        // Next week - milder but with #todo boost
                        const intensity = hasTodo ? 0.7 : 0.5;
                        marking = { intensity, color: 'next-week', reason: 'Next week' + (hasTodo ? ' + #todo' : '') };
                    }
                }
                
                // Keep strongest marking
                if (marking && (!strongestMarking || marking.intensity > strongestMarking.intensity)) {
                    strongestMarking = marking;
                }
            });
            
            return strongestMarking;
        }
        
        // Get border style for temporal marking (Cytoscape format)
        function getTemporalBorderStyle(marking) {
            if (!marking) return null;
            
            const baseWidth = Math.max(1, Math.ceil(marking.intensity * 1.5) + 0.5); // 1-2px width based on intensity
            
            const colorMap = {
                'today': '#ff4500', // Red-orange for today
                'tomorrow-todo': '#ff8c00', // Orange for tomorrow+todo
                'future': '#1e90ff', // Blue for future dates
                'past-todo': '#000000', // Black for past+todo
                'past-done': '#90EE90', // Light green for past+done
                'current-week': '#32cd32', // Lime green for current week
                'next-week': '#9370db' // Medium slate blue for next week
            };
            
            const color = colorMap[marking.color] || '#808080';
            
            return {
                'border-width': baseWidth,
                'border-color': color
            };
        }
        
        // Apply temporal markings to all cards
        function applyTemporalMarkings() {
            const today = new Date();
            console.log('üïí Applying temporal markings for date:', today.toDateString());
            
            let markedCount = 0;
            
            cy.nodes().forEach(node => {
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const fullContent = title + ' ' + text;
                
                console.log(`Checking card "${title}": "${fullContent}"`);
                
                // Parse dates and check for todo/done
                const datePatterns = parseDateFromContent(fullContent);
                const hasTodo = hasTodoTag(node);
                const hasDone = hasDoneTag(node);
                
                console.log(`  - Date patterns found:`, datePatterns);
                console.log(`  - Has #todo:`, hasTodo);
                console.log(`  - Has #done:`, hasDone);
                
                // Get temporal marking
                const marking = getTemporalMarking(datePatterns, hasTodo, hasDone, today);
                console.log(`  - Temporal marking:`, marking);
                
                if (marking) {
                    // Apply border styling via node data and class
                    const borderStyle = getTemporalBorderStyle(marking);
                    if (borderStyle) {
                        console.log(`  - Applying border style:`, borderStyle);
                        
                        // Store temporal styling in node data
                        node.data('temporalBorderWidth', borderStyle['border-width']);
                        node.data('temporalBorderColor', borderStyle['border-color']);
                        
                        // Add temporal marking class to trigger stylesheet
                        node.addClass('temporal-marked');
                        
                        markedCount++;
                        console.log(`üéØ Marked card ${node.id()}: ${marking.reason} (intensity: ${marking.intensity.toFixed(2)}, color: ${borderStyle['border-color']}, width: ${borderStyle['border-width']})`);
                    }
                } else {
                    // Remove temporal marking
                    node.removeClass('temporal-marked');
                    node.removeData('temporalBorderWidth');
                    node.removeData('temporalBorderColor');
                }
            });
            
            // Force Cytoscape to update styling
            cy.style().update();
            
            console.log(`‚úÖ Temporal marking complete: ${markedCount} cards marked`);
            return markedCount;
        }
        
        // Debug function to check hidden_tags - call this in console
        function debugHiddenTags() {
            console.log('=== HIDDEN TAGS DEBUG ===');
            cy.nodes().forEach(node => {
                const hiddenTags = node.data('hidden_tags') || [];
                const isCopy = node.data('isCopy');
                const copyOf = node.data('copyOf');
                const copyTimestamp = node.data('copyTimestamp');
                
                if (hiddenTags.length > 0 || isCopy) {
                    console.log(`Card ${node.id()}:`);
                    console.log(`  Title: "${node.data('title')}"`);
                    console.log(`  Hidden tags:`, hiddenTags);
                    console.log(`  isCopy:`, isCopy);
                    console.log(`  copyOf:`, copyOf);
                    console.log(`  copyTimestamp:`, copyTimestamp);
                    console.log('---');
                }
            });
            console.log('=== END DEBUG ===');
        }
        
        // Test copy search - call this in console 
        function testCopySearch() {
            console.log('üß™ Testing copy search functionality...');
            
            // Create test card
            const testNode = cy.add({
                data: {
                    id: 'test-copy-search',
                    title: 'Test Original',
                    text: 'This is a test card',
                    tags: ['test'],
                    hidden_tags: [],
                    searchMatch: false
                },
                position: { x: 100, y: 100 }
            });
            testNode.grabify();
            
            // Select and copy it
            testNode.select();
            copySelectedCards();
            
            // Create copy via arrangement
            arrangeCopiedCardsInRow();
            
            console.log('‚úÖ Test setup complete. Now try searching for "copy_" in the search box');
            console.log('üí° Also try: debugHiddenTags() to see all hidden tags');
        }
        
        // Test function for temporal markings - call this in console
        function testTemporalMarkings() {
            // Create test cards with different date scenarios
            const testData = [
                { id: 'test-today', title: 'Today Test', text: 'Meeting @250816', x: 100, y: 100 },
                { id: 'test-tomorrow', title: 'Tomorrow Test', text: 'Task @250817 #todo', x: 300, y: 100 },
                { id: 'test-future', title: 'Future Test', text: 'Event @250820', x: 500, y: 100 },
                { id: 'test-week', title: 'Week Test', text: 'Week meeting @25w33', x: 700, y: 100 },
                { id: 'test-past', title: 'Past Test', text: 'Old task @250815 #todo', x: 900, y: 100 }
            ];
            
            // Add test cards
            testData.forEach(card => {
                // Remove if exists
                const existing = cy.getElementById(card.id);
                if (existing.length > 0) {
                    existing.remove();
                }
                
                const node = cy.add({
                    data: {
                        id: card.id,
                        title: card.title,
                        text: card.text,
                        tags: [],
                        searchMatch: false
                    },
                    position: { x: card.x, y: card.y }
                });
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                node.grabify();
            });
            
            // Apply temporal markings
            setTimeout(() => {
                applyTemporalMarkings();
            }, 500);
            
            console.log('üß™ Test cards created! Check console for marking details.');
        }
        
        // Get earliest date from card content for sorting
        function getEarliestDateFromContent(node) {
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const fullContent = title + ' ' + text;
            
            const datePatterns = parseDateFromContent(fullContent);
            
            if (!datePatterns || datePatterns.length === 0) {
                // No dates found - use card creation date as fallback
                return extractDateFromId(node.id());
            }
            
            // Find earliest date from content
            let earliestDate = null;
            datePatterns.forEach(pattern => {
                const dateTime = pattern.date.getTime();
                if (!earliestDate || dateTime < earliestDate) {
                    earliestDate = dateTime;
                }
            });
            
            return earliestDate || extractDateFromId(node.id());
        }
        
        // ========================================
        // MOBILE SEARCH SUPPORT
        // ========================================
        
        // Function to select search results (mobile-friendly alternative to Enter key)
        function selectSearchResults() {
            const searchMatches = cy.$('.search-match');
            console.log('Mobile select button pressed, found matches:', searchMatches.length);
            
            if (searchMatches.length > 0) {
                // Convert search matches to selected cards
                searchMatches.select();
                console.log('Selected search matches via mobile button');
                
                // Clear search visuals but keep cards selected
                searchActive = false;
                cy.nodes().removeClass('search-match');
                cy.nodes().data('searchMatch', false);
                
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.classList.remove('visible');
                
                // Hide the select button
                const selectBtn = document.getElementById('searchSelectBtn');
                selectBtn.style.display = 'none';
                
                // Blur the search input so keyboard shortcuts work
                const searchInput = document.getElementById('searchInput');
                searchInput.blur();
                
                console.log(`‚úÖ Selected ${searchMatches.length} search results via mobile button`);
            }
        }
        
        // ========================================
        // END MOBILE SEARCH SUPPORT  
        // ========================================
        // ========================================
        // END DATE-BASED AUTO-MARKING SYSTEM
        // ========================================
        // ========================================
        // END SORTING SYSTEM
        // ========================================
        
        // Alignment functions for selected cards
        function alignSelectedVertical() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Get the leftmost card's X position as reference (fixed reference point)
            let referenceX = selectedNodes[0].position().x;
            selectedNodes.forEach(node => {
                if (node.position().x < referenceX) {
                    referenceX = node.position().x;
                }
            });
            
            // Sort cards by current Y position to maintain relative order
            const sortedNodes = selectedNodes.sort((a, b) => a.position().y - b.position().y);
            
            // Start from the topmost card's position, adjusted for its height
            const firstCardHeight = getMeasuredTextHeight(sortedNodes[0]);
            let currentY = sortedNodes[0].position().y - (firstCardHeight / 2);
            
            // Position each card using measured height + 20% spacing (60px)
            cy.batch(() => {
                sortedNodes.forEach((node, index) => {
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Position this card at its center Y
                    const centerY = currentY + (cardHeight / 2);
                    node.animate({
                        position: { x: referenceX, y: centerY }
                    }, {
                        duration: 300,
                        easing: 'ease-out'
                    });
                    
                    // Calculate next Y position with 20% spacing (60px)
                    if (index < sortedNodes.length - 1) {
                        const spacing = 60; // 20% of 300px card width
                        currentY += cardHeight + spacing;
                    }
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards vertically with 60px spacing`);
        }
        
        function alignSelectedVerticalSimple() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Get the leftmost card's X position as reference
            let referenceX = selectedNodes[0].position().x;
            selectedNodes.forEach(node => {
                if (node.position().x < referenceX) {
                    referenceX = node.position().x;
                }
            });
            
            // Align all cards to the same X position, keep original Y positions
            selectedNodes.forEach(node => {
                node.animate({
                    position: { x: referenceX, y: node.position().y }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards vertically (simple)`);
        }
        
        function alignSelectedHorizontal() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Calculate the average Y position for better alignment
            let totalY = 0;
            selectedNodes.forEach(node => {
                totalY += node.position().y;
            });
            const averageY = totalY / selectedNodes.length;
            
            // Align all cards to the average Y position (centers them)
            selectedNodes.forEach(node => {
                node.animate({
                    position: { x: node.position().x, y: averageY }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards horizontally at center`);
        }
        
        function arrangeSelectedInGrid() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInGrid();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            console.log('About to save state before grid arrangement');
            saveState();
            console.log('State saved, proceeding with arrangement');
            
            // Calculate grid dimensions
            const nodeCount = selectedNodes.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Calculate grid starting position (top-left corner)
            const spacing = 180; // Closer distance between cards for compact grid
            const gridWidth = (cols - 1) * spacing;
            const gridHeight = (rows - 1) * spacing;
            const startX = screenCenterX - (gridWidth / 2);
            const startY = screenCenterY - (gridHeight / 2);
            
            // Arrange nodes in grid with center alignment
            selectedNodes.forEach((node, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                const newX = startX + (col * spacing);
                const newY = startY + (row * spacing);
                
                node.animate({
                    position: { x: newX, y: newY }
                }, {
                    duration: 400,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered ${rows}√ó${cols} grid`);
        }
        
        function arrangeSelectedInColumn() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInColumn();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            
            // If only one card selected, move it instead of arranging
            if (selectedNodes.length === 1) {
                moveSelectedCard();
                return;
            }
            
            if (selectedNodes.length < 2) return;
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodesToArrange;
            if (sortMode) {
                nodesToArrange = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodesToArrange = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // Calculate total height needed for all cards with spacing
            let totalRequiredHeight = 0;
            nodesToArrange.forEach((node, index) => {
                const cardHeight = getCardHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < nodesToArrange.length - 1) {
                    totalRequiredHeight += 60; // 20% spacing (60px)
                }
            });
            
            // Start positioning from arrangement center, working upwards
            let currentY = centerY - (totalRequiredHeight / 2);
            
            nodesToArrange.forEach((node, index) => {
                // Get this card's actual height
                const cardHeight = getCardHeight(node);
                
                // Position this card at its center
                const cardCenterY = currentY + (cardHeight / 2);
                node.animate({
                    position: { x: centerX, y: cardCenterY }
                }, {
                    duration: 400,
                    easing: 'ease-out'
                });
                
                // Move to next card position
                if (index < selectedNodes.length - 1) {
                    const padding = 60; // 20% spacing
                    currentY += cardHeight + padding;
                }
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered column`);
        }
        
        function arrangeSelectedInRow() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInRow();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            console.log('H command: About to save state for undo');
            saveState();
            console.log('H command: State saved, proceeding with arrangement');
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then left-to-right order
            let sortedNodes;
            if (sortMode) {
                sortedNodes = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first, fallback to left-to-right
                const arrowSorted = getArrowBasedOrder(selectedNodes.toArray());
                sortedNodes = arrowSorted.length === selectedNodes.length ? arrowSorted : selectedNodes.sort((a, b) => a.position().x - b.position().x);
            }
            
            // Calculate total width needed for all cards with spacing (use 20% spacing)
            let totalRequiredWidth = 0;
            sortedNodes.forEach((node, index) => {
                const cardWidth = getCardWidth(node);
                totalRequiredWidth += cardWidth;
                if (index < sortedNodes.length - 1) {
                    totalRequiredWidth += 60; // 20% of 300px = 60px spacing
                }
            });
            
            // Start positioning from arrangement center, working leftwards
            let currentX = centerX - (totalRequiredWidth / 2);
            
            cy.batch(() => {
                sortedNodes.forEach((node, index) => {
                    // Get this card's actual width and height
                    const cardWidth = getCardWidth(node);
                    const cardHeight = getCardHeight(node);
                    
                    // Position this card with top-aligned positioning
                    const cardCenterX = currentX + (cardWidth / 2);
                    const cardCenterY = centerY + (cardHeight / 2); // Top-align: center Y based on card's height
                    
                    node.animate({
                        position: { x: cardCenterX, y: cardCenterY }
                    }, {
                        duration: 400,
                        easing: 'ease-out'
                    });
                    
                    // Move to next card position with 20% spacing
                    currentX += cardWidth + 60;
                });
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered row with 20% spacing`);
        }
        
        // Helper function to calculate card width (considers geometric shapes)
        function getCardWidth(node) {
            // Check if it's a geometric shape with custom width
            if (node.data('isAnnotation') && node.data('customWidth')) {
                return node.data('customWidth');
            }
            return 300; // Fixed width for all regular cards
        }
        
        // Helper function to calculate card height (considers geometric shapes)
        function getCardHeight(node) {
            // Check if it's a geometric shape with custom height
            if (node.data('isAnnotation') && node.data('customHeight')) {
                return node.data('customHeight');
            }
            return getMeasuredTextHeight(node); // Use text-based height for regular cards
        }
        
        
        // Create new cards from copied data and arrange them in column
        function createAndArrangeInColumn() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create new nodes from copied card data
            const newNodes = [];
            copiedCards.forEach(cardData => {
                const newNode = cy.add({
                    data: {
                        id: generateCardId(),
                        title: cardData.title,
                        text: cardData.text,
                        tags: cardData.tags,
                        hidden_tags: cardData.hidden_tags,
                        searchMatch: false,
                        // Copy all metadata
                        export_timestamp: cardData.export_timestamp,
                        export_session: cardData.export_session,
                        export_source: cardData.export_source,
                        source_file: cardData.source_file,
                        page_number: cardData.page_number,
                        matched_terms: cardData.matched_terms,
                        card_index: cardData.card_index,
                        isManualCard: cardData.isManualCard,
                        cardColor: cardData.cardColor,
                        // Copy metadata
                        copyOf: cardData.copyOf,
                        isCopy: cardData.isCopy,
                        copyTimestamp: cardData.copyTimestamp
                    },
                    position: { x: centerX, y: centerY }
                });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Calculate total height needed for all cards with spacing
            let totalRequiredHeight = 0;
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < newNodes.length - 1) {
                    totalRequiredHeight += 60; // 20% spacing
                }
            });
            
            // Start positioning from arrangement center, working upwards
            let currentY = centerY - (totalRequiredHeight / 2);
            
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                
                node.position({ x: centerX, y: cardCenterY });
                
                // Move to next position
                if (index < newNodes.length - 1) {
                    currentY += cardHeight + 60;
                }
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in column`);
        }
        
        // Create new cards from copied data and arrange them in row (H command)
        function createAndArrangeInRow() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create new nodes from copied card data
            const newNodes = [];
            copiedCards.forEach(cardData => {
                const newNode = cy.add({
                    data: {
                        id: generateCardId(),
                        title: cardData.title,
                        text: cardData.text,
                        tags: cardData.tags,
                        hidden_tags: cardData.hidden_tags,
                        searchMatch: false,
                        isManualCard: cardData.isManualCard,
                        cardColor: cardData.cardColor,
                        copyOf: cardData.copyOf,
                        isCopy: cardData.isCopy,
                        copyTimestamp: cardData.copyTimestamp
                    },
                    position: { x: centerX, y: centerY }
                });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in horizontal row with 60px spacing
            const cardWidth = 300;
            const spacing = 60; // 20% spacing
            let totalWidth = newNodes.length * cardWidth + (newNodes.length - 1) * spacing;
            let currentX = centerX - (totalWidth / 2);
            
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterX = currentX + (cardWidth / 2);
                const cardCenterY = centerY + (cardHeight / 2);
                
                node.position({ x: cardCenterX, y: cardCenterY });
                currentX += cardWidth + spacing;
            });
            
            // Clear copied cards and select new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in row`);
        }
        
        // Move single selected card to mouse cursor
        function moveSelectedCard() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length !== 1) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const targetX = arrangePos.x;
            const targetY = arrangePos.y;
            
            const node = selectedNodes[0];
            const cardHeight = getMeasuredTextHeight(node);
            // Position so card's top edge is at mouse cursor
            const cardCenterY = targetY + (cardHeight / 2);
            
            node.animate({
                position: { x: targetX, y: cardCenterY }
            }, {
                duration: 300,
                easing: 'ease-out'
            });
            
            console.log(`Moved card to cursor position (${Math.round(targetX)}, ${Math.round(targetY)})`);
        }
        
        // Stack: Neat stack, top and left aligned at mouse cursor
        function stackSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const baseX = arrangePos.x; // Start at mouse cursor X
            const baseY = arrangePos.y; // Start at mouse cursor Y (top edge)
            
            // Sort cards by current position for consistent stacking
            const sortedNodes = selectedNodes.sort((a, b) => a.position().y - b.position().y);
            
            // Stack them with small offset for neat pile effect
            const stackOffsetX = 3; // 3px right offset per card
            const stackOffsetY = 5; // 5px down offset per card
            
            sortedNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const stackX = baseX + (index * stackOffsetX);
                // Position so first card's top edge is at mouse cursor Y
                const stackY = baseY + (index * stackOffsetY) + (cardHeight / 2);
                
                node.animate({
                    position: { x: stackX, y: stackY }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Stack: Created neat pile of ${selectedNodes.length} cards at cursor`);
        }
        
        function updateSelectionInfo() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectedNodes.length === 0) {
                selectionInfo.classList.remove('visible');
                return;
            }
            
            const count = selectedNodes.length;
            const pinnedCount = selectedNodes.filter('.pinned').length;
            const unpinnedCount = count - pinnedCount;
            
            let text = `${count} kort markerade`;
            if (pinnedCount > 0 && unpinnedCount > 0) {
                text += ` (${pinnedCount} pinnade, ${unpinnedCount} opinnde)`;
            } else if (pinnedCount > 0) {
                text += ` (alla pinnade)`;
            } else {
                text += ` (alla opinnde)`;
            }
            
            text += '<br><small>';
            if (count >= 2) {
                text += '1=kolumn, 2=rad, 3=rutn√§t, V=f√∂rdela‚Üï, Shift+V=linje‚Üï, H=linje‚Üî';
            } else {
                text += 'P=pin, U=unpin, Delete=ta bort, Esc=avmarkera';
            }
            text += '</small>';
            
            selectionInfo.innerHTML = text;
            selectionInfo.classList.add('visible');
        }
        
        // Layout functions
        function applyLayout() {
            const layoutSelect = document.getElementById('layoutSelect');
            const selectedLayout = layoutSelect.value;
            
            let layoutOptions;
            
            switch(selectedLayout) {
                case 'cose':
                    layoutOptions = {
                        name: 'cose',
                        idealEdgeLength: 150,
                        nodeOverlap: 100,
                        refresh: 20,
                        fit: false,
                        padding: 50,
                        randomize: false,
                        componentSpacing: 100,
                        nodeRepulsion: 400000,
                        edgeElasticity: 100,
                        nestingFactor: 5,
                        gravity: 80,
                        numIter: 1000,
                        animate: true
                    };
                    break;
                case 'grid':
                    // Use custom smart grid layout instead of Cytoscape's grid
                    applySmartGridLayout();
                    return;
                default: // preset
                    // Don't run layout for manual positioning
                    return;
            }
            
            const layout = cy.layout(layoutOptions);
            layout.run();
        }
        
        // Smart column layout - all cards in single column with top alignment
        function arrangeAllInColumn() {
            const allNodes = cy.nodes();
            if (allNodes.length === 0) return;
            
            // Calculate center X position
            let totalX = 0;
            allNodes.forEach(node => {
                totalX += node.position().x;
            });
            const centerX = totalX / allNodes.length;
            
            // Calculate total height needed and start from center
            let totalRequiredHeight = 0;
            allNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < allNodes.length - 1) {
                    totalRequiredHeight += 30; // spacing between cards
                }
            });
            
            // Start positioning from center, working upwards
            let currentY = -(totalRequiredHeight / 2);
            
            allNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                
                node.animate({
                    position: { x: centerX, y: cardCenterY }
                }, {
                    duration: 500,
                    easing: 'ease-out'
                });
                
                // Move to next card position
                if (index < allNodes.length - 1) {
                    currentY += cardHeight + 30;
                }
            });
            
            // Show feedback
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `Kolumn-layout applicerat: ${allNodes.length} kort i en kolumn`;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // Smart grid layout using same spacing as arrangements
        function applySmartGridLayout() {
            const allNodes = cy.nodes();
            if (allNodes.length === 0) return;
            
            // Calculate grid dimensions
            const nodeCount = allNodes.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Calculate center point of all nodes
            let totalX = 0, totalY = 0;
            allNodes.forEach(node => {
                const pos = node.position();
                totalX += pos.x;
                totalY += pos.y;
            });
            const centerX = totalX / allNodes.length;
            const centerY = totalY / allNodes.length;
            
            // Measure card dimensions for smart spacing (same as arrangements)
            const ruler = document.getElementById('text-ruler');
            let maxCardWidth = 280; // Default
            let maxCardHeight = 120; // Default
            
            allNodes.forEach(node => {
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const tags = node.data('tags') || [];
                
                // Measure text height
                const combinedText = title + '\n\n' + text + '\n\n' + tags.map(tag => `#${tag}`).join(' ');
                ruler.textContent = combinedText;
                const measuredHeight = Math.max(140, ruler.offsetHeight + 40);
                maxCardHeight = Math.max(maxCardHeight, measuredHeight);
                
                // Calculate width based on content
                const baseWidth = 180;
                const extraWidth = Math.min(120, (title + text).length * 0.9);
                const cardWidth = baseWidth + extraWidth;
                maxCardWidth = Math.max(maxCardWidth, cardWidth);
            });
            
            // Add smart spacing
            const horizontalSpacing = maxCardWidth + 40;
            const verticalSpacing = maxCardHeight + 30;
            
            // Calculate grid starting position (centered)
            const gridWidth = (cols - 1) * horizontalSpacing;
            const gridHeight = (rows - 1) * verticalSpacing;
            const startX = centerX - gridWidth / 2;
            const startY = centerY - gridHeight / 2;
            
            // Position nodes in grid with top-aligned rows
            const nodeArray = allNodes.toArray();
            
            // Group nodes by row and calculate each row's top position
            for (let row = 0; row < rows; row++) {
                const rowNodes = [];
                const rowStartIndex = row * cols;
                const rowEndIndex = Math.min((row + 1) * cols, nodeArray.length);
                
                // Get nodes for this row
                for (let i = rowStartIndex; i < rowEndIndex; i++) {
                    rowNodes.push(nodeArray[i]);
                }
                
                // Find tallest card in this row to determine row height
                let maxRowHeight = 0;
                rowNodes.forEach(node => {
                    const cardHeight = getMeasuredTextHeight(node);
                    maxRowHeight = Math.max(maxRowHeight, cardHeight);
                });
                
                // Position each card in this row (top-aligned)
                rowNodes.forEach((node, colIndex) => {
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    const newX = startX + colIndex * horizontalSpacing;
                    const rowBaseY = startY + row * verticalSpacing;
                    // Align to top of row, then center the card within its space
                    const newY = rowBaseY;
                    
                    node.animate({
                        position: { x: newX, y: newY }
                    }, {
                        duration: 500,
                        easing: 'ease-out'
                    });
                });
            }
            
            // Show feedback
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `Grid-layout applicerat: ${cols}√ó${rows} rutn√§t med ${allNodes.length} kort`;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // G+V: Grid Vertical - column-focused arrangement with max gap between cards (bottom-edge to top-edge)
        function arrangeSelectedGridVerticalColumns() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridVerticalColumns();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState();
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // G+V: Column-focused arrangement with max gap between bottom-edge to top-edge
            const nodeCount = nodeArray.length;
            const maxCols = 6; // Max 6 columns
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const cardsPerCol = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 350; // Gap between columns
            const maxVerticalGap = 80; // Max gap from bottom-edge of upper card to top-edge of lower card
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Top-aligned columns - all start from same Y position (like G+H but vertical)
            const topLineY = screenCenterY; // All columns start from same top line
            
            // Arrange column by column (instead of row by row)
            for (let col = 0; col < cols; col++) {
                const colStartIndex = col * cardsPerCol;
                const colEndIndex = Math.min(colStartIndex + cardsPerCol, nodeCount);
                const cardsInThisCol = colEndIndex - colStartIndex;
                
                if (cardsInThisCol === 0) continue;
                
                const colX = startX + col * horizontalSpacing;
                
                // Start each column from the same top line
                let currentTopY = topLineY;
                
                // Place cards in this column with gap between bottom and top edges
                for (let cardIndex = 0; cardIndex < cardsInThisCol; cardIndex++) {
                    const nodeIndex = colStartIndex + cardIndex;
                    const node = nodeArray[nodeIndex];
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Card center is at currentTopY + half height
                    const cardCenterY = currentTopY + (cardHeight / 2);
                    
                    console.log(`üéØ G+V placing node ${nodeIndex} (${node.id()}) in col ${col}, position ${cardIndex}, top-aligned, gap: ${maxVerticalGap}px`);
                    
                    node.animate({
                        position: { x: colX, y: cardCenterY }
                    }, {
                        duration: 400,
                        easing: 'ease-out'
                    });
                    
                    // Move to next position: current card bottom + gap
                    currentTopY += cardHeight + maxVerticalGap;
                }
            }
            
            console.log(`G+V: Top-alignade kolumner - ${cols} kolumner, 80px vertikalt, 350px horisontellt`);
        }
        
        // G+H: Grid where rows are top-aligned and packed tightly (no row overlap)
        function arrangeSelectedGridHorizontalPacked() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridHorizontalPacked();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            saveState();
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            const nodeCount = selectedNodes.length;
            const maxCols = 6;
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const rows = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 360; // 60px gap between cards (360 - 300 = 60)
            const rowPadding = 95; // Adjusted to get actual 60px visual spacing
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // First pass: calculate the height of each row
            const rowHeights = [];
            for (let row = 0; row < rows; row++) {
                let maxRowHeight = 0;
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        maxRowHeight = Math.max(maxRowHeight, cardHeight);
                    }
                }
                rowHeights.push(maxRowHeight);
            }
            
            // Calculate total height and start position - top of grid at mouse cursor
            const totalHeight = rowHeights.reduce((sum, height) => sum + height, 0) + (rows - 1) * rowPadding;
            let currentY = screenCenterY; // Top of grid at mouse cursor
            
            // Second pass: position cards row by row with tight packing
            for (let row = 0; row < rows; row++) {
                const rowHeight = rowHeights[row];
                
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const newX = startX + col * horizontalSpacing;
                        
                        // Position card at top of its row space
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2); // Top-aligned within row
                        
                        node.animate({
                            position: { x: newX, y: cardCenterY }
                        }, {
                            duration: 400,
                            easing: 'ease-out'
                        });
                    }
                }
                
                // Move to next row position
                currentY += rowHeight + rowPadding;
            }
            
            console.log(`G+H: Grid med packade rader - toppen vid muspekare - ${rows} rader √ó ${cols} kolumner f√∂r ${selectedNodes.length} kort`);
        }
        
        // G+T: Grid where all rows are top-aligned (all cards in same row at same height)
        // G+T (Grid Tight): Max 6 cards wide, 5% horizontal spacing, 40px overlap between cards vertically
        function arrangeSelectedGridTopAligned() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridTopAligned();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            const nodeCount = selectedNodes.length;
            const maxCols = 6; // Max 6 cards wide
            const cols = Math.min(maxCols, nodeCount);
            const rows = Math.ceil(nodeCount / cols);
            
            const cardWidth = 300;
            const horizontalSpacing = cardWidth * 0.05; // 5% of card width = 15px
            const overlapSpacing = 120; // 120px between card tops (3x more to show titles)
            
            // Calculate grid size
            const gridWidth = (cols - 1) * (cardWidth + horizontalSpacing);
            const startX = screenCenterX - gridWidth / 2;
            
            // For top row alignment
            const topRowY = screenCenterY - 100; // Start a bit above center
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            const wasSorted = !!sortMode;
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // Row-by-row placement to respect arrow sorting order
            for (let row = 0; row < rows; row++) {
                let currentY = topRowY + row * overlapSpacing;
                
                // Go through each column in this row
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const colX = startX + col * (cardWidth + horizontalSpacing);
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2);
                        
                        console.log(`üéØ G+T placing node ${nodeIndex} (${node.id()}) at col ${col}, row ${row}`);
                        
                        node.animate({
                            position: { x: colX, y: cardCenterY }
                        }, {
                            duration: 400,
                            easing: 'ease-out'
                        });
                    }
                }
            }
            
            // Z-LAYERING: Disabled for now - remove/re-add breaks original creation timestamps
            // TODO: Find Cytoscape method that changes render order without breaking node identity
            
            console.log(`G+T: Tight grid with 120px overlap - max ${maxCols} wide, ${rows} deep for ${selectedNodes.length} cards`);
        }
        
        // Change tracking for autosave
        let hasChanges = false;
        let autosaveInterval = null;
        
        // Mark that changes have been made
        function markChanged() {
            hasChanges = true;
        }
        
        // Save board to localStorage or file
        function saveBoard(filename = null, isAutosave = false) {
            const now = new Date();
            const boardData = {
                cards: cy.nodes().map(node => ({
                    id: node.id(),
                    title: node.data('title') || '',
                    text: node.data('text') || '',
                    tags: node.data('tags') || [],
                    hidden_tags: node.data('hidden_tags') || [],
                    position: node.position(),
                    pinned: node.hasClass('pinned') || false,
                    isManualCard: node.data('isManualCard') || false,
                    cardColor: node.data('cardColor') || null,
                    // Preserve all metadata for advanced analysis
                    export_timestamp: node.data('export_timestamp') || null,
                    export_session: node.data('export_session') || null,
                    export_source: node.data('export_source') || null,
                    source_file: node.data('source_file') || null,
                    page_number: node.data('page_number') || null,
                    matched_terms: node.data('matched_terms') || null,
                    card_index: node.data('card_index') || null,
                    // Annotation-specific data
                    isAnnotation: node.data('isAnnotation') || false,
                    annotationType: node.data('annotationType') || null,
                    customWidth: node.data('customWidth') || null,
                    customHeight: node.data('customHeight') || null,
                    customZIndex: node.data('customZIndex') || null,
                    // Save annotation color from visual style
                    annotationColor: node.data('isAnnotation') ? node.style('background-color') : null,
                    // Save shape data for geometric figures
                    shape: node.data('shape') || null,
                    // Save custom font size for geometric shapes
                    customFontSize: node.data('customFontSize') || null,
                    // Save copy metadata for copy tracking
                    copyOf: node.data('copyOf') || null,
                    isCopy: node.data('isCopy') || false,
                    copyTimestamp: node.data('copyTimestamp') || null,
                    // IMAGE DATA - New addition for v2.0 backwards compatibility
                    type: node.data('type') || null, // 'image' for image nodes
                    imageData: node.data('imageData') || null, // Base64 image data
                    annotation: node.data('annotation') || null, // Image annotation text
                    searchableText: node.data('searchableText') || null, // Lowercased searchable text
                    originalFileName: node.data('originalFileName') || null // Original filename
                })),
                edges: cy.edges().map(edge => ({
                    id: edge.id(),
                    source: edge.source().id(),
                    target: edge.target().id(),
                    // Preserve all edge data
                    isAnnotation: edge.data('isAnnotation') || false,
                    annotationType: edge.data('annotationType') || null,
                    customColor: edge.data('customColor') || null,
                    // Save all visual styling
                    style: {
                        'line-color': edge.style('line-color'),
                        'target-arrow-color': edge.style('target-arrow-color'),
                        'target-arrow-shape': edge.style('target-arrow-shape'),
                        'source-arrow-color': edge.style('source-arrow-color'),
                        'source-arrow-shape': edge.style('source-arrow-shape'),
                        'width': edge.style('width'),
                        'curve-style': edge.style('curve-style'),
                        'control-point-step-size': edge.style('control-point-step-size'),
                        'opacity': edge.style('opacity')
                    }
                })),
                viewport: {
                    zoom: cy.zoom(),
                    pan: cy.pan()
                },
                // Save global arrow visibility state
                arrowsHidden: window.arrowsHidden || false,
                lastModified: now.getTime(), // Unix timestamp for comparison
                timestamp: now.toISOString(), // Human readable
                version: '2.0' // Updated for image support
            };
            
            if (filename) {
                // Save to file
                const blob = new Blob([JSON.stringify(boardData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                // Save to localStorage
                localStorage.setItem('spatial-notes-board', JSON.stringify(boardData));
            }
            
            // Reset change tracking
            hasChanges = false;
            
            // Show saved message
            const searchInfo = document.getElementById('searchInfo');
            if (isAutosave) {
                searchInfo.textContent = 'Auto-sparad ‚úì';
            } else {
                searchInfo.textContent = 'Sparad ‚úì';
            }
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // Save with timestamp filename
        function saveWithTimestamp() {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('.')[0];
            const filename = `board-name_${timestamp}.json`;
            saveBoard(filename);
        }
        
        // Save as dialog
        function saveAs() {
            const filename = prompt('Filnamn (utan .json):', 'my-board');
            if (filename) {
                saveBoard(filename.endsWith('.json') ? filename : filename + '.json');
            }
        }
        
        // Autosave function
        function performAutosave() {
            if (hasChanges) {
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('.')[0];
                const filename = `board-name_autosave_${timestamp}.json`;
                saveBoard(filename, true);
            }
        }
        
        // Start autosave timer
        function startAutosave() {
            if (autosaveInterval) {
                clearInterval(autosaveInterval);
            }
            // Every 20 minutes (1200000 ms)
            autosaveInterval = setInterval(performAutosave, 20 * 60 * 1000);
        }
        
        
        // Load board data (internal function without UI alerts)
        function loadBoardFromData(boardData) {
            try {
                // Safety check: Ensure Cytoscape is fully initialized
                if (!cy || !cy.nodes || !cy.add || typeof cy.add !== 'function') {
                    throw new Error('Cytoscape √§r inte redo √§n. V√§nta ett √∂gonblick och f√∂rs√∂k igen.');
                }
                
                // Clear existing nodes
                cy.nodes().remove();
                
                // Add saved cards
                boardData.cards.forEach(cardData => {
                    const newNode = cy.add({
                        data: {
                            id: cardData.id,
                            title: cardData.title,
                            text: cardData.text,
                            tags: cardData.tags || [],
                            hidden_tags: cardData.hidden_tags || [],
                            searchMatch: false,
                            isManualCard: cardData.isManualCard || false,
                            cardColor: cardData.cardColor || null,
                            // Preserve metadata if present
                            export_timestamp: cardData.export_timestamp || null,
                            export_session: cardData.export_session || null,
                            export_source: cardData.export_source || null,
                            source_file: cardData.source_file || null,
                            page_number: cardData.page_number || null,
                            matched_terms: cardData.matched_terms || null,
                            card_index: cardData.card_index || null,
                            // Annotation-specific data
                            isAnnotation: cardData.isAnnotation || false,
                            annotationType: cardData.annotationType || null,
                            customWidth: cardData.customWidth || null,
                            customHeight: cardData.customHeight || null,
                            customZIndex: cardData.customZIndex || null,
                            // Store annotation color for restoration
                            annotationColor: cardData.annotationColor || null,
                            // Store shape data for geometric figures
                            shape: cardData.shape || null,
                            // Store custom font size for geometric shapes
                            customFontSize: cardData.customFontSize || null,
                            // Restore copy metadata for copy tracking
                            copyOf: cardData.copyOf || null,
                            isCopy: cardData.isCopy || false,
                            copyTimestamp: cardData.copyTimestamp || null,
                            // IMAGE DATA - Backwards compatible restoration
                            type: cardData.type || null, // 'image' for image nodes
                            imageData: cardData.imageData || null, // Base64 image data
                            annotation: cardData.annotation || null, // Image annotation text
                            searchableText: cardData.searchableText || null, // Lowercased searchable text
                            originalFileName: cardData.originalFileName || null // Original filename
                        },
                        position: cardData.position
                    });
                    
                    // Restore pinned state
                    if (cardData.pinned) {
                        newNode.addClass('pinned');
                    }
                    
                    // Restore annotation shape class and text label
                    if (cardData.isAnnotation && cardData.annotationType === 'shape') {
                        newNode.addClass('annotation-shape');
                        
                        // Make sure text shows as label for annotations
                        if (cardData.text) {
                            newNode.style('label', cardData.text);
                            console.log('‚úÖ Restored annotation text:', cardData.text, 'for node:', cardData.id);
                        }
                    }
                    
                    // Restore custom size, layer and color for annotation nodes
                    if (cardData.isAnnotation && (cardData.customWidth || cardData.customHeight || cardData.customZIndex !== null || cardData.annotationColor)) {
                        const width = cardData.customWidth || 120;
                        const height = cardData.customHeight || 120;
                        const zIndex = cardData.customZIndex !== null ? cardData.customZIndex : -1;
                        
                        // Convert internal z-index to Cytoscape z-index
                        let cyZIndex = 1; // default
                        if (zIndex === -1) cyZIndex = 0; // Background
                        if (zIndex === 0) cyZIndex = 1;  // Normal
                        if (zIndex === 1) cyZIndex = 2;  // Foreground
                        
                        const styleUpdate = {
                            'width': width + 'px',
                            'height': height + 'px',
                            'z-index': cyZIndex
                        };
                        
                        // Restore annotation color if saved
                        if (cardData.annotationColor && cardData.annotationColor !== 'rgb(255,255,255)') {
                            styleUpdate['background-color'] = cardData.annotationColor;
                        }
                        
                        // Restore custom font size if saved
                        if (cardData.customFontSize) {
                            styleUpdate['font-size'] = cardData.customFontSize + 'px';
                        }
                        
                        newNode.style(styleUpdate);
                        console.log('‚úÖ Restored annotation styling for', newNode.id(), 'color:', cardData.annotationColor, 'shape:', cardData.shape);
                    }
                    
                    // Restore card color
                    if (cardData.cardColor) {
                        newNode.style('background-color', getCardColorValue(cardData.cardColor, getCurrentTheme()));
                    }
                    
                    // IMAGE NODE RESTORATION - Special handling for image nodes
                    if (cardData.type === 'image' && cardData.imageData) {
                        console.log('üñºÔ∏è Restoring image node:', cardData.originalFileName);
                        
                        // Apply image-specific styling (height will be calculated by Cytoscape style function)
                        newNode.style({
                            'background-image': cardData.imageData,
                            'background-fit': 'cover',
                            'width': '300px' // Same as regular cards
                        });
                        
                        // Update label to show annotation indicator if present
                        // Don't show filename in title, keep title empty for clean image display
                        newNode.data('title', '');
                        
                        const filename = cardData.originalFileName || 'Image';
                        const hasAnnotation = (cardData.annotation || '').length > 0;
                        console.log(`‚úÖ Restored image: ${filename} (${hasAnnotation ? 'with annotation' : 'no annotation'})`);
                    }
                    
                    newNode.grabify();
                });
                
                // Restore edges/arrows if they exist
                if (boardData.edges && Array.isArray(boardData.edges)) {
                    boardData.edges.forEach(edgeData => {
                        const newEdge = cy.add({
                            data: {
                                id: edgeData.id,
                                source: edgeData.source,
                                target: edgeData.target,
                                isAnnotation: edgeData.isAnnotation || false,
                                annotationType: edgeData.annotationType || null,
                                customColor: edgeData.customColor || null
                            }
                        });
                        
                        // Apply annotation classes for styling
                        if (edgeData.isAnnotation) {
                            newEdge.addClass('annotation-connection');
                        }
                        
                        // Restore all visual styling
                        if (edgeData.style) {
                            newEdge.style(edgeData.style);
                            console.log('‚úÖ Restored edge styling for', edgeData.id, 'arrow shape:', edgeData.style['target-arrow-shape']);
                        }
                    });
                    console.log('‚úÖ Restored', boardData.edges.length, 'edges/arrows');
                }
                
                // Card IDs are now timestamp-based, no counter needed
                
                // Restore viewport (zoom and pan) if saved
                if (boardData.viewport) {
                    cy.zoom(boardData.viewport.zoom);
                    cy.pan(boardData.viewport.pan);
                }
                
                // Restore global arrow visibility state
                if (boardData.arrowsHidden !== undefined) {
                    window.arrowsHidden = boardData.arrowsHidden;
                    if (window.arrowsHidden) {
                        // Apply hidden state to all edges
                        cy.edges().style('opacity', 0);
                    }
                }
                
                // Removed annoying "Laddade X kort!" alert - user can see the cards loaded
                
                // Apply temporal markings after data is loaded
                setTimeout(() => {
                    applyTemporalMarkings();
                }, 200);
                
            } catch (error) {
                console.error('Error loading board data:', error);
                throw error;
            }
        }
        
        // Load board from file
        function loadBoard() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const boardData = JSON.parse(e.target.result);
                            loadBoardFromData(boardData);
                            console.log(`File loaded: ${boardData.cards.length} cards and ${(boardData.edges || []).length} edges`);
                        } catch (error) {
                            alert('Fel vid laddning av fil: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        // Check for newer files on startup
        function checkForNewerFiles() {
            // This is a placeholder - browser can't scan local files for security reasons
            // User will need to manually check their folder or we could implement a file timestamp cache
            console.log('Note: Manual file checking needed - browser cannot scan local folder');
        }
        
        // Startup conflict detection (simplified for browser limitations)
        function checkStartupConflicts() {
            const savedData = localStorage.getItem('spatial-notes-board');
            if (savedData) {
                try {
                    const boardData = JSON.parse(savedData);
                    if (boardData.lastModified) {
                        const lastModified = new Date(boardData.lastModified);
                        const hoursSinceModified = (Date.now() - boardData.lastModified) / (1000 * 60 * 60);
                        
                        if (hoursSinceModified < 24) { // Show warning if modified within 24 hours
                            const timeAgo = hoursSinceModified < 1 ? 
                                `${Math.round(hoursSinceModified * 60)} minuter sedan` : 
                                `${Math.round(hoursSinceModified)} timmar sedan`;
                            
                            console.log(`Varning: LocalStorage har data sparad ${timeAgo}. Kom ih√•g att ladda senaste version fr√•n fil om du arbetat p√• annan dator.`);
                            
                            // Show subtle reminder in status
                            const searchInfo = document.getElementById('searchInfo');
                            searchInfo.textContent = `üí° LocalStorage fr√•n ${timeAgo}`;
                            searchInfo.classList.add('visible');
                            setTimeout(() => {
                                searchInfo.classList.remove('visible');
                            }, 5000);
                        }
                    }
                } catch (error) {
                    console.error('Error checking startup conflicts:', error);
                }
            }
        }
        
        // Save board as standalone HTML file
        function saveAsHTMLFile() {
            const currentCards = cy.nodes().map(node => ({
                id: node.id(),
                title: node.data('title') || '',
                text: node.data('text') || '',
                tags: node.data('tags') || [],
                position: node.position(),
                pinned: node.hasClass('pinned') || false
            }));
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = prompt('Namn p√• HTML-fil:', `spatial-notes-${timestamp}`) || `spatial-notes-${timestamp}`;
            
            // Check if running locally (file://) - fetch won't work due to CORS
            if (window.location.protocol === 'file:') {
                alert('HTML-export fungerar inte n√§r filen k√∂rs lokalt (file://) pga CORS-s√§kerhet.\n\nF√∂r att anv√§nda HTML-export:\n1. K√∂r filen p√• en webbserver\n2. Eller anv√§nd "üíæ Spara" ist√§llet (sparar till localStorage)');
                return;
            }
            
            // Read current HTML as template
            fetch(window.location.href)
                .then(response => response.text())
                .then(currentHTML => {
                    // Replace the initialCards array with current cards
                    const cardArrayRegex = /const initialCards = \[[\s\S]*?\];/;
                    const newCardsArray = `const initialCards = ${JSON.stringify(currentCards, null, 12)};`;
                    
                    let newHTML = currentHTML.replace(cardArrayRegex, newCardsArray);
                    
                    // Update title
                    newHTML = newHTML.replace(/<title>.*?<\/title>/, `<title>Spatial Notes - ${filename}</title>`);
                    
                    // Add metadata comment
                    const metadataComment = `<!-- Saved from Spatial Notes on ${new Date().toLocaleString('sv-SE')} with ${currentCards.length} cards -->`;
                    newHTML = newHTML.replace('</head>', `    ${metadataComment}\n</head>`);
                    
                    // Create and download file
                    const blob = new Blob([newHTML], { type: 'text/html;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename.endsWith('.html') ? filename : filename + '.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show confirmation
                    const searchInfo = document.getElementById('searchInfo');
                    searchInfo.textContent = `HTML-fil sparad: ${a.download} (${currentCards.length} kort)`;
                    searchInfo.classList.add('visible');
                    setTimeout(() => {
                        searchInfo.classList.remove('visible');
                    }, 3000);
                })
                .catch(error => {
                    console.error('Error creating HTML file:', error);
                    alert('Fel vid skapande av HTML-fil: ' + error.message);
                });
        }
        
        // Export board to JSON file (WORKS LOCALLY - No CORS issues!)
        function exportToJSON() {
            try {
                const exportData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        exportApp: 'Spatial Notes',
                        version: '2.0', // Updated for image support
                        totalCards: cy.nodes().length,
                        totalEdges: cy.edges().length,
                        totalImages: cy.nodes('[type="image"]').length
                    },
                    viewport: {
                        zoom: cy.zoom(),
                        pan: cy.pan()
                    },
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        hidden_tags: node.data('hidden_tags') || [],
                        position: {
                            x: Math.round(node.position().x),
                            y: Math.round(node.position().y)
                        },
                        pinned: node.hasClass('pinned') || false,
                        isManualCard: node.data('isManualCard') || false,
                        cardColor: node.data('cardColor') || null,
                        // Preserve all metadata for advanced analysis
                        export_timestamp: node.data('export_timestamp') || null,
                        export_session: node.data('export_session') || null,
                        export_source: node.data('export_source') || null,
                        source_file: node.data('source_file') || null,
                        page_number: node.data('page_number') || null,
                        matched_terms: node.data('matched_terms') || null,
                        card_index: node.data('card_index') || null,
                        // Annotation-specific data (geometric shapes)
                        isAnnotation: node.data('isAnnotation') || false,
                        annotationType: node.data('annotationType') || null,
                        customWidth: node.data('customWidth') || null,
                        customHeight: node.data('customHeight') || null,
                        customZIndex: node.data('customZIndex') || null,
                        customFontSize: node.data('customFontSize') || null,
                        // Save annotation color from visual style
                        annotationColor: node.data('isAnnotation') ? node.style('background-color') : null,
                        // Save shape data for geometric figures
                        shape: node.data('shape') || null,
                        // IMAGE DATA - Essential for exporting images
                        type: node.data('type') || null, // 'image' for image nodes
                        imageData: node.data('imageData') || null, // Base64 image data
                        annotation: node.data('annotation') || null, // Image annotation text
                        searchableText: node.data('searchableText') || null, // Searchable text
                        originalFileName: node.data('originalFileName') || null // Original filename
                    })),
                    edges: cy.edges().map(edge => ({
                        id: edge.id(),
                        source: edge.source().id(),
                        target: edge.target().id(),
                        // Preserve all edge data
                        isAnnotation: edge.data('isAnnotation') || false,
                        annotationType: edge.data('annotationType') || null,
                        customColor: edge.data('customColor') || null,
                        // Save all visual styling
                        style: {
                            'line-color': edge.style('line-color'),
                            'target-arrow-color': edge.style('target-arrow-color'),
                            'target-arrow-shape': edge.style('target-arrow-shape'),
                            'source-arrow-color': edge.style('source-arrow-color'),
                            'source-arrow-shape': edge.style('source-arrow-shape'),
                            'width': edge.style('width'),
                            'curve-style': edge.style('curve-style'),
                            'control-point-step-size': edge.style('control-point-step-size'),
                            'opacity': edge.style('opacity')
                        }
                    })),
                    // Save global arrow visibility state
                    arrowsHidden: window.arrowsHidden || false
                };
                
                // Generate filename with timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = prompt('Namn p√• JSON-fil:', `spatial-notes-${timestamp}.json`) || `spatial-notes-${timestamp}.json`;
                
                if (!filename) return; // User cancelled
                
                // Ensure .json extension
                const finalFilename = filename.endsWith('.json') ? filename : filename + '.json';
                
                // Create and download JSON file
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show confirmation
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = `üìã JSON-fil exporterad: ${finalFilename} (${exportData.cards.length} kort, ${exportData.edges.length} pilar)`;
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
                
                console.log(`JSON export completed: ${finalFilename} with ${exportData.cards.length} cards and ${exportData.edges.length} edges`);
                
            } catch (error) {
                console.error('Error exporting JSON:', error);
                alert('Fel vid JSON-export: ' + error.message);
            }
        }
        
        // Import board from JSON file (WORKS LOCALLY!)
        function importFromJSON() {
            // Create hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json,application/json';
            fileInput.style.display = 'none';
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Add a small delay to ensure Cytoscape is fully ready
                    setTimeout(() => {
                        try {
                            const importData = JSON.parse(e.target.result);
                            
                            // Validate JSON structure
                            if (!importData.cards || !Array.isArray(importData.cards)) {
                                throw new Error('Ogiltig JSON-fil: Saknar kort-data');
                            }
                            
                            // Safety check: Ensure Cytoscape is fully initialized
                            if (!cy || !cy.add || typeof cy.add !== 'function') {
                                alert('‚ö†Ô∏è Systemet laddas fortfarande. V√§nta 2-3 sekunder och f√∂rs√∂k igen.');
                                return;
                            }
                        
                        // Always add to existing cards (no replace option)
                        
                        // Add imported cards
                        let importedCount = 0;
                        
                        // Generate import date in YYMMDD format
                        const now = new Date();
                        const importDate = now.getFullYear().toString().substr(-2) + 
                                          String(now.getMonth() + 1).padStart(2, '0') + 
                                          String(now.getDate()).padStart(2, '0');
                        
                        // Create ID mapping for edges
                        const idMapping = new Map();
                        
                        console.log(`üöÄ Starting optimized import of ${importData.cards.length} cards...`);
                        
                        // Use batch mode for optimal performance
                        cy.batch(() => {
                            importData.cards.forEach(cardData => {
                            // Save original ID for origin tag
                            const originalId = cardData.id;
                            
                            // Always generate new unique ID for all imported cards
                            const timestamp = Date.now();
                            const random = Math.random().toString(36).substr(2, 9);
                            const newId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}-${random}`;
                            
                            cardData.id = newId;
                            
                            // Store ID mapping for edge updates
                            idMapping.set(originalId, newId);
                            
                            // Create hidden tags for import tracking
                            const hiddenTags = cardData.hidden_tags || [];
                            hiddenTags.push(`origin_${originalId}`);
                            hiddenTags.push(`import_${importDate}`);
                            
                            const newNode = cy.add({
                                data: {
                                    id: cardData.id,
                                    title: cardData.title || '',
                                    text: cardData.text || '',
                                    tags: cardData.tags || [],
                                    hidden_tags: hiddenTags,
                                    searchMatch: false,
                                    isManualCard: cardData.isManualCard || false,
                                    cardColor: cardData.cardColor || null,
                                    // Restore metadata
                                    export_timestamp: cardData.export_timestamp || null,
                                    export_session: cardData.export_session || null,
                                    export_source: cardData.export_source || null,
                                    source_file: cardData.source_file || null,
                                    page_number: cardData.page_number || null,
                                    matched_terms: cardData.matched_terms || null,
                                    card_index: cardData.card_index || null,
                                    // Annotation-specific data
                                    isAnnotation: cardData.isAnnotation || false,
                                    annotationType: cardData.annotationType || null,
                                    customWidth: cardData.customWidth || null,
                                    customHeight: cardData.customHeight || null,
                                    customZIndex: cardData.customZIndex || null,
                                    customFontSize: cardData.customFontSize || null,
                                    // Store annotation color for restoration
                                    annotationColor: cardData.annotationColor || null,
                                    // Store shape data for geometric figures
                                    shape: cardData.shape || null,
                                    // IMAGE DATA - Import compatibility for v2.0
                                    type: cardData.type || null,
                                    imageData: cardData.imageData || null,
                                    annotation: cardData.annotation || null,
                                    searchableText: cardData.searchableText || null,
                                    originalFileName: cardData.originalFileName || null
                                },
                                position: cardData.position || { x: Math.random() * 800 + 100, y: Math.random() * 600 + 100 }
                            });
                            
                            // Restore pinned state
                            if (cardData.pinned) {
                                newNode.addClass('pinned');
                            }
                            
                            // Restore annotation shape class and text label
                            if (cardData.isAnnotation && cardData.annotationType === 'shape') {
                                newNode.addClass('annotation-shape');
                                
                                // Make sure text shows as label for annotations
                                if (cardData.text) {
                                    newNode.style('label', cardData.text);
                                }
                            }
                            
                            // Restore custom size, layer, color and font size for annotation nodes
                            if (cardData.isAnnotation && (cardData.customWidth || cardData.customHeight || cardData.customZIndex !== null || cardData.annotationColor || cardData.customFontSize)) {
                                const width = cardData.customWidth || 120;
                                const height = cardData.customHeight || 120;
                                const zIndex = cardData.customZIndex !== null ? cardData.customZIndex : -1;
                                
                                // Convert internal z-index to Cytoscape z-index
                                let cyZIndex = 1; // default
                                if (zIndex === -1) cyZIndex = 0; // Background
                                if (zIndex === 0) cyZIndex = 1;  // Normal
                                if (zIndex === 1) cyZIndex = 2;  // Foreground
                                
                                const styleUpdate = {
                                    'width': width + 'px',
                                    'height': height + 'px',
                                    'z-index': cyZIndex
                                };
                                
                                // Restore annotation color if saved
                                if (cardData.annotationColor && cardData.annotationColor !== 'rgb(255,255,255)') {
                                    styleUpdate['background-color'] = cardData.annotationColor;
                                }
                                
                                // Restore custom font size if saved
                                if (cardData.customFontSize) {
                                    styleUpdate['font-size'] = cardData.customFontSize + 'px';
                                }
                                
                                newNode.style(styleUpdate);
                            }
                            
                            // Restore card color
                            if (cardData.cardColor) {
                                newNode.style('background-color', getCardColorValue(cardData.cardColor, getCurrentTheme()));
                            }
                            
                            // IMAGE NODE RESTORATION - Import compatibility
                            if (cardData.type === 'image' && cardData.imageData) {
                                console.log('üñºÔ∏è Importing image node:', cardData.originalFileName);
                                
                                // Apply image-specific styling
                                newNode.style({
                                    'background-image': cardData.imageData,
                                    'background-fit': 'cover',
                                    'width': '300px'
                                });
                                
                                // Update title to show annotation indicator if present
                                // Don't show filename in title, keep title empty for clean image display
                                newNode.data('title', '');
                                
                                const filename = cardData.originalFileName || 'Imported Image';
                                const hasAnnotation = (cardData.annotation || '').length > 0;
                                console.log(`‚úÖ Imported image: ${filename} (${hasAnnotation ? 'with annotation' : 'no annotation'})`);
                            }
                            
                            newNode.grabify();
                            importedCount++;
                        });
                        }); // End batch operation for cards
                        
                        console.log(`‚úÖ Batch card import completed: ${importedCount} cards processed`);
                        
                        // Import edges/arrows if they exist  
                        let importedEdges = 0;
                        if (importData.edges && Array.isArray(importData.edges)) {
                            console.log(`üîó Starting batch import of ${importData.edges.length} edges...`);
                            cy.batch(() => {
                                importData.edges.forEach(edgeData => {
                                // Map old IDs to new IDs
                                const newSourceId = idMapping.get(edgeData.source);
                                const newTargetId = idMapping.get(edgeData.target);
                                
                                // Only create edge if both source and target exist
                                if (newSourceId && newTargetId) {
                                    // Generate new edge ID
                                    const timestamp = Date.now();
                                    const random = Math.random().toString(36).substr(2, 9);
                                    const newEdgeId = `edge-${timestamp}-${random}`;
                                    
                                    const newEdge = cy.add({
                                        data: {
                                            id: newEdgeId,
                                            source: newSourceId,
                                            target: newTargetId,
                                            isAnnotation: edgeData.isAnnotation || false,
                                            annotationType: edgeData.annotationType || null,
                                            customColor: edgeData.customColor || null
                                        }
                                    });
                                
                                    // Apply annotation classes for styling
                                    if (edgeData.isAnnotation) {
                                        newEdge.addClass('annotation-connection');
                                    }
                                    
                                    // Restore all visual styling
                                    if (edgeData.style) {
                                        newEdge.style(edgeData.style);
                                    }
                                    
                                    importedEdges++;
                                } else {
                                    console.warn('Skipping edge - source or target not found:', edgeData.source, '->', edgeData.target);
                                }
                            });
                            }); // End batch operation for edges
                            console.log(`‚úÖ Batch edge import completed: ${importedEdges} edges processed`);
                        }
                        
                        // Restore global arrow visibility state
                        if (importData.arrowsHidden !== undefined) {
                            window.arrowsHidden = importData.arrowsHidden;
                            if (window.arrowsHidden) {
                                // Apply hidden state to all edges
                                cy.edges().style('opacity', 0);
                            }
                        }
                        
                        // Card IDs are now timestamp-based, no counter needed
                        
                        // Restore viewport if available
                        if (importData.viewport) {
                            setTimeout(() => {
                                cy.zoom(importData.viewport.zoom);
                                cy.pan(importData.viewport.pan);
                            }, 100);
                        }
                        
                        // Show success message
                        let message = `üìÅ JSON-import lyckades: ${importedCount} kort`;
                        if (importedEdges > 0) {
                            message += `, ${importedEdges} pilar`;
                        }
                        message += ` importerade (alla fick nya ID:n + g√∂mda taggar)`;
                        if (importData.metadata) {
                            message += `\nExportdatum: ${new Date(importData.metadata.exportDate).toLocaleString('sv-SE')}`;
                        }
                        
                        const searchInfo = document.getElementById('searchInfo');
                        searchInfo.textContent = message;
                        searchInfo.classList.add('visible');
                        setTimeout(() => {
                            searchInfo.classList.remove('visible');
                        }, 4000);
                        
                        console.log(`JSON import completed: ${importedCount} cards and ${importedEdges} edges imported`, importData.metadata);
                        
                        } catch (error) {
                            console.error('Error importing JSON:', error);
                            alert('Fel vid JSON-import: ' + error.message + '\n\nKontrollera att filen √§r en giltig Spatial Notes JSON-export.');
                        }
                    }, 100); // End of setTimeout
                };
                
                reader.readAsText(file);
            });
            
            // Trigger file picker
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
        }
        
        // Import cards from PDF-Extractor localStorage
        function importFromExtractor() {
            try {
                // Debug: Show all localStorage keys
                console.log('All localStorage keys:', Object.keys(localStorage));
                
                // Try different possible keys that PDF-extractor might use
                // PDF-Extractor uses the same localStorage key as spatial notes
                const extractorData = localStorage.getItem('spatial-notes-board');
                console.log('Checking for PDF-Extractor data in spatial-notes-board key');
                
                if (!extractorData) {
                    // Show debug info
                    const allKeys = Object.keys(localStorage);
                    alert(`Ingen data fr√•n PDF-Extractor hittades!\n\nDebug info:\nLocalStorage nycklar: ${allKeys.join(', ')}\n\nK√∂r PDF-extractor f√∂rst och exportera kort till Spatial Notes.`);
                    return;
                }
                
                const importedCards = JSON.parse(extractorData);
                
                if (!Array.isArray(importedCards) || importedCards.length === 0) {
                    alert('PDF-Extractor data √§r tom eller ogiltig.');
                    return;
                }
                
                // Check if we have existing cards in spatial notes
                const hasExistingCards = cy.nodes().length > 0;
                const existingIds = new Set(cy.nodes().map(n => n.id()));
                
                // Filter out cards that already exist in spatial notes
                const newCards = importedCards.filter(card => !existingIds.has(card.id));
                
                if (newCards.length === 0) {
                    alert('Inga nya kort att importera fr√•n PDF-Extractor. Alla kort finns redan.');
                    return;
                }
                
                let replaceExisting = false;
                
                if (hasExistingCards) {
                    replaceExisting = confirm(
                        `PDF-Extractor har ${newCards.length} NYA kort att importera.\n` +
                        `Du har ${cy.nodes().length} befintliga kort.\n\n` +
                        `Klicka OK f√∂r att ERS√ÑTTA alla kort\n` +
                        `Klicka Avbryt f√∂r att L√ÑGGA TILL endast de nya korten`
                    );
                }
                
                // Use only new cards if not replacing
                if (!replaceExisting) {
                    importedCards = newCards;
                }
                
                // Clear existing cards if replacing
                if (replaceExisting) {
                    cy.nodes().remove();
                }
                
                // Add imported cards with smart positioning
                let importedCount = 0;
                let duplicateCount = 0;
                
                importedCards.forEach((cardData, index) => {
                    // Check for duplicate IDs if not replacing
                    if (!replaceExisting && cy.getElementById(cardData.id).length > 0) {
                        // Generate new unique ID for duplicate
                        cardData.id = cardData.id + '_imported_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                        duplicateCount++;
                    }
                    
                    // Smart positioning: arrange in grid if no position provided
                    let position = cardData.position;
                    if (!position || (position.x === 0 && position.y === 0)) {
                        const cols = Math.ceil(Math.sqrt(importedCards.length));
                        const col = index % cols;
                        const row = Math.floor(index / cols);
                        position = {
                            x: 200 + col * 320,
                            y: 200 + row * 200
                        };
                    }
                    
                    const newNode = cy.add({
                        data: {
                            id: cardData.id,
                            title: cardData.title || '',
                            text: cardData.text || '',
                            tags: cardData.tags || [],
                            hidden_tags: cardData.hidden_tags || [],
                            searchMatch: false,
                            // Preserve PDF-extractor metadata
                            export_timestamp: cardData.export_timestamp || null,
                            export_session: cardData.export_session || null,
                            export_source: cardData.export_source || 'pdf_extractor',
                            source_file: cardData.source_file || null,
                            page_number: cardData.page_number || null,
                            matched_terms: cardData.matched_terms || null,
                            card_index: cardData.card_index || null
                        },
                        position: position
                    });
                    
                    newNode.grabify();
                    importedCount++;
                });
                
                // Card IDs are now timestamp-based, no counter needed
                
                // Clear the PDF-extractor data so it doesn't import again
                // localStorage.removeItem('pdf-extractor-export'); // Don't clear, let user decide
                
                // Show success message
                let message = `üì• PDF-Extractor import lyckades: ${importedCount} kort importerade`;
                if (duplicateCount > 0) {
                    message += ` (${duplicateCount} dubbletter fick nya ID:n)`;
                }
                
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = message;
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 4000);
                
                console.log(`PDF-Extractor import completed: ${importedCount} cards imported`);
                
            } catch (error) {
                console.error('Error importing from PDF-Extractor:', error);
                alert('Fel vid import fr√•n PDF-Extractor: ' + error.message);
            }
        }
        
        // Clear board completely
        function clusterSelectedCards() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInCluster();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo
            saveState();
            
            // Get center position (mouse or screen center)
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Small cluster radius
            const radius = 50;
            
            // Arrange in tight circle
            selectedNodes.forEach((node, index) => {
                const angle = (index / selectedNodes.length) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                node.animate({
                    position: { x: x, y: y }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Q: Klustrade ${selectedNodes.length} kort`);
        }

        function executeCommand(command) {
            const selectedNodes = cy.$('node:selected');
            
            switch(command) {
                case 'H':
                    arrangeSelectedInRow();
                    break;
                case 'G+V':
                    arrangeSelectedGridVerticalColumns();
                    break;
                case 'G+H':
                    arrangeSelectedGridHorizontalPacked();
                    break;
                case 'G+T':
                    arrangeSelectedGridTopAligned();
                    break;
                case 'Q':
                    clusterSelectedCards();
                    break;
                case 'C':
                    copySelectedCards();
                    break;
                case 'T':
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        const fakeEvent = {
                            clientX: window.innerWidth / 2,
                            clientY: window.innerHeight / 2
                        };
                        showColorPicker(fakeEvent, selectedNodes);
                    }
                    break;
                case 'V':
                    arrangeSelectedInColumn();
                    break;
                case 'Stack':
                case 'QQ':
                case 'Alt+S':
                    stackSelectedCards();
                    break;
                case 'Pin':
                    selectedNodes.forEach(node => {
                        pinCard(node);
                    });
                    break;
                case 'Unpin':
                    selectedNodes.forEach(node => {
                        unpinCard(node);
                    });
                    break;
                case 'Delete':
                    deleteSelectedCards();
                    break;
                case 'Ctrl+Z':
                    // Trigger undo
                    if (undoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        redoStack.push(currentState);
                        
                        const previousState = undoStack.pop();
                        restoreState(previousState);
                    }
                    break;
                case 'Ctrl+Y':
                    // Trigger redo
                    if (redoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        undoStack.push(currentState);
                        
                        const nextState = redoStack.pop();
                        restoreState(nextState);
                    }
                    break;
                case 'Ctrl+A':
                    cy.nodes().not('.pinned').select();
                    break;
                case 'Ctrl+S':
                    saveBoard();
                    break;
            }
        }

        function debugDumpPositions() {
            console.log('\n=== KORT POSITIONER DEBUG ===');
            cy.nodes().forEach(node => {
                const pos = node.position();
                const title = node.data('title') || 'Untitled';
                console.log(`${node.id()}: x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)} - "${title}"`);
            });
            console.log('=== SLUT DEBUG ===\n');
            
            const searchInfo = document.getElementById('searchInfo');
            if (searchInfo) {
                searchInfo.textContent = 'Kort-positioner dumpade till console (F12)';
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
            }
        }

        function toggleDarkTheme() {
            const body = document.body;
            const themeBtn = document.getElementById('themeBtn');
            
            let currentTheme = 'light';
            if (body.classList.contains('dark-theme')) {
                currentTheme = 'dark';
            } else if (body.classList.contains('sepia-theme')) {
                currentTheme = 'sepia';
            }
            
            // Cycle through themes: light -> dark -> sepia -> light
            if (currentTheme === 'light') {
                body.classList.remove('sepia-theme');
                body.classList.add('dark-theme');
                themeBtn.innerHTML = 'üìú Sepia Tema';
                localStorage.setItem('theme', 'dark');
                applyCardTheme('dark');
            } else if (currentTheme === 'dark') {
                body.classList.remove('dark-theme');
                body.classList.add('sepia-theme');
                themeBtn.innerHTML = '‚òÄÔ∏è Ljust Tema';
                localStorage.setItem('theme', 'sepia');
                applyCardTheme('sepia');
            } else {
                body.classList.remove('sepia-theme');
                themeBtn.innerHTML = 'üåô M√∂rkt Tema';
                localStorage.setItem('theme', 'light');
                applyCardTheme('light');
            }
        }
        
        // Get card color value based on theme
        function getCardColorValue(colorId, theme) {
            const colors = {
                light: {
                    1: '#d4f2d4', // Gr√∂n
                    2: '#ffe4b3', // Orange
                    3: '#ffc1cc', // R√∂d
                    4: '#fff7b3', // Gul
                    5: '#f3e5f5', // Lila
                    6: '#c7e7ff', // Bl√•
                    7: '#e0e0e0', // Gr√•
                    8: '#ffffff'  // Vit
                },
                dark: {
                    1: '#3d5a3d', // M√∂rk Gr√∂n
                    2: '#5a4d3a', // M√∂rk Orange
                    3: '#5a3c3a', // M√∂rk R√∂d
                    4: '#5a5a3a', // M√∂rk Gul
                    5: '#4a3d5a', // M√∂rk Lila
                    6: '#2e4a6f', // M√∂rk Bl√•
                    7: '#555555', // M√∂rk Gr√•
                    8: '#8a8a8a'  // Ljusgr√• (vit blir f√∂r ljus i dark theme)
                },
                sepia: {
                    1: '#ded6c7', // Sepia Gr√∂n
                    2: '#e6d6c2', // Sepia Orange
                    3: '#ead6c7', // Sepia R√∂d
                    4: '#ebe2d6', // Sepia Gul
                    5: '#e2d6c7', // Sepia Lila
                    6: '#d6c7b3', // Sepia Bl√•
                    7: '#c0b8a8', // Sepia Gr√•
                    8: '#f5f2e8'  // Sepia Vit
                }
            };
            
            // Extract number from colorId (card-color-1 -> 1)
            const colorNumber = colorId.toString().replace('card-color-', '');
            
            return colors[theme] && colors[theme][colorNumber] ? colors[theme][colorNumber] : null;
        }

        function applyCardTheme(theme) {
            if (cy) {
                if (theme === 'dark') {
                    // Dark theme styling
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    // Color priority: if card has color, use it regardless of theme
                                    return getCardColorValue(cardColor, 'dark');
                                }
                                return '#2a2a2a';
                            },
                            'color': '#f0f0f0',
                            'border-color': '#555'
                        })
                        .selector('node:selected').style({
                            'border-color': '#66b3ff',  // Bright blue for visibility
                            'border-width': 5,
                            'box-shadow': '0 0 25px rgba(102, 179, 255, 0.8)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#4a3c00',  // Dark yellow background
                            'border-color': '#ffcc00',     // Bright yellow border
                            'border-width': 3,
                            'box-shadow': '0 0 15px rgba(255, 204, 0, 0.6)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#4caf50',  // Bright green
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(76, 175, 80, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                } else if (theme === 'sepia') {
                    // Sepia theme styling
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    return getCardColorValue(cardColor, 'sepia');
                                }
                                return '#f0e6d2';
                            },
                            'color': '#5d4e37',
                            'border-color': '#c8a882'
                        })
                        .selector('node:selected').style({
                            'border-color': '#8b7556',  // Dark brown for sepia
                            'border-width': 4,
                            'box-shadow': '0 0 20px rgba(139, 117, 86, 0.7)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#f4e8d0',  // Light sepia highlight
                            'border-color': '#d2691e',     // Chocolate border
                            'border-width': 2,
                            'box-shadow': '0 0 10px rgba(210, 105, 30, 0.5)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#8fbc8f',  // Dark sea green for sepia
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(143, 188, 143, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                } else {
                    // Light theme styling (default)
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    return getCardColorValue(cardColor, 'light');
                                }
                                return '#ffffff';
                            },
                            'color': '#333333',
                            'border-color': '#ddd'
                        })
                        .selector('node:selected').style({
                            'border-color': '#1565c0',
                            'border-width': 4,
                            'box-shadow': '0 0 20px rgba(21, 101, 192, 0.7)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#fff9c4',
                            'border-color': '#f57f17',
                            'border-width': 2,
                            'box-shadow': '0 0 10px rgba(245, 127, 23, 0.4)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#2e7d32',
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(46, 125, 50, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                }
            }
        }
        
        // Load saved theme on page load
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme') || localStorage.getItem('darkTheme'); // Backward compatibility
            const themeBtn = document.getElementById('themeBtn');
            
            // Handle backward compatibility
            let theme = 'light';
            if (savedTheme === 'dark' || savedTheme === 'true') {
                theme = 'dark';
            } else if (savedTheme === 'sepia') {
                theme = 'sepia';
            }
            
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
                if (themeBtn) {
                    themeBtn.innerHTML = 'üìú Sepia Tema';
                }
                setTimeout(() => applyCardTheme('dark'), 100);
            } else if (theme === 'sepia') {
                document.body.classList.add('sepia-theme');
                if (themeBtn) {
                    themeBtn.innerHTML = '‚òÄÔ∏è Ljust Tema';
                }
                setTimeout(() => applyCardTheme('sepia'), 100);
            } else {
                if (themeBtn) {
                    themeBtn.innerHTML = 'üåô M√∂rkt Tema';
                }
                setTimeout(() => applyCardTheme('light'), 100);
            }
        }

        function clearBoard() {
            if (confirm('√Ñr du s√§ker p√• att du vill rensa hela br√§dan och localStorage?\n\nDetta kommer att:\n‚Ä¢ Ta bort alla kort fr√•n br√§dan\n‚Ä¢ Rensa sparad data i localStorage\n‚Ä¢ √Öterst√§lla till tom br√§da\n\nDenna √•tg√§rd kan inte √•ngras!')) {
                // Clear memoization cache
                heightCache.clear();
                // Clear all nodes from the board
                cy.nodes().remove();
                
                // Clear localStorage
                localStorage.removeItem('spatial-notes-board');
                
                // Card IDs are now timestamp-based, no counter to reset
                
                // Show confirmation
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = 'Br√§da och localStorage rensade! ‚úÖ';
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
                
                console.log('Board and localStorage cleared completely');
            }
        }
        
        // Toggle metadata view for development and analysis
        let showMetadata = false;
        function toggleMetadataView() {
            showMetadata = !showMetadata;
            const btn = document.getElementById('metadataBtn');
            
            if (showMetadata) {
                btn.textContent = 'üîç D√∂lj Metadata';
                btn.style.backgroundColor = '#ff9800';
                
                // Show metadata in console and as overlays
                console.log('=== SPATIAL NOTES METADATA ===');
                cy.nodes().forEach(node => {
                    const metadata = {
                        id: node.id(),
                        export_timestamp: node.data('export_timestamp'),
                        export_session: node.data('export_session'),
                        export_source: node.data('export_source'),
                        source_file: node.data('source_file'),
                        page_number: node.data('page_number'),
                        matched_terms: node.data('matched_terms'),
                        card_index: node.data('card_index')
                    };
                    console.log(`${node.id()}:`, metadata);
                });
                
                // Add metadata styling
                cy.style().selector('node').style({
                    'border-color': function(node) {
                        const session = node.data('export_session');
                        if (!session) return '#ddd';
                        // Color-code by export session
                        const hash = session.split('').reduce((a, b) => {
                            a = ((a << 5) - a) + b.charCodeAt(0);
                            return a & a;
                        }, 0);
                        const color = `hsl(${Math.abs(hash) % 360}, 70%, 60%)`;
                        return color;
                    },
                    'border-width': 3
                }).update();
                
                // Show stats
                const stats = analyzeMetadata();
                alert(`Metadata aktiverad!\n\n${stats}\n\nKolla konsolen f√∂r detaljer.`);
                
            } else {
                btn.textContent = 'üîç Metadata';
                btn.style.backgroundColor = '#007acc';
                
                // Reset styling
                cy.style().selector('node').style({
                    'border-color': '#ddd',
                    'border-width': 2
                }).update();
                
                console.log('Metadata view disabled');
            }
        }
        
        function analyzeMetadata() {
            const nodes = cy.nodes();
            const sessions = new Set();
            const sources = new Set();
            let pdfCards = 0;
            let manualCards = 0;
            
            nodes.forEach(node => {
                const session = node.data('export_session');
                const source = node.data('export_source');
                
                if (session) sessions.add(session);
                if (source) sources.add(source);
                
                if (source === 'pdf_extractor') pdfCards++;
                else manualCards++;
            });
            
            return `Totalt: ${nodes.length} kort\n` +
                   `PDF-kort: ${pdfCards}\n` +
                   `Manuella kort: ${manualCards}\n` +
                   `Export-sessioner: ${sessions.size}\n` +
                   `K√§llor: ${sources.size}`;
        }
        
        // Add new card
        function addNewCard() {
            // Clear any existing edit dialogs first
            clearAllEditDialogs();
            
            // Create overlay for multiline text input
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Nytt kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="newCardText" placeholder="Skriv text h√§r... (radbrytningar bevaras)"
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;"></textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="newCardTags" placeholder="tech, psychology, design..."
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelCard" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveCard" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara kort</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea
            const textarea = document.getElementById('newCardText');
            textarea.focus();
            
            // Handle save
            document.getElementById('saveCard').onclick = function() {
                const text = textarea.value.trim();
                if (!text) {
                    alert('Text kr√§vs f√∂r att skapa kort');
                    return;
                }
                
                const tagsInput = document.getElementById('newCardTags').value || '';
                const tags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                const newId = generateCardId();
                
                // Position card based on device type
                let x, y;
                const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window);
                
                if (isMobile) {
                    // Mobile: center of screen
                    const extent = cy.extent();
                    x = (extent.x1 + extent.x2) / 2;
                    y = (extent.y1 + extent.y2) / 2;
                } else {
                    // Desktop: at mouse position (or fallback to center)
                    const arrangePos = getArrangementPosition();
                    x = arrangePos.x;
                    y = arrangePos.y;
                }
                
                const newNode = cy.add({
                    data: {
                        id: newId,
                        title: null, // Explicitly null to avoid any title processing
                        text: text, // Keep line breaks as-is
                        tags: tags,
                        searchMatch: false,
                        isManualCard: true // Flag to identify manually created cards
                    },
                    position: { x: x, y: y }
                });
                
                newNode.grabify();
                
                // Force refresh of node styling
                cy.style().update();
                
                document.body.removeChild(overlay);
            };
            
            // Handle cancel
            document.getElementById('cancelCard').onclick = function() {
                document.body.removeChild(overlay);
            };
            
            // Handle Enter to save (Ctrl+Enter or Shift+Enter for new lines)
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    document.getElementById('saveCard').click();
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Regular Enter and Shift+Enter allow normal newline behavior
            });
        }
        
        // Zoom out to center (mobile function)
        function zoomOutToCenter() {
            cy.fit(null, 50); // Fit all nodes with 50px padding
            cy.center(); // Center the view
        }
        
        // Helper function to create node from card data (handles both regular and image nodes)
        function createNodeFromCardData(cardData, newId, position) {
            const nodeData = {
                id: newId,
                title: cardData.title,
                text: cardData.text,
                tags: cardData.tags,
                hidden_tags: cardData.hidden_tags || [],
                searchMatch: false,
                // Copy metadata
                export_timestamp: cardData.export_timestamp,
                export_session: cardData.export_session,
                export_source: cardData.export_source,
                source_file: cardData.source_file,
                page_number: cardData.page_number,
                matched_terms: cardData.matched_terms,
                card_index: cardData.card_index,
                // Copy metadata
                copyOf: cardData.copyOf,
                isCopy: cardData.isCopy,
                copyTimestamp: cardData.copyTimestamp,
                // IMAGE DATA - Essential for image nodes
                type: cardData.type,
                imageData: cardData.imageData,
                imageWidth: cardData.imageWidth,        // Store original dimensions
                imageHeight: cardData.imageHeight,      // Store original dimensions
                calculatedHeight: cardData.calculatedHeight, // Store pre-calculated height
                annotation: cardData.annotation,
                searchableText: cardData.searchableText,
                originalFileName: cardData.originalFileName
            };

            const newNode = cy.add({
                data: nodeData,
                position: position
            });

            // Apply image-specific styling if it's an image node
            if (cardData.type === 'image' && cardData.imageData) {
                newNode.style({
                    'background-image': cardData.imageData,
                    'background-fit': 'cover',
                    'width': '300px'
                });
                console.log(`üì∑ Created image copy: ${cardData.originalFileName}`);
            }

            // Apply auto-gray coloring for #done tags
            applyAutoDoneColoring(newNode);

            return newNode;
        }

        // Copy selected cards
        function copySelectedCards() {
            const selectedNodes = cy.nodes(':selected');
            if (selectedNodes.length === 0) {
                alert('Inga kort markerade f√∂r kopiering');
                return;
            }
            
            // Save state for undo before copying (copies will be created when arranged)
            saveState();
            
            // Generate timestamp for copy tagging
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/[-T:]/g, '').slice(0, 13); // YYYYMMDD_HHmm format
            
            copiedCards = [];
            
            selectedNodes.forEach((node, index) => {
                const originalData = {
                    title: node.data('title') || '',
                    text: node.data('text') || '',
                    tags: [...(node.data('tags') || [])], // Clone array
                    hidden_tags: [...(node.data('hidden_tags') || [])], // Clone hidden tags array
                    // Copy all metadata too
                    export_timestamp: node.data('export_timestamp'),
                    export_session: node.data('export_session'),
                    export_source: node.data('export_source'),
                    source_file: node.data('source_file'),
                    page_number: node.data('page_number'),
                    matched_terms: node.data('matched_terms'),
                    card_index: node.data('card_index'),
                    // IMAGE NODE DATA - Essential for copying images
                    type: node.data('type'), // 'image' for image nodes
                    imageData: node.data('imageData'), // Base64 image data
                    annotation: node.data('annotation'), // Image annotation text
                    searchableText: node.data('searchableText'), // Searchable text
                    originalFileName: node.data('originalFileName') // Original filename
                };
                
                // Add copy metadata to hidden tags (searchable but not visible)
                const copyTag = `copy_${timestamp}_${index + 1}`;
                originalData.hidden_tags.push(copyTag);
                originalData.copyOf = node.id();
                originalData.isCopy = true;
                originalData.copyTimestamp = now.toISOString();
                
                copiedCards.push(originalData);
            });
            
            console.log(`Copied ${copiedCards.length} cards with timestamp ${timestamp}`);
        }
        
        // Arrange copied cards in row at mouse position
        function arrangeCopiedCardsInRow() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Now arrange them in a row (H-logic: 20% spacing = 60px)
            const spacing = 60; // 20% spacing as per spec
            let totalRequiredWidth = 0;
            newNodes.forEach((node, index) => {
                const cardWidth = getCardWidth(node);
                totalRequiredWidth += cardWidth;
                if (index < newNodes.length - 1) {
                    totalRequiredWidth += spacing;
                }
            });
            
            let currentX = centerX - (totalRequiredWidth / 2);
            newNodes.forEach(node => {
                const cardWidth = getCardWidth(node);
                const cardHeight = getMeasuredTextHeight(node);
                
                // Position with top-aligned positioning (same as original)
                const cardCenterX = currentX + (cardWidth / 2);
                const cardCenterY = centerY + (cardHeight / 2); // Top-align: center Y based on card's height
                
                node.position({ x: cardCenterX, y: cardCenterY });
                currentX += cardWidth + spacing;
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in row`);
        }
        
        // Arrange copied cards in column at mouse position
        function arrangeCopiedCardsInColumn() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Now arrange them in a column (V-logic: 20% spacing = 60px)
            const spacing = 60; // 20% spacing as per spec
            let totalRequiredHeight = 0;
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < newNodes.length - 1) {
                    totalRequiredHeight += spacing;
                }
            });
            
            let currentY = centerY - (totalRequiredHeight / 2);
            newNodes.forEach(node => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                node.position({ x: centerX, y: cardCenterY });
                currentY += cardHeight + spacing;
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in column`);
        }
        
        // Arrange copied cards in grid at mouse position
        function arrangeCopiedCardsInGrid() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Calculate grid dimensions
            const nodeCount = copiedCards.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in grid
            const cardWidth = 300;
            const cardHeight = 200;
            const horizontalSpacing = 350;
            const verticalSpacing = 250;
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const gridHeight = (rows - 1) * verticalSpacing;
            
            const startX = screenCenterX - (gridWidth / 2);
            const startY = screenCenterY - (gridHeight / 2);
            
            newNodes.forEach((node, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                const x = startX + (col * horizontalSpacing);
                const y = startY + (row * verticalSpacing);
                
                node.position({ x: x, y: y });
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in ${rows}√ó${cols} grid`);
        }
        
        // G+V: Copy cards in vertical columns layout
        function arrangeCopiedCardsGridVerticalColumns() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // G+V: Column-focused arrangement with max gap between bottom-edge to top-edge (same logic as original)
            const nodeCount = newNodes.length;
            const maxCols = 6; // Max 6 columns
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const cardsPerCol = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 350; // Gap between columns
            const maxVerticalGap = 80; // Max gap from bottom-edge of upper card to top-edge of lower card
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Top-aligned columns - all start from same Y position (like G+H but vertical)
            const topLineY = screenCenterY; // All columns start from same top line
            
            // Arrange column by column (instead of row by row)
            for (let col = 0; col < cols; col++) {
                const colStartIndex = col * cardsPerCol;
                const colEndIndex = Math.min(colStartIndex + cardsPerCol, nodeCount);
                const cardsInThisCol = colEndIndex - colStartIndex;
                
                if (cardsInThisCol === 0) continue;
                
                const colX = startX + col * horizontalSpacing;
                
                // Start each column from the same top line
                let currentTopY = topLineY;
                
                // Place cards in this column with gap between bottom and top edges
                for (let cardIndex = 0; cardIndex < cardsInThisCol; cardIndex++) {
                    const nodeIndex = colStartIndex + cardIndex;
                    const node = newNodes[nodeIndex];
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Card center is at currentTopY + half height
                    const cardCenterY = currentTopY + (cardHeight / 2);
                    
                    node.position({ x: colX, y: cardCenterY });
                    
                    // Move to next position: current card bottom + gap
                    currentTopY += cardHeight + maxVerticalGap;
                }
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+V: Created ${newNodes.length} copied cards in ${cols} top-aligned columns, 80px vertikalt, 350px horisontellt`);
        }
        
        // G+H: Copy cards in horizontal packed layout
        function arrangeCopiedCardsGridHorizontalPacked() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in horizontal packed rows (exact same logic as original)
            const nodeCount = newNodes.length;
            const maxCols = 6;
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const rows = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 360; // 60px gap between cards (360 - 300 = 60)
            const rowPadding = 95; // Adjusted to get actual 60px visual spacing
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // First pass: calculate the height of each row
            const rowHeights = [];
            for (let row = 0; row < rows; row++) {
                let maxRowHeight = 0;
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        maxRowHeight = Math.max(maxRowHeight, cardHeight);
                    }
                }
                rowHeights.push(maxRowHeight);
            }
            
            // Calculate total height and start position
            const totalHeight = rowHeights.reduce((sum, height) => sum + height, 0) + (rows - 1) * rowPadding;
            let currentY = screenCenterY; // Top of grid at mouse cursor (same as move G+H)
            
            // Second pass: position cards row by row with tight packing
            for (let row = 0; row < rows; row++) {
                const rowHeight = rowHeights[row];
                
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const newX = startX + col * horizontalSpacing;
                        
                        // Position card at top of its row space
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2); // Top-aligned within row
                        
                        node.position({ x: newX, y: cardCenterY });
                    }
                }
                
                currentY += rowHeight + rowPadding; // Move to next row
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+H: Created ${newNodes.length} copied cards in ${rows} packed rows`);
        }
        
        // Form dialog for structured card creation
        function showFormDialog(x, y) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create form dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 400px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">Skapa nytt kort</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Titel (valfritt):</label>
                    <input type="text" id="formTitle" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Text:</label>
                    <textarea id="formText" rows="4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Tags (kommaseparerade):</label>
                    <input type="text" id="formTags" placeholder="tech, ai, design" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">F√§rg (valfritt):</label>
                    <div id="formColorPicker" style="display: flex; gap: 8px; align-items: center;">
                        <div class="form-color-dot" data-color="" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer; background: white; position: relative;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #999;">√ó</div>
                        </div>
                        <div class="form-color-dot card-color-1" data-color="card-color-1" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-2" data-color="card-color-2" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-3" data-color="card-color-3" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-4" data-color="card-color-4" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-5" data-color="card-color-5" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                    </div>
                </div>
                <div style="text-align: right;">
                    <button id="formCancel" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="formSave" style="padding: 8px 16px; border: none; background: #007AFF; color: white; border-radius: 4px; cursor: pointer;">Skapa kort</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus first field
            document.getElementById('formTitle').focus();
            
            // Event handlers
            document.getElementById('formCancel').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('formSave').onclick = () => {
                createCardFromForm(x, y, selectedColor);
                document.body.removeChild(overlay);
            };
            
            // Color picker event handlers
            let selectedColor = '';
            document.querySelectorAll('.form-color-dot').forEach(dot => {
                dot.onclick = () => {
                    // Remove selection from all dots
                    document.querySelectorAll('.form-color-dot').forEach(d => {
                        d.style.boxShadow = '';
                        d.style.transform = '';
                    });
                    // Select this dot
                    dot.style.boxShadow = '0 0 0 3px #007AFF';
                    dot.style.transform = 'scale(1.1)';
                    selectedColor = dot.dataset.color;
                };
            });
            
            // Store selected color on overlay for access in createCardFromForm
            overlay.selectedColor = () => selectedColor;
            
            // ESC to cancel - must capture on document for focus issues
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
        }
        
        // Create card from form data
        function createCardFromForm(x, y, selectedColor = '') {
            const title = document.getElementById('formTitle').value.trim();
            const text = document.getElementById('formText').value.trim();
            const tagsInput = document.getElementById('formTags').value.trim();
            
            if (!text) return; // Need at least some text
            
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            const newId = generateCardId();
            const nodeData = {
                id: newId,
                title: title,
                text: text,
                tags: tags,
                searchMatch: false
            };
            
            // Add color if selected
            if (selectedColor) {
                nodeData.cardColor = selectedColor;
            }
            
            const newNode = cy.add({
                data: nodeData,
                position: { x: x, y: y }
            });
            
            // Apply color styling if selected
            if (selectedColor) {
                newNode.style('background-color', getCardColorValue(selectedColor, getCurrentTheme()));
            }
            
            newNode.grabify();
            console.log(`Created card via form: ${title || 'Untitled'} ${selectedColor ? 'with color ' + selectedColor : ''}`);
            
            // Apply temporal markings to newly created card
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
        }
        
        // Code syntax dialog for quick card creation
        function showCodeDialog(x, y) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create code dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 500px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #333;">Snabbformat</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    #Titel<br>Inneh√•ll h√§r (Shift+Enter f√∂r ny rad)<br>#tag1 #tag2
                    <br><strong>Enter</strong>=Spara, <strong>Esc</strong>=Avbryt
                </p>
                <textarea id="codeInput" placeholder="#Titel h√§r
Skriv ditt inneh√•ll h√§r...
#tag1 #tag2" 
                    style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
                           font-family: 'SF Mono', Consolas, monospace; font-size: 14px; resize: vertical;"></textarea>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            const textarea = document.getElementById('codeInput');
            textarea.focus();
            
            // Keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    createCardFromCode(x, y, textarea.value);
                    document.body.removeChild(overlay);
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Shift+Enter allows normal newline (no preventDefault)
            });
            
            // Click outside to cancel
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        // Parse code syntax and create card
        function createCardFromCode(x, y, input) {
            if (!input.trim()) return;
            
            const lines = input.trim().split('\n');
            let title = '';
            let text = '';
            let tags = [];
            
            let inContent = false;
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith('#') && !inContent) {
                    // First # line is title, rest are tags
                    if (!title) {
                        title = line.substring(1).trim();
                        inContent = true;
                    } else {
                        // Tags line - extract all #tag words
                        const tagMatches = line.match(/#\w+/g);
                        if (tagMatches) {
                            tags.push(...tagMatches.map(t => t.substring(1)));
                        }
                    }
                } else if (line.startsWith('#') && inContent) {
                    // Tags in content
                    const tagMatches = line.match(/#\w+/g);
                    if (tagMatches) {
                        tags.push(...tagMatches.map(t => t.substring(1)));
                    }
                } else {
                    // Content line
                    if (text) text += '\n';
                    text += line;
                    inContent = true;
                }
            }
            
            // If no title found, use first line of text
            if (!title && text) {
                const firstLine = text.split('\n')[0];
                if (firstLine.length < 50) {
                    title = firstLine;
                    text = text.substring(firstLine.length).trim();
                }
            }
            
            if (!text && !title) return; // Need something
            
            const newId = generateCardId();
            const newNode = cy.add({
                data: {
                    id: newId,
                    title: title,
                    text: text || title, // Use title as text if no content
                    tags: [...new Set(tags)], // Remove duplicates
                    searchMatch: false
                },
                position: { x: x, y: y }
            });
            
            newNode.grabify();
            console.log(`Created card via code syntax: ${title || 'Untitled'}`);
            
            // Apply temporal markings to newly created card
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
        }
        
        // G+T: Copy cards in top-aligned grid
        function arrangeCopiedCardsGridTopAligned() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in G+T layout (max 6 cols, 120px overlap, column-major ordering)
            const nodeCount = newNodes.length;
            const maxCols = 6; // Max 6 cards wide (same as original)
            const cols = Math.min(maxCols, nodeCount);
            const rows = Math.ceil(nodeCount / cols);
            
            const cardWidth = 300;
            const horizontalSpacing = cardWidth * 0.05; // 5% of card width = 15px
            const overlapSpacing = 120; // 120px between card tops (3x more to show titles)
            
            // Calculate grid size
            const gridWidth = (cols - 1) * (cardWidth + horizontalSpacing);
            const startX = screenCenterX - gridWidth / 2;
            
            // For top row alignment
            const topRowY = screenCenterY - 100; // Start a bit above center
            
            // Position cards column by column for proper overlapping (same as original)
            for (let col = 0; col < cols; col++) {
                const colX = startX + col * (cardWidth + horizontalSpacing);
                let currentY = topRowY;
                
                // Go through each row in this column
                for (let row = 0; row < rows; row++) {
                    const nodeIndex = row * cols + col; // Same ordering as original G+T
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2);
                        
                        node.position({ x: colX, y: cardCenterY });
                        currentY += overlapSpacing; // Move down for next card in this column
                    }
                }
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+T: Created ${newNodes.length} copied cards in top-aligned ${rows}√ó${cols} grid`);
        }
        
        // Arrange copied cards in cluster at mouse position
        function arrangeCopiedCardsInCluster() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in cluster (tight circle)
            const radius = 50; // Small cluster radius like original clusterSelectedCards
            
            newNodes.forEach((node, index) => {
                const angle = (index / newNodes.length) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                node.position({ x: x, y: y });
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            // Apply temporal markings to newly created cards
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
            
            console.log(`Q: Created and clustered ${newNodes.length} copied cards`);
        }
        
        // Quick note dialog for Alt+N
        function showQuickNoteDialog() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create quick note dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 500px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #333;">Snabb Anteckning</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    F√∂rsta raden = Titel<br>
                    Resten = Inneh√•ll (Shift+Enter f√∂r ny rad)<br>
                    #taggar hittas automatiskt √∂verallt<br>
                    <strong>Enter</strong>=Spara, <strong>Esc</strong>=Avbryt
                </p>
                <textarea id="quickNoteInput" placeholder="Min titel h√§r
H√§r skriver jag mitt inneh√•ll...
Kan ha #taggar √∂verallt.
#extra #taggar #h√§r" 
                    style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
                           font-family: 'SF Mono', Consolas, monospace; font-size: 14px; resize: vertical;"></textarea>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            const textarea = document.getElementById('quickNoteInput');
            textarea.focus();
            
            // Keyboard shortcuts - same as code dialog
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    createCardFromQuickNote(textarea.value);
                    document.body.removeChild(overlay);
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Shift+Enter allows normal newline
            });
            
            // Click outside to cancel
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
            
            // ESC handling for focus issues
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
        }
        
        // Parse quick note and create card
        function createCardFromQuickNote(input) {
            if (!input.trim()) return;
            
            const lines = input.trim().split('\n');
            if (lines.length === 0) return;
            
            // First line is always title
            const title = lines[0].trim();
            
            // Rest is content (skip first line)
            let contentLines = lines.slice(1);
            
            // Check if last line contains only tags (and has at least one #tag)
            let extraTags = [];
            if (contentLines.length > 0) {
                const lastLine = contentLines[contentLines.length - 1].trim();
                const hasOnlyTags = /^(#\w+\s*)+$/.test(lastLine); // Only #tags and whitespace
                
                if (hasOnlyTags && lastLine.includes('#')) {
                    // Extract tags from last line and remove it from content
                    const tagMatches = lastLine.match(/#\w+/g);
                    if (tagMatches) {
                        extraTags = tagMatches.map(t => t.substring(1));
                    }
                    contentLines = contentLines.slice(0, -1); // Remove last line from content
                }
            }
            
            // Join remaining content lines
            const text = contentLines.join('\n').trim();
            
            // Find all #tags in title and content
            let allTags = [...extraTags];
            const allText = (title + ' ' + text);
            const tagMatches = allText.match(/#\w+/g);
            if (tagMatches) {
                allTags.push(...tagMatches.map(t => t.substring(1)));
            }
            
            // Remove duplicates and filter out empty tags
            const uniqueTags = [...new Set(allTags)].filter(tag => tag.length > 0);
            
            // Use screen center as position (no mouse position for keyboard shortcut)
            const viewport = cy.extent();
            const centerX = (viewport.x1 + viewport.x2) / 2;
            const centerY = (viewport.y1 + viewport.y2) / 2;
            
            const newId = generateCardId();
            const newNode = cy.add({
                data: {
                    id: newId,
                    title: title,
                    text: text || title, // Use title as text if no content
                    tags: uniqueTags,
                    searchMatch: false
                },
                position: { x: centerX, y: centerY }
            });
            
            newNode.grabify();
            console.log(`Created quick note: "${title}" with ${uniqueTags.length} tags`);
        }
        
        // Edit card - unified for all card types (including images)
        function editCard(node) {
            // Clear any existing edit dialogs first
            clearAllEditDialogs();
            
            // Handle image nodes differently - use annotation field for text
            const isImageNode = node.data('type') === 'image';
            const currentText = isImageNode ? (node.data('annotation') || '') : (node.data('text') || '');
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing (unified UI without title)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara √§ndringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newText = textarea.value.trim();
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Allow saving with just tags (no text required)
                if (!newText && newTags.length === 0) {
                    alert('Antingen text eller minst en tagg kr√§vs');
                    return;
                }
                
                if (isImageNode) {
                    // For image nodes, save to annotation field and update searchable text
                    node.data('annotation', newText);
                    node.data('searchableText', newText.toLowerCase());
                    
                    // Update title to show annotation indicator
                    // Don't show filename in title, keep title empty for clean image display
                    node.data('title', '');
                } else {
                    // For regular nodes, save to text field
                    node.data('text', newText);
                }
                
                node.data('tags', newTags);
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                refreshSearchAndFilter();
                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    document.getElementById('saveEdit').click();
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // DEPRECATED - Edit manually created cards with textarea popup
        // Now using unified editCard() function instead
        function editManualCard_DEPRECATED(node) {
            const currentText = node.data('text') || '';
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara √§ndringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newText = textarea.value.trim();
                if (!newText) {
                    alert('Text kr√§vs');
                    return;
                }
                
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Update node data
                node.data('text', newText);
                node.data('tags', newTags);
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                // Re-run search if active
                const searchInput = document.getElementById('searchInput');
                if (searchInput.value.trim()) {
                    performSearch(searchInput.value);
                }
                
                // Re-run tag filter if active
                const tagFilterInput = document.getElementById('tagFilterInput');
                if (tagFilterInput.value.trim()) {
                    performTagFilter(tagFilterInput.value);
                }
                
                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    document.getElementById('saveEdit').click();
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // DEPRECATED - Edit imported cards with old prompt system  
        // Now using unified editCard() function instead
        function editImportedCard_DEPRECATED(node) {
            const currentTitle = node.data('title') || '';
            const currentText = node.data('text') || '';
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing (same as addNewCard and editManualCard)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Titel (valfritt):</label>
                    <input type="text" id="editCardTitle" value="${currentTitle}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px; margin-bottom: 10px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara √§ndringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newTitle = document.getElementById('editCardTitle').value.trim();
                const newText = textarea.value.trim();
                if (!newText) {
                    alert('Text kr√§vs');
                    return;
                }
                
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Update node data
                node.data('title', newTitle);
                node.data('text', newText);
                node.data('tags', newTags);
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                refreshSearchAndFilter();
                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
                // Clear any existing edit dialogs to prevent conflicts
                const existingDialogs = document.querySelectorAll('[id^="editCard"], [id^="newCard"]');
                existingDialogs.forEach(dialog => {
                    if (dialog.parentNode && dialog.parentNode !== document.body) {
                        dialog.parentNode.remove();
                    }
                });
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            textarea.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    document.getElementById('saveEdit').click();
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // Helper function to refresh search and filter
        function refreshSearchAndFilter() {
            // Re-run search if active
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value.trim()) {
                performSearch(searchInput.value);
            }
            
            // Re-run tag filter if active
            const tagFilterInput = document.getElementById('tagFilterInput');
            if (tagFilterInput.value.trim()) {
                performTagFilter(tagFilterInput.value);
            }
        }
        
        // Global function to clean up any stray edit dialogs
        function clearAllEditDialogs() {
            // Remove overlays by style attributes
            const overlays = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10000"]');
            overlays.forEach(overlay => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            });
            
            // Remove any elements with edit-related IDs
            const editElements = document.querySelectorAll('#editCardText, #editCardTags, #editCardTitle, #newCardText, #newCardTags, #saveEdit, #cancelEdit, #saveCard, #cancelCard');
            editElements.forEach(element => {
                // Find the overlay parent (should be 2-3 levels up)
                let parent = element.parentNode;
                while (parent && parent !== document.body) {
                    if (parent.style.position === 'fixed' && parent.style.zIndex === '10000') {
                        if (parent.parentNode) {
                            parent.parentNode.removeChild(parent);
                        }
                        break;
                    }
                    parent = parent.parentNode;
                }
            });
            
            // Remove all event listeners by cloning and replacing document
            // This is a bit aggressive but ensures no zombie listeners
            console.log('Cleared all edit dialogs and potential zombie listeners');
        }
        
        // Google Drive API Configuration
        const GOOGLE_CLIENT_ID = '971005822021-8ebrpd92n1upsedg7s5fn80mnmvhou5d.apps.googleusercontent.com';
        const GOOGLE_SCOPE = 'https://www.googleapis.com/auth/drive.file';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        
        let isGoogleApiLoaded = false;
        let isSignedIn = false;
        let accessToken = null;
        let tokenClient = null;
        
        // Project management  
        let currentProject = localStorage.getItem('spatial-notes-project-name') || 'Nytt projekt';
        let availableProjects = [];
        let projectsLoaded = false;
        
        // Token management with enhanced persistence
        let tokenExpiry = null;
        let rememberMeEnabled = false;
        
        // Check user's remember preference
        function checkRememberPreference() {
            const remembered = localStorage.getItem('auth_remember_preference');
            return remembered === 'true';
        }
        
        // Save tokens with enhanced persistence options
        function saveTokens(forceRemember = false) {
            if (accessToken) {
                const storage = (rememberMeEnabled || forceRemember) ? localStorage : sessionStorage;
                const prefix = (rememberMeEnabled || forceRemember) ? 'google_' : 'session_google_';
                
                storage.setItem(prefix + 'access_token', accessToken);
                storage.setItem(prefix + 'token_expiry', tokenExpiry?.toString() || '');
                storage.setItem(prefix + 'current_project', currentProject);
                
                if (rememberMeEnabled || forceRemember) {
                    localStorage.setItem('auth_remember_preference', 'true');
                    console.log('Tokens saved to localStorage (30-day persistence)');
                } else {
                    localStorage.setItem('auth_remember_preference', 'false');
                    console.log('Tokens saved to sessionStorage (session only)');
                }
            }
        }
        
        // Load tokens from storage (localStorage or sessionStorage)
        function loadSavedTokens() {
            // Check user preference for remember me
            const rememberPreference = checkRememberPreference();
            
            // Try localStorage first (30-day persistence)
            let savedToken = localStorage.getItem('google_access_token');
            let savedExpiry = localStorage.getItem('google_token_expiry');
            let savedProject = localStorage.getItem('google_current_project');
            let source = 'localStorage (30-day)';
            
            // If no localStorage tokens, try sessionStorage
            if (!savedToken) {
                savedToken = sessionStorage.getItem('session_google_access_token');
                savedExpiry = sessionStorage.getItem('session_google_token_expiry');
                savedProject = sessionStorage.getItem('session_google_current_project');
                source = 'sessionStorage (session)';
            }
            
            if (savedToken && savedExpiry) {
                const expiryTime = parseInt(savedExpiry);
                const now = Date.now();
                
                // Check if token is still valid (with 5 minute buffer)
                if (expiryTime && now < (expiryTime - 5 * 60 * 1000)) {
                    accessToken = savedToken;
                    tokenExpiry = expiryTime;
                    isSignedIn = true;
                    rememberMeEnabled = rememberPreference;
                    
                    if (savedProject) {
                        currentProject = savedProject;
                    }
                    
                    console.log(`Restored valid tokens from ${source}`);
                    return true;
                } else {
                    console.log(`Saved tokens expired, clearing ${source}`);
                    clearSavedTokens();
                }
            }
            
            return false;
        }
        
        // Clear saved tokens from both storage types
        function clearSavedTokens() {
            // Clear localStorage tokens
            localStorage.removeItem('google_access_token');
            localStorage.removeItem('google_token_expiry');
            localStorage.removeItem('google_current_project');
            
            // Clear sessionStorage tokens
            sessionStorage.removeItem('session_google_access_token');
            sessionStorage.removeItem('session_google_token_expiry');
            sessionStorage.removeItem('session_google_current_project');
            
            // Reset auth state
            accessToken = null;
            tokenExpiry = null;
            isSignedIn = false;
            rememberMeEnabled = false;
            
            console.log('Cleared saved tokens from both storage types');
        }
        
        // Check if token needs refresh
        function isTokenExpiringSoon() {
            if (!tokenExpiry) return true;
            const now = Date.now();
            const timeToExpiry = tokenExpiry - now;
            // Refresh if less than 10 minutes left
            return timeToExpiry < (10 * 60 * 1000);
        }
        
        // Show remember me dialog before first login
        function showRememberMeDialog() {
            return new Promise((resolve) => {
                // Check if user has already made a choice
                const existingPreference = localStorage.getItem('auth_remember_preference');
                if (existingPreference !== null) {
                    rememberMeEnabled = existingPreference === 'true';
                    resolve(rememberMeEnabled);
                    return;
                }
                
                // Create remember me dialog
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.7); z-index: 10000;
                    display: flex; justify-content: center; align-items: center;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 30px; border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3); max-width: 400px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #007acc; text-align: center;">
                        üîê Google Drive Inloggning
                    </h3>
                    <p style="margin: 0 0 20px 0; line-height: 1.5; color: #333;">
                        Vill du att vi ska komma ih√•g din inloggning p√• den h√§r enheten?
                    </p>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin: 0 0 10px 0; font-weight: bold; color: #007acc;">üì± Kom ih√•g i 30 dagar:</p>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>Funkar p√• alla dina enheter (iPad, Android, dator)</li>
                            <li>Automatisk synkronisering</li>
                            <li>Mindre inloggningar</li>
                        </ul>
                        
                        <p style="margin: 15px 0 5px 0; font-weight: bold; color: #666;">üîí Bara denna session:</p>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>Loggas ut n√§r du st√§nger browsern</li>
                            <li>Mer s√§kert p√• delade enheter</li>
                        </ul>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="rememberYes" style="
                            padding: 12px 24px; background: #007acc; color: white; 
                            border: none; border-radius: 6px; cursor: pointer;
                            font-size: 16px; font-weight: bold;
                        ">üîì Kom ih√•g i 30 dagar</button>
                        <button id="rememberNo" style="
                            padding: 12px 24px; background: #666; color: white; 
                            border: none; border-radius: 6px; cursor: pointer;
                            font-size: 16px;
                        ">üîí Bara denna session</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Handle button clicks
                dialog.querySelector('#rememberYes').onclick = () => {
                    rememberMeEnabled = true;
                    localStorage.setItem('auth_remember_preference', 'true');
                    document.body.removeChild(overlay);
                    resolve(true);
                };
                
                dialog.querySelector('#rememberNo').onclick = () => {
                    rememberMeEnabled = false;
                    localStorage.setItem('auth_remember_preference', 'false');
                    document.body.removeChild(overlay);
                    resolve(false);
                };
            });
        }
        
        // Refresh token if needed before API calls
        async function ensureValidToken() {
            if (!isSignedIn || !accessToken) {
                throw new Error('Not signed in to Google Drive');
            }
            
            if (isTokenExpiringSoon()) {
                console.log('Token expiring soon, requesting new token...');
                
                return new Promise((resolve, reject) => {
                    // Request new token
                    tokenClient.requestAccessToken({
                        prompt: '',
                        callback: (response) => {
                            if (response.access_token) {
                                accessToken = response.access_token;
                                tokenExpiry = Date.now() + (response.expires_in ? response.expires_in * 1000 : 3600000);
                                saveTokens();
                                console.log('Token refreshed successfully');
                                resolve();
                            } else {
                                console.error('Failed to refresh token:', response.error);
                                clearSavedTokens();
                                updateAuthStatus();
                                reject(new Error('Token refresh failed'));
                            }
                        }
                    });
                });
            }
            
            return Promise.resolve();
        }
        
        // ====================================================================================================
        // üìÇ PROJECT SELECTOR FUNCTIONS
        // ====================================================================================================
        
        // Update project name in UI
        function updateProjectNameUI() {
            const projectNameElement = document.getElementById('projectName');
            if (projectNameElement) {
                projectNameElement.textContent = currentProject;
                localStorage.setItem('spatial-notes-project-name', currentProject);
            }
        }
        
        // Toggle project dropdown
        function toggleProjectDropdown() {
            const dropdown = document.getElementById('projectDropdown');
            if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeProjectDropdownOnClickOutside);
            } else {
                dropdown.classList.add('show');
                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeProjectDropdownOnClickOutside);
                }, 10);
            }
        }
        
        // Close dropdown when clicking outside
        function closeProjectDropdownOnClickOutside(event) {
            const dropdown = document.getElementById('projectDropdown');
            const button = document.getElementById('projectButton');
            
            if (!dropdown.contains(event.target) && !button.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeProjectDropdownOnClickOutside);
            }
        }
        
        // Rename current project
        function renameProject() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            const newName = prompt(`Byt namn p√• projekt "${currentProject}" till:`, currentProject);
            if (newName && newName.trim() && newName.trim() !== currentProject) {
                const oldName = currentProject;
                currentProject = newName.trim();
                updateProjectNameUI();
                
                // Show success message
                updateSyncStatus(`‚úèÔ∏è Projektnamn √§ndrat: "${oldName}" ‚Üí "${currentProject}"`, 'success');
                
                // If signed in to Google Drive, this will be saved on next save
                if (isSignedIn && accessToken) {
                    // Automatically save to update the project name in Google Drive
                    setTimeout(() => saveBoard(), 500);
                }
            }
        }
        
        // Create new project
        function createNewProject() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            const projectName = prompt('Ange namn f√∂r det nya projektet:', '');
            if (projectName && projectName.trim()) {
                // Save current project if it has content
                const hasContent = cy.nodes().length > 0;
                if (hasContent && isSignedIn && accessToken) {
                    saveBoard(); // Save current project first
                }
                
                // Clear current board
                cy.nodes().remove();
                cy.edges().remove();
                
                // Set new project name
                currentProject = projectName.trim();
                updateProjectNameUI();
                
                updateSyncStatus(`‚ûï Nytt projekt skapat: "${currentProject}"`, 'success');
            }
        }
        
        // Show project list (simplified version)
        function showProjectList() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            if (!isSignedIn || !accessToken) {
                // Show local projects only
                alert('Logga in p√• Google Drive f√∂r att se alla sparade projekt.\n\nF√∂r n√§rvarande arbetar du lokalt med projekt: "' + currentProject + '"');
                return;
            }
            
            // Use existing project manager
            showProjectManager();
        }
        
        // Manage projects (same as existing function)
        function manageProjects() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            if (!isSignedIn || !accessToken) {
                alert('Logga in p√• Google Drive f√∂r att hantera projekt.\n\nF√∂r n√§rvarande arbetar du lokalt med projekt: "' + currentProject + '"');
                return;
            }
            
            showProjectManager();
        }
        
        // Initialize project name on page load
        function initializeProjectName() {
            updateProjectNameUI();
        }
        
        // ====================================================================================================
        // üíæ SMART SAVE SYSTEM - Enhanced save with Google Drive integration
        // ====================================================================================================
        
        // Smart save function - handles Google Drive integration
        async function smartSave() {
            try {
                // Always save to localStorage first (instant backup)
                saveBoard();
                updateSyncStatus('Sparad lokalt ‚úì', 'success');
                
                // Check if user is signed in to Google Drive
                if (isSignedIn && accessToken) {
                    // User is signed in - save to Google Drive with structured filename
                    await saveToGoogleDriveWithStructure();
                } else {
                    // User not signed in - offer to sign in
                    showGoogleDriveSignInPrompt();
                }
            } catch (error) {
                console.error('Smart save error:', error);
                updateSyncStatus('Sparning misslyckades', 'error');
            }
        }
        
        // Save to Google Drive with proper folder structure and naming
        async function saveToGoogleDriveWithStructure() {
            try {
                await ensureValidToken();
                
                // Create structured filename: projektnamn_YYYY-MM-DD_HH-MM.json
                const now = new Date();
                const dateStr = now.getFullYear() + '-' + 
                               String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(now.getDate()).padStart(2, '0');
                const timeStr = String(now.getHours()).padStart(2, '0') + '-' + 
                               String(now.getMinutes()).padStart(2, '0');
                
                // Clean project name for filename (remove invalid chars)
                const cleanProjectName = currentProject
                    .replace(/[<>:"/\\|?*]/g, '-')  // Replace invalid chars with dashes
                    .replace(/\s+/g, '_')           // Replace spaces with underscores
                    .substring(0, 50);              // Limit length
                
                const filename = `${cleanProjectName}_${dateStr}_${timeStr}.json`;
                
                updateSyncStatus(`Sparar till Google Drive: ${filename}`, 'loading');
                
                // Get board data
                const boardData = {
                    project_name: currentProject,
                    saved_date: now.toISOString(),
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        hidden_tags: node.data('hidden_tags') || [],
                        position: node.position(),
                        pinned: node.hasClass('pinned') || false,
                        isManualCard: node.data('isManualCard') || false,
                        cardColor: node.data('cardColor') || null,
                        // Image data
                        isImageCard: node.data('isImageCard') || false,
                        imageData: node.data('imageData') || null,
                        imageWidth: node.data('imageWidth') || null,
                        imageHeight: node.data('imageHeight') || null,
                        calculatedHeight: node.data('calculatedHeight') || null,
                        originalFileName: node.data('originalFileName') || null,
                        imageNotes: node.data('imageNotes') || '',
                        // All other metadata
                        export_timestamp: node.data('export_timestamp') || null,
                        export_session: node.data('export_session') || null,
                        export_source: node.data('export_source') || null,
                        source_file: node.data('source_file') || null,
                        page_number: node.data('page_number') || null,
                        matched_terms: node.data('matched_terms') || null,
                        card_index: node.data('card_index') || null
                    })),
                    metadata: {
                        total_cards: cy.nodes().length,
                        version: '2.1',
                        saved_from: 'spatial-notes-smart-save'
                    }
                };
                
                // Find or create 'Spatial Notes' folder
                const folderId = await findOrCreateSpatialNotesFolder();
                
                // Save file to the folder
                const fileBlob = new Blob([JSON.stringify(boardData, null, 2)], { type: 'application/json' });
                
                // Check if file already exists with same name (for versioning)
                const existingFiles = await findFilesInFolder(folderId, filename);
                
                let saveResponse;
                if (existingFiles.length > 0) {
                    // Update existing file
                    const fileId = existingFiles[0].id;
                    saveResponse = await updateFileInGoogleDrive(fileId, fileBlob);
                } else {
                    // Create new file
                    saveResponse = await createFileInGoogleDrive(filename, fileBlob, folderId);
                }
                
                if (saveResponse.ok) {
                    const fileInfo = await saveResponse.json();
                    updateSyncStatus(`‚úÖ Sparad i Google Drive: "${filename}"`, 'success');
                    console.log(`Successfully saved project "${currentProject}" to Google Drive as ${filename}`);
                } else {
                    throw new Error('Failed to save to Google Drive: ' + saveResponse.statusText);
                }
                
            } catch (error) {
                console.error('Error saving to Google Drive with structure:', error);
                updateSyncStatus('Google Drive-sparning misslyckades', 'error');
                // Local save is still done, so user doesn't lose data
            }
        }
        
        // Show prompt to sign in to Google Drive
        function showGoogleDriveSignInPrompt() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10001;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 30px; border-radius: 10px; 
                box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px; width: 90%;
                text-align: center; font-family: inherit;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #333;">üíæ Spara online?</h3>
                <p style="margin: 15px 0; color: #666; line-height: 1.5;">
                    Ditt projekt "<strong>${currentProject}</strong>" √§r sparat lokalt.<br><br>
                    Vill du logga in p√• Google Drive f√∂r att spara online och synka mellan dina enheter?
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button id="signInYes" style="
                        padding: 12px 20px; background: #007acc; color: white; 
                        border: none; border-radius: 6px; cursor: pointer; font-size: 16px;
                    ">üîó Ja, logga in</button>
                    <button id="signInNo" style="
                        padding: 12px 20px; background: #666; color: white; 
                        border: none; border-radius: 6px; cursor: pointer; font-size: 16px;
                    ">üì± Nej, bara lokalt</button>
                </div>
                <p style="margin: 15px 0 5px 0; font-size: 12px; color: #999;">
                    Du kan alltid logga in senare via menyn.
                </p>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Handle buttons
            document.getElementById('signInYes').onclick = () => {
                document.body.removeChild(overlay);
                // Start Google sign-in process
                toggleGoogleDriveAuth();
            };
            
            document.getElementById('signInNo').onclick = () => {
                document.body.removeChild(overlay);
                updateSyncStatus('Sparad lokalt (endast denna enhet)', 'info');
            };
            
            // Close on Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Find or create 'Spatial Notes' folder in Google Drive
        async function findOrCreateSpatialNotesFolder() {
            try {
                // Search for existing 'Spatial Notes' folder
                const searchParams = new URLSearchParams({
                    q: "name='Spatial Notes' and mimeType='application/vnd.google-apps.folder'",
                    fields: 'files(id, name)'
                });
                
                const searchResponse = await fetch(`https://www.googleapis.com/drive/v3/files?${searchParams}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const searchResult = await searchResponse.json();
                
                if (searchResult.files && searchResult.files.length > 0) {
                    // Folder exists, return its ID
                    return searchResult.files[0].id;
                } else {
                    // Create new folder
                    const createResponse = await fetch('https://www.googleapis.com/drive/v3/files', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: 'Spatial Notes',
                            mimeType: 'application/vnd.google-apps.folder'
                        })
                    });
                    
                    const createResult = await createResponse.json();
                    console.log('Created Spatial Notes folder:', createResult.id);
                    return createResult.id;
                }
                
            } catch (error) {
                console.error('Error finding/creating Spatial Notes folder:', error);
                // Return null to save to root folder as fallback
                return null;
            }
        }
        
        // Find files in a specific folder
        async function findFilesInFolder(folderId, filename) {
            try {
                const query = folderId 
                    ? `name='${filename}' and '${folderId}' in parents`
                    : `name='${filename}'`;
                
                const searchParams = new URLSearchParams({
                    q: query,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${searchParams}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                return result.files || [];
                
            } catch (error) {
                console.error('Error finding files in folder:', error);
                return [];
            }
        }
        
        // Create file in Google Drive
        async function createFileInGoogleDrive(filename, fileBlob, parentFolderId = null) {
            const metadata = {
                name: filename
            };
            
            if (parentFolderId) {
                metadata.parents = [parentFolderId];
            }
            
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
            form.append('file', fileBlob);
            
            return fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                },
                body: form
            });
        }
        
        // Update existing file in Google Drive
        async function updateFileInGoogleDrive(fileId, fileBlob) {
            return fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: fileBlob
            });
        }
        
        // Initialize Google API
        async function initializeGoogleAPI() {
            try {
                // Wait for Google Identity Services to be available
                if (typeof google === 'undefined' || !google.accounts) {
                    console.log('Google Identity Services not yet loaded, retrying in 2 seconds...');
                    setTimeout(() => initializeGoogleAPI(), 2000);
                    return;
                }
                
                console.log('Initializing Google Identity Services...');
                
                // Try to load saved tokens first
                const hasValidTokens = loadSavedTokens();
                if (hasValidTokens) {
                    console.log('‚úÖ Auto-signed in with saved tokens');
                    updateAuthStatus();
                    
                    // Load available projects and current project
                    setTimeout(async () => {
                        await loadAvailableProjects();
                        if (currentProject) {
                            await loadFromGoogleDrive();
                        }
                    }, 1000);
                }
                
                // Initialize Google Identity Services token client
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: GOOGLE_SCOPE,
                    callback: (response) => {
                        if (response.access_token) {
                            accessToken = response.access_token;
                            isSignedIn = true;
                            
                            // Calculate token expiry (Google tokens typically last 1 hour)
                            tokenExpiry = Date.now() + (response.expires_in ? response.expires_in * 1000 : 3600000);
                            
                            // Save tokens for persistence
                            saveTokens();
                            
                            console.log('Successfully signed in to Google Drive');
                            console.log('Token expires at:', new Date(tokenExpiry).toLocaleString());
                            updateAuthStatus();
                            
                            // Load available projects and then current project
                            setTimeout(async () => {
                                await loadAvailableProjects();
                                await loadFromGoogleDrive();
                            }, 500);
                        } else if (response.error) {
                            console.error('Authentication error:', response.error);
                            updateSyncStatus('Authentication failed', 'error');
                        }
                    },
                });
                
                isGoogleApiLoaded = true;
                console.log('Google Identity Services initialized successfully');
                
                // Try to restore saved tokens
                if (loadSavedTokens()) {
                    console.log(`Restored session from saved tokens, project: ${currentProject}`);
                    updateAuthStatus();
                    
                    // Load projects and current project
                    setTimeout(async () => {
                        await loadAvailableProjects();
                        console.log(`Loading saved project: ${currentProject}`);
                        await loadFromGoogleDrive();
                    }, 500);
                } else {
                    updateAuthStatus();
                }
                
            } catch (error) {
                console.error('Error initializing Google Identity Services:', error);
                
                // Check if we're running locally
                if (window.location.protocol === 'file:') {
                    console.log('Google Drive sync requires HTTPS. Deploy to GitHub Pages to test.');
                    updateSyncStatus('Google Drive needs HTTPS', 'info');
                    
                    // Disable the Google Drive button for local development
                    const driveBtn = document.getElementById('googleDriveBtn');
                    if (driveBtn) {
                        driveBtn.disabled = true;
                        driveBtn.innerHTML = '<span>‚ö†Ô∏è</span><span>Needs HTTPS</span>';
                    }
                } else {
                    console.log('Google Identity Services will retry in 5 seconds...');
                    updateSyncStatus('Google API loading...', 'info');
                    
                    // Retry initialization after 5 seconds
                    setTimeout(() => initializeGoogleAPI(), 5000);
                }
            }
        }
        
        // Update authentication status
        function updateAuthStatus() {
            if (!isGoogleApiLoaded) return;
            
            const driveBtn = document.getElementById('googleDriveBtn');
            const driveButtonText = document.getElementById('driveButtonText');
            
            // Check if elements exist before updating
            if (!driveBtn) {
                console.log('Google Drive button not found in DOM');
                return;
            }
            
            if (isSignedIn && accessToken) {
                if (driveButtonText) driveButtonText.textContent = `${currentProject}`;
                driveBtn.innerHTML = `‚úÖ Google Drive (Inloggad)`;
                updateSyncStatus(`Synced: ${currentProject}`, 'success');
                
                // Start auto-sync
                startAutoSync();
            } else {
                if (driveButtonText) driveButtonText.textContent = 'Google Drive';
                driveBtn.innerHTML = `üîó Google Drive (Ej inloggad)`;
                updateSyncStatus('', '');
                
                // Stop auto-sync when signed out
                stopAutoSync();
            }
        }
        
        // Toggle Google Drive authentication with Remember Me option
        async function toggleGoogleDriveAuth() {
            if (!isGoogleApiLoaded || !tokenClient) {
                updateSyncStatus('Google API not loaded yet...', 'loading');
                return;
            }
            
            try {
                if (isSignedIn && accessToken) {
                    // Sign out
                    if (confirm('Logga ut fr√•n Google Drive?\n\nDetta kommer att:\n‚Ä¢ Stoppa automatisk synkronisering\n‚Ä¢ Du beh√∂ver logga in igen f√∂r Drive-funktioner\n‚Ä¢ Lokalt sparade kort p√•verkas inte')) {
                        google.accounts.oauth2.revoke(accessToken, () => {
                            console.log('Access token revoked');
                        });
                        
                        // Clear all tokens and saved data
                        clearSavedTokens();
                        
                        updateSyncStatus('Signed out from Google Drive', 'info');
                        updateAuthStatus();
                    }
                } else {
                    // Show remember me dialog first
                    updateSyncStatus('F√∂rbereder inloggning...', 'loading');
                    
                    // Show remember me dialog and wait for user choice
                    const rememberChoice = await showRememberMeDialog();
                    console.log('User chose remember me:', rememberChoice);
                    
                    // Sign in - request access token  
                    updateSyncStatus('Signing in to Google Drive...', 'loading');
                    tokenClient.requestAccessToken({prompt: 'consent'});
                }
            } catch (error) {
                console.error('Authentication error:', error);
                updateSyncStatus('Authentication failed', 'error');
            }
        }
        
        // Project Management Functions
        
        // Load list of available projects from Google Drive
        async function loadAvailableProjects() {
            try {
                await ensureValidToken();
                const params = new URLSearchParams({
                    q: "name contains 'spatial-notes-' and name contains '.json' and trashed=false",
                    spaces: 'drive',
                    fields: 'files(id, name, modifiedTime)',
                    orderBy: 'modifiedTime desc'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${params}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to load projects:', response.statusText);
                    return [];
                }
                
                const result = await response.json();
                const projects = [];
                
                result.files.forEach(file => {
                    // Extract project name from filename: spatial-notes-PROJECT.json -> PROJECT
                    const match = file.name.match(/^spatial-notes-(.+)\.json$/);
                    if (match) {
                        projects.push({
                            name: match[1],
                            fileId: file.id,
                            lastModified: file.modifiedTime
                        });
                    }
                });
                
                availableProjects = projects;
                projectsLoaded = true;
                console.log('Loaded projects:', projects);
                return projects;
                
            } catch (error) {
                console.error('Error loading projects:', error);
                return [];
            }
        }
        
        // Switch to a different project
        async function switchProject(projectName) {
            if (projectName === currentProject) return;
            
            try {
                // Save current project first
                if (isSignedIn && accessToken) {
                    updateSyncStatus('Saving current project...', 'loading');
                    await saveToGoogleDrive();
                }
                
                // Switch to new project
                currentProject = projectName;
                
                // Save current project to localStorage immediately
                localStorage.setItem('google_current_project', currentProject);
                
                updateSyncStatus(`Switching to ${projectName}...`, 'loading');
                
                // Load the new project
                const success = await loadFromGoogleDrive();
                
                if (success) {
                    updateSyncStatus(`‚úÖ Loaded ${projectName}`, 'success');
                } else {
                    // New project - start with empty board
                    cy.nodes().remove();
                    updateSyncStatus(`‚úÖ New project: ${projectName}`, 'success');
                }
                
                // Update UI
                updateAuthStatus();
                
            } catch (error) {
                console.error('Error switching project:', error);
                updateSyncStatus('Failed to switch project', 'error');
            }
        }
        
        // Create a new project
        async function createNewProject(projectName) {
            if (!projectName || projectName.trim() === '') return;
            
            // Sanitize project name
            projectName = projectName.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
            
            // Check if project already exists
            const existingProject = availableProjects.find(p => p.name === projectName);
            if (existingProject) {
                alert(`Project "${projectName}" already exists!`);
                return;
            }
            
            // Switch to new project
            await switchProject(projectName);
        }
        
        // Get current project filename
        function getCurrentProjectFileName() {
            return `spatial-notes-${currentProject}.json`;
        }
        
        // Update node appearance after loading
        function updateNodeAppearance(node) {
            try {
                // Apply color if node has cardColor data
                const cardColor = node.data('cardColor');
                if (cardColor) {
                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                    node.style('background-color', colorValue);
                }
                
                // Apply pinned styling if needed
                const isPinned = node.data('isPinned');
                if (isPinned) {
                    node.addClass('pinned');
                }
                
                // Update text content and height with delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        const heightInfo = getMeasuredTextHeight(node);
                        console.log(`Setting height for node ${node.id()}: ${heightInfo}px`);
                        node.style('height', heightInfo + 'px');
                    } catch (heightError) {
                        console.error('Error calculating height for node:', node.id(), heightError);
                        // Fallback to default height calculation with proper padding
                        const textLength = (node.data('text') || '').length;
                        const defaultHeight = Math.max(140, textLength * 0.8 + 60); // 140px minimum fallback
                        console.log(`Fallback height for ${node.id()}: ${defaultHeight}px`);
                        node.style('height', defaultHeight + 'px');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error updating node appearance:', error);
                // Continue without styling rather than failing
            }
        }
        
        // Update sync status display using the existing search results info area
        function updateSyncStatus(message, type = '') {
            const statusEl = document.querySelector('.search-results-info');
            
            if (!statusEl) {
                console.log('Status element not found');
                return;
            }
            
            // Show the status box and set message
            statusEl.textContent = message;
            statusEl.classList.add('visible');
            
            // Clear existing type classes
            statusEl.classList.remove('sync-success', 'sync-error', 'sync-loading', 'sync-info');
            
            // Add type-specific styling
            if (type) {
                statusEl.classList.add(`sync-${type}`);
            }
            
            // Auto-clear status after 5 seconds for non-permanent messages
            if (type === 'loading' || type === 'info') {
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-loading', 'sync-info');
                }, 5000);
            } else if (type === 'error') {
                // Keep error messages longer
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-error');
                }, 8000);
            } else if (type === 'success') {
                // Keep success messages for a medium time
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-success');
                }, 6000);
            }
        }
        
        // Save board to Google Drive
        async function saveToGoogleDrive() {
            try {
                // Ensure we have a valid token
                await ensureValidToken();
                
                console.log(`Saving project "${currentProject}" to Google Drive...`);
                updateSyncStatus('Saving to Google Drive...', 'loading');
                
                const cardCount = cy.nodes().length;
                console.log(`Preparing to save ${cardCount} cards`);
                
                const boardData = {
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        x: node.position('x'),
                        y: node.position('y'),
                        cardColor: node.data('cardColor') || '',
                        export_source: node.data('export_source') || '',
                        source_file: node.data('source_file') || '',
                        matched_terms: node.data('matched_terms') || '',
                        isManualCard: node.data('isManualCard') || false,
                        isPinned: node.data('isPinned') || false
                    })),
                    timestamp: new Date().toISOString(),
                    version: '2.0'
                };
                
                const fileContent = JSON.stringify(boardData, null, 2);
                const fileName = getCurrentProjectFileName();
                
                console.log(`File to save: ${fileName}`);
                console.log(`Content length: ${fileContent.length} characters`);
                console.log(`Board data:`, boardData);
                
                // Check if file already exists
                console.log('Checking if file exists...');
                const existingFileId = await findSpatialNotesFile();
                console.log('Existing file ID:', existingFileId);
                
                if (existingFileId) {
                    // Update existing file
                    const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFileId}?uploadType=media`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: fileContent
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to update file: ${response.statusText}`);
                    }
                } else {
                    // Create new file (simple approach)
                    const metadata = {
                        name: fileName
                    };
                    
                    // First create the file metadata
                    const createResponse = await fetch('https://www.googleapis.com/drive/v3/files', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(metadata)
                    });
                    
                    if (!createResponse.ok) {
                        throw new Error(`Failed to create file: ${createResponse.statusText}`);
                    }
                    
                    const fileInfo = await createResponse.json();
                    
                    // Then upload the content
                    const uploadResponse = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileInfo.id}?uploadType=media`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: fileContent
                    });
                    
                    if (!uploadResponse.ok) {
                        throw new Error(`Failed to upload content: ${uploadResponse.statusText}`);
                    }
                }
                
                updateSyncStatus('‚úÖ Saved to Drive', 'success');
                return true;
            } catch (error) {
                console.error('Error saving to Google Drive:', error);
                
                // If error is auth-related, clear tokens and update UI
                if (error.message.includes('Not signed in') || error.message.includes('Token refresh failed')) {
                    clearSavedTokens();
                    updateAuthStatus();
                    updateSyncStatus('Please sign in to Google Drive', 'error');
                } else {
                    updateSyncStatus('Failed to save to Drive', 'error');
                }
                return false;
            }
        }
        
        // Load board from Google Drive
        async function loadFromGoogleDrive() {
            try {
                // Ensure we have a valid token
                await ensureValidToken();
                
                console.log(`Loading project "${currentProject}" from Google Drive...`);
                updateSyncStatus('Loading from Google Drive...', 'loading');
                
                const fileId = await findSpatialNotesFile();
                console.log('File search result:', fileId);
                
                if (!fileId) {
                    console.log(`No file found for project "${currentProject}"`);
                    updateSyncStatus(`No saved data for "${currentProject}"`, 'info');
                    return false;
                }
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                console.log('Drive API response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Drive API error:', errorText);
                    throw new Error(`Failed to load file: ${response.status} ${response.statusText}`);
                }
                
                const fileContent = await response.text();
                console.log('File content length:', fileContent.length);
                console.log('File content preview:', fileContent.substring(0, 200));
                
                const boardData = JSON.parse(fileContent);
                console.log('Parsed board data:', boardData);
                
                // Check if we already have cards loaded (from localStorage)
                const existingCards = cy.nodes().length;
                console.log(`Found ${existingCards} existing cards before Drive sync`);
                
                // Clear existing cards silently without visual updates during sync
                cy.batch(() => {
                    cy.nodes().remove();
                });
                
                // Add cards from Drive in a batch to minimize visual updates
                if (boardData.cards && boardData.cards.length > 0) {
                    console.log(`Loading ${boardData.cards.length} cards...`);
                    
                    // Batch all card additions to prevent visual jumping
                    cy.batch(() => {
                        boardData.cards.forEach((card, index) => {
                            console.log(`Adding card ${index + 1}:`, card.id, card.title?.substring(0, 30));
                            
                            const nodeData = {
                                id: card.id,
                                title: card.title || '',
                                text: card.text || '',
                                tags: card.tags || [],
                                cardColor: card.cardColor || '',
                                export_source: card.export_source || '',
                                source_file: card.source_file || '',
                                matched_terms: card.matched_terms || '',
                                isManualCard: card.isManualCard || false,
                                isPinned: card.isPinned || false
                            };
                            
                            const node = cy.add({
                                data: nodeData,
                                position: { x: card.x || 0, y: card.y || 0 }
                            });
                            
                            // Apply auto-gray coloring for #done tags
                            applyAutoDoneColoring(node);
                            
                            // Apply colors and pinning immediately, skip height for now
                            const cardColor = node.data('cardColor');
                            if (cardColor) {
                                const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                node.style('background-color', colorValue);
                            }
                            
                            if (node.data('isPinned')) {
                                node.addClass('pinned');
                            }
                        });
                    });
                    
                    console.log('All cards loaded successfully');
                    updateSyncStatus(`‚úÖ Loaded ${boardData.cards.length} cards from "${currentProject}"`, 'success');
                    
                    // Skip height updates if cards were already loaded from localStorage 
                    // to prevent visual jumping during Drive sync
                    if (existingCards === 0) {
                        // Only update heights for first load (no localStorage data)
                        console.log('First load - applying height calculations');
                        setTimeout(() => {
                            cy.batch(() => {
                                cy.nodes().forEach(node => {
                                    try {
                                        const heightInfo = getMeasuredTextHeight(node);
                                        node.style('height', heightInfo + 'px');
                                    } catch (error) {
                                        const textLength = (node.data('text') || '').length;
                                        const fallbackHeight = Math.max(140, textLength * 0.8 + 60);
                                        node.style('height', fallbackHeight + 'px');
                                    }
                                });
                            });
                            console.log(`Height calculations applied to ${cy.nodes().length} cards`);
                        }, 150);
                    } else {
                        console.log('Skipped height updates - cards already properly sized from localStorage');
                    }
                    
                    // Auto-save to localStorage as backup
                    setTimeout(() => saveBoard(), 500);
                    
                    return true;
                } else {
                    console.log('No cards found in board data');
                    updateSyncStatus(`Empty project: "${currentProject}"`, 'info');
                    return false;
                }
            } catch (error) {
                console.error('Error loading from Google Drive:', error);
                
                // If error is auth-related, clear tokens and update UI
                if (error.message.includes('Not signed in') || error.message.includes('Token refresh failed')) {
                    clearSavedTokens();
                    updateAuthStatus();
                    updateSyncStatus('Please sign in to Google Drive', 'error');
                } else {
                    updateSyncStatus('Failed to load from Drive', 'error');
                }
                return false;
            }
        }
        
        // Find existing spatial notes file in Google Drive
        async function findSpatialNotesFile() {
            try {
                const fileName = getCurrentProjectFileName();
                const params = new URLSearchParams({
                    q: `name='${fileName}' and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${params}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to search files: ${response.statusText}`);
                }
                
                const result = await response.json();
                const files = result.files;
                return files && files.length > 0 ? files[0].id : null;
            } catch (error) {
                console.error('Error searching for spatial notes file:', error);
                return null;
            }
        }
        
        // Show project manager modal
        async function showProjectManager() {
            if (!isSignedIn || !accessToken) {
                alert('Please sign in to Google Drive first!');
                return;
            }
            
            // Load latest projects
            await loadAvailableProjects();
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="closeProjectManager(event)">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation();">
                        <h2 style="margin-top: 0; text-align: center;">üìÅ Project Manager</h2>
                        
                        <div style="margin-bottom: 20px;">
                            <strong>Current Project:</strong> <span style="color: #007acc;">${currentProject}</span>
                        </div>
                        
                        <h3>Available Projects:</h3>
                        <div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
            `;
            
            if (availableProjects.length === 0) {
                html += '<p style="text-align: center; color: #666;">No projects found. Create your first project below!</p>';
            } else {
                availableProjects.forEach(project => {
                    const isCurrentProject = project.name === currentProject;
                    const date = new Date(project.lastModified).toLocaleDateString();
                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; ${isCurrentProject ? 'background: #f0f8ff;' : ''}">
                            <div>
                                <strong>${project.name}</strong> ${isCurrentProject ? '(current)' : ''}
                                <br><small style="color: #666;">Modified: ${date}</small>
                            </div>
                            <div>
                                ${!isCurrentProject ? `<button onclick="switchToProject('${project.name}')" style="margin-right: 5px; padding: 4px 8px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer;">Switch</button>` : ''}
                                <button onclick="deleteProject('${project.name}')" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    `;
                });
            }
            
            html += `
                        </div>
                        
                        <h3 style="margin-top: 25px;">Create New Project:</h3>
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <input type="text" id="newProjectName" placeholder="Project name..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button onclick="createProject()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create</button>
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button onclick="closeProjectManager()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            const modal = document.createElement('div');
            modal.id = 'projectManagerModal';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        // Close project manager modal
        function closeProjectManager(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('projectManagerModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        // Switch to project from modal
        async function switchToProject(projectName) {
            closeProjectManager();
            await switchProject(projectName);
        }
        
        // Create project from modal
        async function createProject() {
            const input = document.getElementById('newProjectName');
            const projectName = input.value.trim();
            
            if (!projectName) {
                alert('Please enter a project name!');
                return;
            }
            
            closeProjectManager();
            await createNewProject(projectName);
        }
        
        // Delete project
        async function deleteProject(projectName) {
            if (projectName === currentProject) {
                alert('Cannot delete the current project! Switch to another project first.');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete project "${projectName}"? This cannot be undone!`)) {
                return;
            }
            
            try {
                // Find and delete the project file
                const project = availableProjects.find(p => p.name === projectName);
                if (project) {
                    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${project.fileId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });
                    
                    if (response.ok) {
                        // Refresh project list and modal
                        await loadAvailableProjects();
                        closeProjectManager();
                        setTimeout(() => showProjectManager(), 100);
                        updateSyncStatus(`Deleted project: ${projectName}`, 'info');
                    } else {
                        alert('Failed to delete project: ' + response.statusText);
                    }
                }
            } catch (error) {
                console.error('Error deleting project:', error);
                alert('Error deleting project: ' + error.message);
            }
        }
        
        // Auto-sync functionality
        let autoSyncInterval;
        function startAutoSync() {
            if (!isSignedIn || !accessToken) return;
            
            // Auto-save to Drive every 30 seconds when signed in
            autoSyncInterval = setInterval(async () => {
                if (isSignedIn && accessToken) {
                    await saveToGoogleDrive();
                }
            }, 30000);
        }
        
        function stopAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
                autoSyncInterval = null;
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initCytoscape();
            loadSavedTheme(); // Load theme before anything else
            
            // Check for potential conflicts on startup
            checkStartupConflicts();
            
            // Start autosave system
            startAutosave();
            
            // Add change tracking to Cytoscape events
            cy.on('add remove position', function(evt) {
                markChanged();
            });
            
            // Also track manual edits through existing edit functions
            // (editCard, editCodeCard, etc. already call saveBoard which resets hasChanges)
            
            // Load current project from localStorage even without Google login
            const savedProject = localStorage.getItem('google_current_project');
            if (savedProject) {
                currentProject = savedProject;
                console.log(`Restored current project: ${currentProject}`);
            }
            
            // Initialize Google Drive API (wait for gapi to load)
            setTimeout(() => initializeGoogleAPI(), 3000);
            
            // Initialize project name UI
            initializeProjectName();
            
            // Enhanced save function that includes Drive sync (after original function is defined)
            setTimeout(() => {
                const originalSaveBoard = window.saveBoard;
                window.saveBoard = function() {
                    // Always save to localStorage first
                    if (originalSaveBoard) {
                        originalSaveBoard();
                    }
                    
                    // Update column view if active (for markdown and other changes)
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                    
                    // Also save to Drive if signed in
                    if (isSignedIn && accessToken) {
                        saveToGoogleDrive();
                    }
                }
            }, 100);
            
            // Auto-load from localStorage if data exists (silent load)
            setTimeout(() => {
                const savedData = localStorage.getItem('spatial-notes-board');
                if (savedData) {
                    try {
                        const boardData = JSON.parse(savedData);
                        if (boardData.cards && boardData.cards.length > 0) {
                            console.log(`Auto-loading ${boardData.cards.length} cards from localStorage...`);
                            
                            // Clear any existing content first
                            cy.nodes().remove();
                            cy.edges().remove();
                            
                            // Use the full loadBoard functionality but suppress alerts
                            const originalAlert = window.alert;
                            window.alert = () => {}; // Temporarily disable alerts
                            
                            // Manually trigger the full load process
                            loadBoardFromData(boardData);
                            
                            // Restore alert function
                            window.alert = originalAlert;
                            
                            console.log(`‚úÖ Auto-loaded ${boardData.cards.length} cards and ${(boardData.edges || []).length} edges from localStorage`);
                            
                            // Apply temporal markings after loading
                            setTimeout(() => {
                                applyTemporalMarkings();
                            }, 500);
                        }
                    } catch (e) {
                        console.log('Error auto-loading:', e);
                    }
                }
            }, 100);
            
            const searchInput = document.getElementById('searchInput');
            let searchTimeout;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    performSearch(this.value);
                }, 300);
            });
            
            // Make status info clickable to close (especially useful on mobile)
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.addEventListener('click', function() {
                this.classList.remove('visible');
            });
            
            // Clear search when input is empty
            searchInput.addEventListener('keyup', function() {
                if (!this.value.trim()) {
                    clearSearch();
                }
            });
            
            // Handle Enter key to convert search matches to selected cards
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const searchMatches = cy.$('.search-match');
                    console.log('Enter in search box, found matches by class:', searchMatches.length);
                    if (searchMatches.length > 0) {
                        // Convert search matches to selected cards
                        searchMatches.select();
                        console.log('Selected search matches, now clearing search visual');
                        
                        // Clear search visuals but keep cards selected
                        searchActive = false;
                        cy.nodes().removeClass('search-match');
                        cy.nodes().removeClass('search-non-match'); // Remove blur
                        cy.nodes().data('searchMatch', false);
                        // Don't unselect cards like clearSearch() does
                        
                        const searchInfo = document.getElementById('searchInfo');
                        searchInfo.classList.remove('visible');
                        
                        // Blur the search input so keyboard shortcuts work
                        this.blur();
                        e.preventDefault();
                    }
                }
            });
            
            // Tag filter functionality
            const tagFilterInput = document.getElementById('tagFilterInput');
            let tagFilterTimeout;
            
            tagFilterInput.addEventListener('input', function() {
                clearTimeout(tagFilterTimeout);
                tagFilterTimeout = setTimeout(() => {
                    performTagFilter(this.value);
                }, 300);
            });
            
            tagFilterInput.addEventListener('keyup', function() {
                if (!this.value.trim()) {
                    clearTagFilter();
                }
            });
            
            // Handle Enter key to convert tag filter matches to selected cards
            tagFilterInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    // For tag filtering, matches are nodes WITHOUT .tag-filtered class
                    const tagMatches = cy.nodes().not('.tag-filtered');
                    console.log('Enter in tag filter box, found tag matches:', tagMatches.length);
                    if (tagMatches.length > 0) {
                        // Convert tag filter matches to selected cards
                        tagMatches.select();
                        console.log('Selected tag filter matches, now clearing tag filter visual');
                        
                        // Clear tag filter visuals but keep cards selected
                        clearTagFilter();
                        
                        // Remove focus from input so keyboard shortcuts work
                        this.blur();
                        
                        e.preventDefault();
                    }
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Skip keyboard shortcuts if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                    return;
                }
                
                // Enkla kortkommandon (bara om inte i input-f√§lt)
                
                // N f√∂r ny anteckning (v√•r nya textarea-version)
                if (e.key === 'n' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    addNewCard();
                }
                
                // C f√∂r kopiera markerade kort
                if (e.key === 'c' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    copySelectedCards();
                }
                
                // (Delete-tangenten hanteras l√§ngre ner)
                
                // S f√∂r spara - Smart save with Google Drive integration
                if (e.key === 's' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    smartSave();
                }
                
                // L f√∂r ladda sparad br√§da
                if (e.key === 'l' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    loadBoard();
                }
                
                // F f√∂r fokusera s√∂krutan
                if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('searchInput').focus();
                }
                
                // D f√∂r Draw (toggle annotation toolbar)
                if (e.key === 'd' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    toggleAnnotationToolbar();
                }
                
                // A f√∂r Arrow (aktivera pil-verktyg direkt fr√•n vilken l√§ge som helst)
                if (e.key === 'a' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    // √ñppna toolbar om den inte √§r √∂ppen
                    if (!annotationToolbarVisible) {
                        toggleAnnotationToolbar();
                    }
                    // V√§nta en kort stund f√∂r att toolbar ska √∂ppnas, sedan aktivera arrow
                    setTimeout(() => {
                        const arrowTool = document.querySelector('[data-tool="arrow"]');
                        if (arrowTool) {
                            // Ta bort active fr√•n alla verktyg
                            document.querySelectorAll('.annotation-tool').forEach(tool => {
                                tool.classList.remove('active');
                            });
                            // Aktivera arrow tool
                            arrowTool.classList.add('active');
                            arrowTool.click();
                            console.log('‚ú® Arrow tool aktiverat med A-tangent');
                        }
                    }, 100);
                }
                
                // Ctrl+S f√∂r spara (beh√•ll som backup)
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    saveBoard();
                }
                
                // Ctrl+Z f√∂r undo - MINIMAL IMPLEMENTATION
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    if (undoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        redoStack.push(currentState);
                        
                        const previousState = undoStack.pop();
                        restoreState(previousState);
                        console.log('Undo performed');
                    }
                }
                
                // Ctrl+Y f√∂r redo - MINIMAL IMPLEMENTATION  
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    if (redoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        undoStack.push(currentState);
                        
                        const nextState = redoStack.pop();
                        restoreState(nextState);
                        console.log('Redo performed');
                    }
                }
                
                // Ctrl+O f√∂r ladda (beh√•ll som backup)
                if (e.ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    loadBoard();
                }
                
                // Multi-selection shortcuts
                // P f√∂r pin selected cards
                if (e.key === 'p' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    pinSelectedCards();
                }
                
                // U f√∂r unpin selected cards
                if (e.key === 'u' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    unpinSelectedCards();
                }
                
                // Delete f√∂r ta bort markerade kort
                if (e.key === 'Delete') {
                    e.preventDefault();
                    deleteSelectedCards();
                }
                
                // Ctrl+A f√∂r markera alla opinnde kort (pinnade kort p√•verkas inte)
                if (e.ctrlKey && e.key === 'a') {
                    e.preventDefault();
                    cy.nodes().not('.pinned').select();
                }
                
                // DEBUG: Ctrl+Shift+D f√∂r att dumpa alla kort-positioner
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    console.log('\n=== KORT POSITIONER DEBUG ===');
                    cy.nodes().forEach(node => {
                        const pos = node.position();
                        const title = node.data('title') || 'Untitled';
                        console.log(`${node.id()}: x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)} - "${title}"`);
                    });
                    console.log('=== SLUT DEBUG ===\n');
                    
                    // Visa ocks√• p√• sk√§rmen
                    const searchInfo = document.getElementById('searchInfo');
                    if (searchInfo) {
                        searchInfo.textContent = 'Kort-positioner dumpade till console (F12)';
                        searchInfo.classList.add('visible');
                        setTimeout(() => {
                            searchInfo.classList.remove('visible');
                        }, 3000);
                    }
                }
                
                // Enter f√∂r att konvertera s√∂ktr√§ffar till markerade kort
                if (e.key === 'Enter') {
                    const searchMatches = cy.$('node[searchMatch="true"]');
                    console.log('Enter pressed, found search matches:', searchMatches.length);
                    if (searchMatches.length > 0) {
                        // Konvertera s√∂ktr√§ffar till riktigt markerade kort
                        searchMatches.select();
                        console.log('Selected search matches, now clearing search');
                        // Rensa s√∂kmarkering men beh√•ll som markerade
                        clearSearch();
                        e.preventDefault();
                    }
                }
                
                // Escape f√∂r rensa s√∂kning och avmarkera alla kort
                if (e.key === 'Escape') {
                    if (cy.$('node[searchMatch="true"]').length > 0) {
                        clearSearch(); // Rensa s√∂kning
                    } else {
                        cy.nodes().unselect(); // Avmarkera alla kort
                    }
                }
                
                
                // Track keys for combination detection
                window.keysPressed = window.keysPressed || new Set();
                window.keysPressed.add(e.key.toLowerCase());
                
                // Handle G+V, G+H, G+T combinations (grid variants for selected cards)
                if (window.keysPressed.has('g') && window.keysPressed.has('v')) {
                    e.preventDefault();
                    arrangeSelectedGridVerticalColumns();
                    return;
                }
                if (window.keysPressed.has('g') && window.keysPressed.has('h')) {
                    e.preventDefault();
                    arrangeSelectedGridHorizontalPacked();
                    return;
                }
                if (window.keysPressed.has('g') && window.keysPressed.has('t')) {
                    e.preventDefault();
                    console.log('G+T pressed, mouse position:', lastMousePosition);
                    arrangeSelectedGridTopAligned();
                    return;
                }
                
                // V f√∂r vertikal kolumn (markerade kort) - only if G is not pressed
                if (e.key === 'v' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    arrangeSelectedInColumn();
                    return;
                }
                
                // H f√∂r horisontell rad top-aligned (markerade kort)  
                if (e.key === 'h' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    arrangeSelectedInRow();
                }
                
                // T f√∂r f√§rgval (markerade kort) - only if G is not pressed
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        // Create fake event with screen center position
                        const fakeEvent = {
                            clientX: window.innerWidth / 2,
                            clientY: window.innerHeight / 2
                        };
                        showColorPicker(fakeEvent, selectedNodes);
                    }
                }
                
                // Siffertangenter 1-8 f√∂r direktf√§rgning
                if (['1', '2', '3', '4', '5', '6', '7', '8'].includes(e.key) && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        e.preventDefault();
                        const colorNumber = parseInt(e.key);
                        const colorId = `card-color-${colorNumber}`;
                        console.log(`Direct color shortcut ${colorNumber}, applying to ${selectedNodes.length} cards`);
                        
                        // Apply color to all selected nodes
                        selectedNodes.forEach(node => {
                            node.data('cardColor', colorId);
                            const colorValue = getCardColorValue(colorId, getCurrentTheme());
                            node.style('background-color', colorValue);
                        });
                        
                        console.log(`Applied color ${colorNumber} to ${selectedNodes.length} cards via shortcut`);
                    }
                }
                
                // 0 f√∂r att ta bort f√§rg (√•terst√§lla)
                if (e.key === '0' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        e.preventDefault();
                        console.log(`Remove color shortcut, removing from ${selectedNodes.length} cards`);
                        
                        // Remove color from all selected nodes
                        selectedNodes.forEach(node => {
                            removeCardColor(node);
                        });
                        
                        console.log(`Removed color from ${selectedNodes.length} cards via shortcut`);
                    }
                }
                
                
                // Q toggles between cluster (ruffig) and stack (prydlig) - infinite loop
                if (e.key === 'q' && !e.ctrlKey && !e.altKey) {
                    const now = Date.now();
                    const lastQTime = window.lastQPress || 0;
                    
                    e.preventDefault();
                    
                    if (now - lastQTime < 500) {
                        // Recent Q press - toggle to the other arrangement
                        const wasCluster = window.lastQWasCluster || true;
                        if (wasCluster) {
                            console.log('Q toggle: cluster ‚Üí stack');
                            stackSelectedCards();
                            window.lastQWasCluster = false;
                        } else {
                            console.log('Q toggle: stack ‚Üí cluster');
                            clusterSelectedCards();
                            window.lastQWasCluster = true;
                        }
                        window.lastQPress = now; // Continue the chain
                    } else {
                        // First Q or timeout - always start with cluster
                        console.log('Q start: cluster');
                        clusterSelectedCards();
                        window.lastQWasCluster = true;
                        window.lastQPress = now;
                    }
                }
                
                // Alt+S f√∂r neat stack (samma som N)
                if (e.key === 's' && e.altKey && !e.ctrlKey) {
                    e.preventDefault();
                    stackSelectedCards();
                }
                
                // Gamla arrangement shortcuts 1,2,3 borttagna f√∂r f√§rgfunktionen
                // Anv√§nd ist√§llet V (kolumn), H (rad), Q (rutn√§t)
                
                // Column view specific shortcuts
                // I f√∂r importance sorting (√§ldsta datum + #todo f√∂rst) - endast i kolumnvy
                if (e.key === 'i' && !e.ctrlKey && !e.altKey && isColumnView) {
                    e.preventDefault();
                    setColumnViewSort('importance');
                }
                
                // W f√∂r background-color sorting (r√∂d‚Üíbl√•) - endast i kolumnvy
                if (e.key === 'w' && !e.ctrlKey && !e.altKey && isColumnView) {
                    e.preventDefault();
                    setColumnViewSort('background-color');
                }
                
                // M f√∂r multi-card paste (√∂ppna dialog)
                if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    showMultiCardPasteDialog();
                }
                
                // K f√∂r toggla mellan br√§d och kolumnvy
                if (e.key === 'k' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    toggleView();
                }
                
            });
            
            // Clear pressed keys on keyup for combination detection
            document.addEventListener('keyup', function(e) {
                if (window.keysPressed) {
                    window.keysPressed.delete(e.key.toLowerCase());
                }
            });
            
            // Handle mobile dropdown menus (touch/click to activate)
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                const button = dropdown.querySelector('.menu-button');
                
                button.addEventListener('click', function(e) {
                    e.stopPropagation();
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.menu-dropdown').forEach(otherDropdown => {
                        if (otherDropdown !== dropdown) {
                            otherDropdown.classList.remove('active');
                        }
                    });
                    
                    // Toggle this dropdown
                    dropdown.classList.toggle('active');
                });
                
            });
            
            // Close dropdowns when clicking inside dropdown buttons (Android fix)
            document.querySelectorAll('.dropdown-content button').forEach(button => {
                button.addEventListener('click', function(e) {
                    // Close all dropdowns when any dropdown button is clicked
                    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('active');
                    });
                });
            });
            
            // Close dropdowns when clicking outside or on cytoscape canvas
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.menu-dropdown')) {
                    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('active');
                    });
                }
            });
            
        });

        // Column View Implementation
        let isColumnView = false;
        let columnCardStates = new Map(); // Track which cards show text vs image

        function toggleView() {
            isColumnView = !isColumnView;
            const btn = document.getElementById('viewToggleBtn');
            const cyContainer = document.getElementById('cy');
            const columnContainer = document.getElementById('columnView');
            
            if (isColumnView) {
                // Switch to column view
                btn.innerHTML = 'üó∫Ô∏è Br√§dvy';
                btn.title = 'V√§xla tillbaka till br√§dvy';
                cyContainer.style.display = 'none';
                columnContainer.style.display = 'block';
                renderColumnViewDebounced();
            } else {
                // Switch to board view
                btn.innerHTML = 'üìã Kolumnvy';
                btn.title = 'V√§xla till kolumnvy';
                cyContainer.style.display = 'block';
                columnContainer.style.display = 'none';
            }
            
            // Save view state to localStorage
            localStorage.setItem('spatial-notes-view', isColumnView ? 'column' : 'board');
        }

        function convertMarkdownToHtml(text) {
            if (!text) return '';
            
            let html = text;
            // Convert markdown to HTML (opposite of what Cytoscape does)
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>'); // ### H3
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>'); // ## H2
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>'); // # H1
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // **bold**
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>'); // *italic*
            html = html.replace(/`(.*?)`/g, '<code>$1</code>'); // `code`
            html = html.replace(/~~(.*?)~~/g, '<del>$1</del>'); // ~~strikethrough~~
            // Convert markdown links [text](url) to clickable links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" style="color: #007acc; text-decoration: underline;" onclick="event.stopPropagation();">$1</a>');
            html = html.replace(/^- /gm, '‚Ä¢ '); // Convert - to bullets
            html = html.replace(/\n/g, '<br>'); // Line breaks
            
            return html;
        }

        // Debounced render to avoid excessive updates
        // Setup column view background handlers (one time only)
        let columnBackgroundHandlersSetup = false;
        function setupColumnBackgroundHandlers() {
            if (columnBackgroundHandlersSetup) return;
            columnBackgroundHandlersSetup = true;
            
            const container = document.getElementById('columnContainer');
            
            if (isMobileDevice()) {
                let columnBackgroundTimer = null;
                let columnTouchPos = null;
                
                container.addEventListener('touchstart', (e) => {
                    // Only trigger if touching the background (not a card or card content)
                    const isCard = e.target.closest('.column-card');
                    const isBackground = !isCard && (e.target === container || 
                                        e.target.classList.contains('column-view') ||
                                        e.target.classList.contains('column-container') ||
                                        e.target.id === 'columnContainer');
                    console.log('DEBUG column background touchstart:', e.target, 'isBackground:', isBackground);
                    
                    if (isBackground) {
                        e.preventDefault(); // Prevent text selection on iPad
                        columnTouchPos = { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                        console.log('DEBUG column background touch detected, pos:', columnTouchPos);
                        let backgroundTouchStartTime = Date.now();
                        
                        columnBackgroundTimer = setTimeout(() => {
                            const selectedNodes = cy.$('node:selected');
                            console.log('DEBUG column background LONG PRESS timeout fired, selected nodes:', selectedNodes.length);
                            if (selectedNodes.length > 0 && columnTouchPos) {
                                // Show mobile card menu for selected cards
                                console.log('DEBUG calling showMobileCardMenu from column background');
                                showMobileCardMenu(columnTouchPos, selectedNodes[0].id());
                            }
                        }, 750);
                        
                        // Handle short tap on background to deselect all
                        const handleBackgroundTouchEnd = (endEvent) => {
                            if (columnBackgroundTimer) {
                                clearTimeout(columnBackgroundTimer);
                                columnBackgroundTimer = null;
                            }
                            
                            const tapDuration = Date.now() - backgroundTouchStartTime;
                            console.log('DEBUG background touch end, duration:', tapDuration);
                            
                            if (tapDuration < 300) { // Short tap
                                console.log('DEBUG background short tap - deselecting all cards');
                                cy.nodes().unselect();
                                document.querySelectorAll('.column-card').forEach(card => {
                                    card.classList.remove('selected');
                                });
                            }
                            
                            columnTouchPos = null;
                            container.removeEventListener('touchend', handleBackgroundTouchEnd);
                            container.removeEventListener('touchmove', handleBackgroundTouchEnd);
                        };
                        
                        container.addEventListener('touchend', handleBackgroundTouchEnd, { once: true });
                        container.addEventListener('touchmove', handleBackgroundTouchEnd, { once: true });
                    }
                }, { passive: false });
            } else {
                // Desktop: Simple click handler for background
                container.addEventListener('click', (e) => {
                    const isCard = e.target.closest('.column-card');
                    if (!isCard) {
                        console.log('DEBUG desktop background click - deselecting all cards');
                        cy.nodes().unselect();
                        document.querySelectorAll('.column-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                    }
                });
            }
        }

        let renderColumnViewTimeout = null;
        function renderColumnView() {
            const container = document.getElementById('columnContainer');
            container.innerHTML = '';
            
            // Setup background handlers once
            setupColumnBackgroundHandlers();
            
            if (!cy) return;
            
            // Apply temporal markings before rendering
            if (typeof applyTemporalMarkings === 'function') {
                applyTemporalMarkings();
            }
            
            // Get all nodes and apply automatic sorting
            let nodes = cy.nodes().stdFilter(function(node) {
                return !node.data('isAnnotation'); // Exclude annotation nodes
            });
            
            // Apply sorting based on current sort preference
            nodes = sortColumnViewNodes(nodes);
            
            // Use document fragment for better performance
            const fragment = document.createDocumentFragment();
            nodes.forEach(node => {
                const cardDiv = createColumnCard(node);
                fragment.appendChild(cardDiv);
            });
            container.appendChild(fragment);
            
            // Apply current search highlighting
            updateColumnViewSearch();
        }
        
        function renderColumnViewDebounced() {
            if (renderColumnViewTimeout) {
                clearTimeout(renderColumnViewTimeout);
            }
            renderColumnViewTimeout = setTimeout(renderColumnView, 16); // ~60fps
        }

        // Column view sorting function
        let currentColumnSort = 'creation'; // default sort
        function sortColumnViewNodes(nodes) {
            const nodeArray = nodes.toArray();
            
            switch(currentColumnSort) {
                case 'alphabetical':
                    return nodeArray.sort((a, b) => {
                        const aText = (a.data('title') || a.data('text') || '').toLowerCase();
                        const bText = (b.data('title') || b.data('text') || '').toLowerCase();
                        return aText.localeCompare(bText);
                    });
                
                case 'reverse-alphabetical':
                    return nodeArray.sort((a, b) => {
                        const aText = (a.data('title') || a.data('text') || '').toLowerCase();
                        const bText = (b.data('title') || b.data('text') || '').toLowerCase();
                        return bText.localeCompare(aText);
                    });
                
                case 'creation':
                    return nodeArray.sort((a, b) => {
                        // Sort by ID (assuming timestamp-based IDs)
                        return a.id().localeCompare(b.id());
                    });
                
                case 'reverse-creation':
                    return nodeArray.sort((a, b) => {
                        return b.id().localeCompare(a.id());
                    });
                
                case 'tags':
                    return nodeArray.sort((a, b) => {
                        const aTags = (a.data('tags') || []).join(' ').toLowerCase();
                        const bTags = (b.data('tags') || []).join(' ').toLowerCase();
                        return aTags.localeCompare(bTags);
                    });

                case 'color':
                    return nodeArray.sort((a, b) => {
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Same color order as background-color: r√∂d, orange, gul, lila, bl√•, vit, gr√∂n, gr√•
                        const colorOrder = {
                            'card-color-3': 1, // r√∂d
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // bl√•
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // gr√∂n
                            'card-color-7': 8, // gr√•
                            '': 9              // of√§rgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        return aPriority - bPriority;
                    });

                case 'tagged-date':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '999999'; // No date = last
                        const bDate = bDateMatch ? bDateMatch[1] : '999999';
                        
                        return aDate.localeCompare(bDate);
                    });

                case 'reverse-tagged-date':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '000000'; // No date = first
                        const bDate = bDateMatch ? bDateMatch[1] : '000000';
                        
                        return bDate.localeCompare(aDate);
                    });

                case 'importance':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        const aTags = a.data('tags') || [];
                        const bTags = b.data('tags') || [];
                        
                        // Check for search matches OR selected cards (after Enter)
                        const aIsSearchMatch = a.hasClass('search-match') || a.data('searchMatch') || a.selected();
                        const bIsSearchMatch = b.hasClass('search-match') || b.data('searchMatch') || b.selected();
                        
                        // Prioritize search matches and selected cards
                        if (aIsSearchMatch && !bIsSearchMatch) return -1;
                        if (!aIsSearchMatch && bIsSearchMatch) return 1;
                        
                        // Check for #todo tag
                        const aHasTodo = aTags.some(tag => tag.toLowerCase() === 'todo');
                        const bHasTodo = bTags.some(tag => tag.toLowerCase() === 'todo');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '999999'; // No date = last
                        const bDate = bDateMatch ? bDateMatch[1] : '999999';
                        
                        // Priority: oldest date + #todo first, then by date, then no date
                        if (aHasTodo && !bHasTodo) return -1; // a has todo, b doesn't
                        if (!aHasTodo && bHasTodo) return 1;  // b has todo, a doesn't
                        
                        // Both have todo or both don't have todo - sort by date (oldest first)
                        return aDate.localeCompare(bDate);
                    });

                case 'background-color':
                    return nodeArray.sort((a, b) => {
                        // Check for search matches OR selected cards (after Enter)
                        const aIsSearchMatch = a.hasClass('search-match') || a.data('searchMatch') || a.selected();
                        const bIsSearchMatch = b.hasClass('search-match') || b.data('searchMatch') || b.selected();
                        
                        // Prioritize search matches and selected cards
                        if (aIsSearchMatch && !bIsSearchMatch) return -1;
                        if (!aIsSearchMatch && bIsSearchMatch) return 1;
                        
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Color priority: r√∂d, orange, gul, lila, bl√•, vit, gr√∂n, gr√•
                        const colorOrder = {
                            'card-color-3': 1, // r√∂d
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // bl√•
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // gr√∂n
                            'card-color-7': 8, // gr√•
                            '': 9              // of√§rgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        
                        return aPriority - bPriority;
                    });
                
                default:
                    return nodeArray;
            }
        }

        // Function to change column view sorting
        function setColumnViewSort(sortType) {
            currentColumnSort = sortType;
            console.log('Column view sort set to:', sortType);
            
            if (isColumnView) {
                renderColumnViewDebounced();
                
                // Show feedback
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    let sortName = 'Ok√§nd sortering';
                    switch(sortType) {
                        case 'alphabetical': sortName = 'A ‚Üí Z'; break;
                        case 'reverse-alphabetical': sortName = 'Z ‚Üí A'; break;
                        case 'creation': sortName = '√Ñldst ‚Üí Nyast'; break;
                        case 'reverse-creation': sortName = 'Nyast ‚Üí √Ñldst'; break;
                        case 'tags': sortName = 'Sorterat efter taggar'; break;
                        case 'color': sortName = 'F√§rg 1‚Üí6'; break;
                        case 'tagged-date': sortName = '@datum √Ñldst ‚Üí Nyast'; break;
                        case 'reverse-tagged-date': sortName = '@datum Nyast ‚Üí √Ñldst'; break;
                        case 'importance': sortName = 'Viktighet (√§ldsta #todo f√∂rst)'; break;
                        case 'background-color': sortName = 'Bakgrundsf√§rg (r√∂d‚Üígr√•)'; break;
                    }
                    statusDiv.textContent = `Kolumnvy sorterad: ${sortName}`;
                    statusDiv.classList.add('visible');
                    
                    // Auto-hide after 3 seconds
                    setTimeout(() => {
                        statusDiv.classList.remove('visible');
                    }, 3000);
                }
            }
            
            // Close sort menu
            closeSortMenu();
        }

        function createColumnCard(node) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'column-card';
            cardDiv.dataset.nodeId = node.id();
            
            // Apply current state classes
            if (node.hasClass('search-match')) {
                cardDiv.classList.add('search-match');
            }
            if (node.selected()) {
                cardDiv.classList.add('selected');
            }
            
            // Apply card color if it exists
            const cardColor = node.data('cardColor');
            if (cardColor) {
                const currentTheme = getCurrentTheme();
                const color = getCardColorValue(cardColor, currentTheme);
                if (color) {
                    cardDiv.style.backgroundColor = color;
                }
            }

            // Apply temporal markings if they exist
            const temporalBorderWidth = node.data('temporalBorderWidth');
            const temporalBorderColor = node.data('temporalBorderColor');
            if (temporalBorderWidth && temporalBorderColor) {
                cardDiv.style.borderWidth = temporalBorderWidth + 'px';
                cardDiv.style.borderColor = temporalBorderColor;
                cardDiv.style.borderStyle = 'solid';
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'column-card-content';
            
            // Check if card should show image or text
            const nodeId = node.id();
            const showText = columnCardStates.get(nodeId) || false;
            const hasImage = node.data('imageData');
            
            if (hasImage && !showText) {
                // Show image ONLY - no text/annotation in image mode
                const img = document.createElement('img');
                img.src = node.data('imageData');
                img.className = 'column-card-image';
                img.alt = node.data('originalFileName') || 'Bild';
                contentDiv.appendChild(img);
            } else if (hasImage && showText) {
                // Show text/annotation ONLY - no image in text mode
                const annotation = node.data('annotation');
                if (annotation) {
                    const displayText = convertMarkdownToHtml(annotation);
                    contentDiv.innerHTML = displayText;
                }
            } else {
                // Show text content
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const isManualCard = node.data('isManualCard') || false;
                
                let displayText = '';
                if (title && !isManualCard) {
                    displayText = `<strong>${title}</strong><br><br>`;
                }
                displayText += convertMarkdownToHtml(text);
                
                contentDiv.innerHTML = displayText;
            }
            
            // Add tags
            const tags = node.data('tags') || [];
            if (tags.length > 0) {
                const visibleTags = tags.filter(tag => {
                    const pdfPattern = /^[A-Za-z\-]+\-\d{4}\-[a-z\-]+$/;
                    return !pdfPattern.test(tag);
                });
                
                if (visibleTags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'column-card-tags';
                    visibleTags.forEach(tag => {
                        const tagSpan = document.createElement('span');
                        tagSpan.className = 'tag';
                        tagSpan.textContent = '#' + tag;
                        tagsDiv.appendChild(tagSpan);
                    });
                    contentDiv.appendChild(tagsDiv);
                }
            }
            
            // Create wrapper for content and selection area
            const cardWrapper = document.createElement('div');
            cardWrapper.style.cssText = `
                display: flex;
                width: 100%;
                min-height: 100%;
            `;
            
            // Content takes most of the space
            contentDiv.style.cssText = `
                flex: 1;
                min-width: 0;
                user-select: text;
                -webkit-user-select: text;
            `;
            
            // Create selection area on the right (40px wide)
            const selectionArea = document.createElement('div');
            selectionArea.className = 'column-card-selection-area';
            selectionArea.style.cssText = `
                width: 40px;
                min-height: 60px;
                background: transparent;
                cursor: pointer;
                flex-shrink: 0;
                user-select: none;
                -webkit-user-select: none;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0.3;
                transition: opacity 0.2s;
            `;
            
            // Add visual indicator that changes based on selection state
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                width: 12px; 
                height: 12px; 
                border-radius: 50%; 
                border: 2px solid currentColor;
                background: ${node.selected() ? 'currentColor' : 'transparent'};
                transition: all 0.2s;
            `;
            selectionArea.appendChild(indicator);
            
            // Update indicator when selection changes
            const updateIndicator = () => {
                if (cardDiv.classList.contains('selected')) {
                    indicator.style.background = 'currentColor';
                    selectionArea.style.opacity = '0.8';
                } else {
                    indicator.style.background = 'transparent';
                    selectionArea.style.opacity = '0.3';
                }
            };
            
            // Initial state
            updateIndicator();
            
            // Hover effect for desktop
            selectionArea.addEventListener('mouseenter', () => {
                selectionArea.style.opacity = '0.8';
            });
            selectionArea.addEventListener('mouseleave', updateIndicator);
            
            cardWrapper.appendChild(contentDiv);
            cardWrapper.appendChild(selectionArea);
            cardDiv.appendChild(cardWrapper);
            
            // Add selection click handler to the selection area
            selectionArea.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                console.log('DEBUG selection area click:', node.id(), 'isMobileDevice():', isMobileDevice());
                console.log('DEBUG mobile tap -> toggleColumnCardSelection');
                toggleColumnCardSelection(node.id(), cardDiv);
            });
            
            // Add click handlers for content area (desktop functionality)
            contentDiv.addEventListener('click', (e) => {
                if (!isMobileDevice()) {
                    console.log('DEBUG content area click (desktop):', node.id(), 'ctrlKey:', e.ctrlKey, 'metaKey:', e.metaKey);
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+click for multi-select (desktop)
                        console.log('DEBUG ctrl+click -> toggleColumnCardSelection');
                        toggleColumnCardSelection(node.id(), cardDiv);
                    } else if (hasImage) {
                        // Desktop: Toggle between image and text for image cards
                        const currentState = columnCardStates.get(nodeId) || false;
                        columnCardStates.set(nodeId, !currentState);
                        
                        // Re-render just this card
                        const newCard = createColumnCard(node);
                        cardDiv.parentNode.replaceChild(newCard, cardDiv);
                    } else {
                        // Desktop: Select single card
                        selectColumnCard(node.id(), cardDiv);
                    }
                }
                // On mobile, content area clicks do nothing (avoid text selection conflicts)
            });
            
            // Add double-click handler for editing
            cardDiv.addEventListener('dblclick', (e) => {
                e.preventDefault();
                editCard(node); // Reuse existing edit function
            });

            // Add right-click context menu
            cardDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showColumnContextMenu(e, node.id());
            });
            
            // Add iPad/mobile long-press functionality for tagging and color change
            let longPressTimer = null;
            let touchStartTime = 0;
            let touchMoved = false;
            
            cardDiv.addEventListener('touchstart', (e) => {
                console.log('DEBUG column touchstart:', node.id(), 'touches:', e.touches?.length);
                touchStartTime = Date.now();
                touchMoved = false;
                
                // Set up long press detection (800ms)
                longPressTimer = setTimeout(() => {
                    console.log('DEBUG column long press timeout fired, touchMoved:', touchMoved);
                    if (!touchMoved) {
                        e.preventDefault();
                        // Show combined tag/color context menu for iPad
                        console.log('DEBUG calling showMobileCardMenu from column long press:', e.touches[0], node.id());
                        showMobileCardMenu(e.touches[0], node.id());
                    }
                }, 800);
            }, { passive: false });
            
            cardDiv.addEventListener('touchmove', () => {
                touchMoved = true;
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
            
            cardDiv.addEventListener('touchend', (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // If it was a quick tap (< 200ms) and didn't move, treat as normal click
                if (!touchMoved && (Date.now() - touchStartTime) < 200) {
                    // Trigger normal click behavior
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        clientX: e.changedTouches[0].clientX,
                        clientY: e.changedTouches[0].clientY
                    });
                    cardDiv.dispatchEvent(clickEvent);
                }
            });
            
            return cardDiv;
        }

        // Mobile/iPad context menu with tagging and color options
        function showMobileCardMenu(touch, nodeId) {
            console.log('DEBUG showMobileCardMenu called with touch:', touch, 'nodeId:', nodeId);
            // Remove any existing mobile menu
            const existingMenu = document.getElementById('mobileCardMenu');
            if (existingMenu) {
                document.body.removeChild(existingMenu);
                console.log('DEBUG removed existing menu');
            }
            
            const node = cy.getElementById(nodeId);
            
            // Ensure the target node is selected for tag operations
            if (!node.selected()) {
                console.log('DEBUG target node not selected, selecting it');
                node.select();
                // Update column view visual selection
                if (isColumnView) {
                    const cardDiv = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (cardDiv) {
                        cardDiv.classList.add('selected');
                    }
                }
            }
            
            const selectedNodes = cy.$('node:selected');
            const isMultipleSelected = selectedNodes.length > 1;
            const targetNodes = isMultipleSelected ? selectedNodes : cy.$(`#${nodeId}`);
            console.log('DEBUG node found:', !!node, 'selectedNodes.length:', selectedNodes.length, 'isMultipleSelected:', isMultipleSelected);
            
            // Create mobile menu
            const menu = document.createElement('div');
            menu.id = 'mobileCardMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${Math.min(touch.clientX, window.innerWidth - 280)}px;
                top: ${Math.min(touch.clientY, window.innerHeight - 400)}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 260px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 16px;
                padding: 12px 0;
            `;
            
            const targetText = isMultipleSelected ? `${selectedNodes.length} kort` : '1 kort';
            
            menu.innerHTML = `
                <div style="padding: 8px 16px; font-weight: bold; color: #666; border-bottom: 1px solid #eee;">
                    ${targetText}
                </div>
                
                <!-- Color Section -->
                <div style="padding: 12px 16px; border-bottom: 1px solid #eee;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #333;">F√§rg</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;" id="mobileColorGrid">
                    </div>
                    <div style="margin-top: 8px;">
                        <div class="mobile-clear-color" style="background: #f5f5f5; padding: 6px 12px; border-radius: 16px; text-align: center; cursor: pointer; border: 1px solid #ddd;">Ta bort f√§rg</div>
                    </div>
                </div>
                
                <!-- Tags Section -->
                <div style="padding: 12px 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #333;">Taggar</div>
                    <div class="mobile-menu-item" data-action="add-tag" style="padding: 8px 12px; cursor: pointer; border-radius: 8px; margin-bottom: 4px;">‚ûï L√§gg till tagg</div>
                    <div class="mobile-menu-item" data-action="remove-tag" style="padding: 8px 12px; cursor: pointer; border-radius: 8px;">‚ûñ Ta bort tagg</div>
                </div>
            `;
            
            document.body.appendChild(menu);
            
            // Create color dots dynamically with real colors
            const colorGrid = menu.querySelector('#mobileColorGrid');
            const currentTheme = getCurrentTheme();
            
            for (let i = 1; i <= 8; i++) {
                const colorValue = getCardColorValue(`card-color-${i}`, currentTheme);
                const colorDot = document.createElement('div');
                colorDot.className = 'mobile-color-dot';
                colorDot.dataset.color = i;
                colorDot.style.cssText = `
                    background: ${colorValue};
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    color: ${currentTheme === 'light' ? '#333' : '#fff'};
                    cursor: pointer;
                    border: 2px solid #ddd;
                `;
                colorDot.textContent = i;
                colorGrid.appendChild(colorDot);
            }
            
            // Add color click handlers
            menu.querySelectorAll('.mobile-color-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    const colorNum = dot.dataset.color;
                    const colorId = `card-color-${colorNum}`;
                    
                    targetNodes.forEach(node => {
                        node.data('cardColor', colorId);
                        const colorValue = getCardColorValue(colorId, getCurrentTheme());
                        node.style('background-color', colorValue);
                    });
                    
                    // Update column view if active
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                    
                    // Show feedback
                    const statusDiv = document.getElementById('selectionInfo');
                    if (statusDiv) {
                        statusDiv.textContent = `F√§rgade ${targetNodes.length} kort med f√§rg ${colorNum}`;
                        statusDiv.classList.add('visible');
                        setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                    }
                    
                    document.body.removeChild(menu);
                });
            });
            
            // Clear color handler
            menu.querySelector('.mobile-clear-color').addEventListener('click', () => {
                targetNodes.forEach(node => {
                    removeCardColor(node);
                });
                
                if (isColumnView) {
                    renderColumnViewDebounced();
                }
                
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Tog bort f√§rg fr√•n ${targetNodes.length} kort`;
                    statusDiv.classList.add('visible');
                    setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                }
                
                document.body.removeChild(menu);
            });
            
            // Tag action handlers
            menu.querySelectorAll('.mobile-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    console.log('DEBUG mobile menu item clicked:', action);
                    if (action === 'add-tag') {
                        console.log('DEBUG calling addTagToSelected from mobile menu');
                        addTagToSelected();
                    } else if (action === 'remove-tag') {
                        console.log('DEBUG calling removeTagFromSelected from mobile menu');
                        removeTagFromSelected();
                    }
                    document.body.removeChild(menu);
                });
            });
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', closeHandler);
                        document.removeEventListener('touchstart', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
                document.addEventListener('touchstart', closeHandler);
            }, 100);
        }

        function toggleColumnCardSelection(nodeId, cardDiv) {
            const node = cy.getElementById(nodeId);
            console.log('DEBUG toggleColumnCardSelection:', nodeId, 'was selected:', node.selected());
            if (node.selected()) {
                node.unselect();
                cardDiv.classList.remove('selected');
                console.log('DEBUG unselected', nodeId);
            } else {
                node.select();
                cardDiv.classList.add('selected');
                console.log('DEBUG selected', nodeId);
            }
            console.log('DEBUG total selected after toggle:', cy.$('node:selected').length);
        }

        function selectColumnCard(nodeId, cardDiv) {
            console.log('DEBUG selectColumnCard called:', nodeId, 'clearing all selections first');
            // Deselect all
            cy.nodes().unselect();
            document.querySelectorAll('.column-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Select this one
            const node = cy.getElementById(nodeId);
            node.select();
            cardDiv.classList.add('selected');
            console.log('DEBUG selectColumnCard completed, selected:', nodeId, 'total selected:', cy.$('node:selected').length);
        }

        function updateColumnViewSearch() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                
                if (node.hasClass('search-match')) {
                    cardDiv.classList.add('search-match');
                } else {
                    cardDiv.classList.remove('search-match');
                }
            });
        }

        function getCurrentTheme() {
            if (document.body.classList.contains('dark-theme')) return 'dark';
            if (document.body.classList.contains('sepia-theme')) return 'sepia';
            return 'light';
        }

        // Hook into existing search functions to update column view
        const originalPerformSearch = performSearch;
        performSearch = function(query) {
            const result = originalPerformSearch.call(this, query);
            updateColumnViewSearch();
            return result;
        };

        const originalClearSearch = clearSearch;
        clearSearch = function() {
            const result = originalClearSearch.call(this);
            updateColumnViewSearch();
            return result;
        };

        const originalPerformTagFilter = performTagFilter;
        performTagFilter = function() {
            const result = originalPerformTagFilter.apply(this, arguments);
            updateColumnViewSearch();
            return result;
        };

        const originalClearTagFilter = clearTagFilter;
        clearTagFilter = function() {
            const result = originalClearTagFilter.call(this);
            updateColumnViewSearch();
            return result;
        };

        // Function to update column view colors immediately
        function updateColumnViewColors() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                const cardColor = node.data('cardColor');
                
                if (cardColor) {
                    const currentTheme = getCurrentTheme();
                    const color = getCardColorValue(cardColor, currentTheme);
                    if (color) {
                        cardDiv.style.backgroundColor = color;
                    }
                } else {
                    // Remove background color if no card color
                    cardDiv.style.backgroundColor = '';
                }
            });
        }

        // Function to update column view selections
        function updateColumnViewSelections() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                
                if (node.selected()) {
                    cardDiv.classList.add('selected');
                } else {
                    cardDiv.classList.remove('selected');
                }
            });
        }

        // Hook into color functions - need to find where colors are applied
        // Override the color application functions to update column view
        setTimeout(() => {
            // Hook into the existing color functions after they're defined
            if (typeof applyColorToNodes === 'function') {
                const originalApplyColorToNodes = applyColorToNodes;
                applyColorToNodes = function() {
                    const result = originalApplyColorToNodes.apply(this, arguments);
                    updateColumnViewColors();
                    return result;
                };
            }

            // Hook into removeCardColor function
            if (typeof removeCardColor === 'function') {
                const originalRemoveCardColor = removeCardColor;
                removeCardColor = function(node) {
                    const result = originalRemoveCardColor.call(this, node);
                    updateColumnViewColors();
                    return result;
                };
            }

            // Hook into direct style updates via Cytoscape events
            if (cy) {
                cy.on('style', function(evt) {
                    // Update column view when any node style changes
                    setTimeout(updateColumnViewColors, 10);
                });
                
                cy.on('data', function(evt) {
                    // Update column view when node data changes (like cardColor)
                    setTimeout(updateColumnViewColors, 10);
                });

                // Hook into selection events
                cy.on('select unselect', function(evt) {
                    // Update column view when selections change
                    setTimeout(updateColumnViewSelections, 10);
                });

                // Hook into add/remove events to re-render column view
                cy.on('add remove', function(evt) {
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                });
            }
        }, 500);

        // Restore view state on page load
        setTimeout(() => {
            const savedView = localStorage.getItem('spatial-notes-view');
            if (savedView === 'column' && !isColumnView) {
                toggleView(); // Switch to column view if it was saved
            }
        }, 1000); // Wait a bit longer to ensure everything is initialized

        // Function to update column view for specific node after text changes
        function updateColumnViewCard(nodeId) {
            if (!isColumnView) return;
            
            const cardDiv = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (cardDiv) {
                const node = cy.getElementById(nodeId);
                const newCard = createColumnCard(node);
                cardDiv.parentNode.replaceChild(newCard, cardDiv);
            }
        }

        // Hook into edit dialogs to update column view on text changes
        // We'll monitor for text changes in edit dialogs
        let editDialogObserver = null;
        function watchEditDialogs() {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Check if edit dialog was added
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1 && node.querySelector && node.querySelector('textarea')) {
                                const textarea = node.querySelector('textarea');
                                const nodeId = node.dataset?.nodeId || getEditingNodeId();
                                
                                if (textarea && nodeId && isColumnView) {
                                    // Add input listener to textarea
                                    textarea.addEventListener('input', function() {
                                        // Update node data temporarily for preview
                                        const cyNode = cy.getElementById(nodeId);
                                        if (cyNode) {
                                            cyNode.data('text', this.value);
                                            setTimeout(() => updateColumnViewCard(nodeId), 10);
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            return observer;
        }

        // Helper function to get currently editing node ID (best effort)
        function getEditingNodeId() {
            // Try to find the node being edited by looking for selected nodes
            const selected = cy.$('node:selected');
            return selected.length > 0 ? selected[0].id() : null;
        }

        // Start watching for edit dialogs
        setTimeout(() => {
            editDialogObserver = watchEditDialogs();
        }, 2000);

        // Column view context menu
        function showColumnContextMenu(e, nodeId) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('columnContextMenu');
            if (existingMenu) {
                document.body.removeChild(existingMenu);
            }

            const selectedNodes = cy.$('node:selected');
            const isMultipleSelected = selectedNodes.length > 1;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'columnContextMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                min-width: 150px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
            `;

            const targetText = isMultipleSelected ? `${selectedNodes.length} kort` : '1 kort';

            menu.innerHTML = `
                <div style="padding: 8px 0; border-bottom: 1px solid #eee;">
                    <div style="padding: 4px 12px; font-weight: bold; color: #666;">Taggar f√∂r ${targetText}</div>
                </div>
                <div style="padding: 4px 0;">
                    <div class="context-menu-item" onclick="addTagToSelected()" style="padding: 8px 12px; cursor: pointer;">‚ûï L√§gg till tagg</div>
                    <div class="context-menu-item" onclick="removeTagFromSelected()" style="padding: 8px 12px; cursor: pointer;">‚ûñ Ta bort tagg</div>
                </div>
                <div style="padding: 8px 0; border-top: 1px solid #eee;">
                    <div style="padding: 4px 12px; font-weight: bold; color: #666;">F√§rger f√∂r ${targetText}</div>
                </div>
                <div style="padding: 4px 0;">
                    <div class="context-menu-item" onclick="showColumnColorPicker(event, '${nodeId}')" style="padding: 8px 12px; cursor: pointer;">üé® F√§rga kort</div>
                    <div class="context-menu-item" onclick="removeColorFromSelected()" style="padding: 8px 12px; cursor: pointer;">‚ùå Ta bort f√§rg</div>
                </div>
            `;

            // Add hover effects to menu items
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#f0f0f0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '';
                });
            });

            document.body.appendChild(menu);

            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    document.body.removeChild(menu);
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 10);
        }

        // Add tag to selected cards
        function addTagToSelected() {
            const selectedNodes = cy.$('node:selected');
            console.log('DEBUG addTagToSelected called, selected nodes:', selectedNodes.length);
            if (selectedNodes.length === 0) return;

            // Create iPad-friendly tag input dialog
            console.log('DEBUG calling showTagInputDialog');
            showTagInputDialog((tagName) => {
                if (!tagName || !tagName.trim()) return;

                const cleanTag = tagName.trim().replace(/^#/, ''); // Remove # if present

                selectedNodes.forEach(node => {
                    const currentTags = node.data('tags') || [];
                    if (!currentTags.includes(cleanTag)) {
                        currentTags.push(cleanTag);
                        node.data('tags', currentTags);
                    }
                });

                // Save and update views
                saveBoard();
                if (isColumnView) {
                    renderColumnViewDebounced();
                }
                
                // Show feedback
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Lade till tagg "${cleanTag}" p√• ${selectedNodes.length} kort`;
                    statusDiv.classList.add('visible');
                    setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                }
            });
        }

        // iPad-friendly tag input dialog
        function showTagInputDialog(callback) {
            console.log('DEBUG showTagInputDialog called');
            // Remove any existing dialog
            const existingDialog = document.querySelector('.tag-input-dialog');
            if (existingDialog) {
                existingDialog.remove();
                console.log('DEBUG removed existing tag dialog');
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'tag-input-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                width: 90%;
                max-width: 400px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">L√§gg till tagg</h3>
                <input type="text" id="tagNameInput" placeholder="Taggnamn (utan #)" style="
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #ddd;
                    border-radius: 8px;
                    font-size: 16px;
                    box-sizing: border-box;
                    margin-bottom: 15px;
                " />
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelTagInput" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">Avbryt</button>
                    <button id="confirmTagInput" style="
                        padding: 10px 20px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">L√§gg till</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('DEBUG tag input dialog added to DOM');
            
            // Focus input
            const input = document.getElementById('tagNameInput');
            setTimeout(() => input.focus(), 100);
            
            // Event handlers
            const cleanup = () => {
                console.log('DEBUG tag dialog cleanup called');
                overlay.remove();
            };
            
            document.getElementById('cancelTagInput').onclick = () => {
                console.log('DEBUG cancel tag button clicked');
                cleanup();
            };
            
            document.getElementById('confirmTagInput').onclick = () => {
                const tagName = input.value.trim();
                console.log('DEBUG confirm tag button clicked, tagName:', tagName);
                cleanup();
                if (callback) callback(tagName);
            };
            
            // Enter key to confirm
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const tagName = input.value.trim();
                    cleanup();
                    if (callback) callback(tagName);
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    cleanup();
                }
            });
        }

        // Remove tag from selected cards
        function removeTagFromSelected() {
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length === 0) return;

            // Collect all unique tags from selected nodes
            const allTags = new Set();
            selectedNodes.forEach(node => {
                const tags = node.data('tags') || [];
                tags.forEach(tag => allTags.add(tag));
            });

            if (allTags.size === 0) {
                alert('Inga taggar hittades p√• de markerade korten.');
                return;
            }

            const tagList = Array.from(allTags).sort();
            
            // Show iPad-friendly tag selection dialog
            showTagSelectionDialog(tagList, (selectedTag) => {
                if (!selectedTag) return;

                const cleanTag = selectedTag.trim().replace(/^#/, '');

                let removedCount = 0;
                selectedNodes.forEach(node => {
                    const currentTags = node.data('tags') || [];
                    const filteredTags = currentTags.filter(tag => tag !== cleanTag);
                    if (filteredTags.length !== currentTags.length) {
                        node.data('tags', filteredTags);
                        removedCount++;
                    }
                });

                if (removedCount > 0) {
                    // Save and update views
                    saveBoard();
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                    
                    // Show feedback
                    const statusDiv = document.getElementById('selectionInfo');
                    if (statusDiv) {
                        statusDiv.textContent = `Tog bort tagg "${cleanTag}" fr√•n ${removedCount} kort`;
                        statusDiv.classList.add('visible');
                        setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                    }
                } else {
                    alert(`Taggen "${cleanTag}" hittades inte p√• de markerade korten.`);
                }
            });
        }

        // iPad-friendly tag selection dialog
        function showTagSelectionDialog(tagList, callback) {
            // Remove any existing dialog
            const existingDialog = document.querySelector('.tag-selection-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'tag-selection-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                width: 90%;
                max-width: 400px;
                max-height: 70vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">Ta bort tagg</h3>
                <p style="margin: 0 0 15px 0; color: #666; text-align: center; font-size: 14px;">
                    V√§lj vilken tagg som ska tas bort:
                </p>
                <div id="tagSelectionList" style="margin-bottom: 15px;">
                    ${tagList.map(tag => `
                        <div class="tag-selection-item" data-tag="${tag}" style="
                            padding: 12px;
                            border: 1px solid #ddd;
                            border-radius: 8px;
                            margin-bottom: 8px;
                            cursor: pointer;
                            background: #f8f9fa;
                            text-align: center;
                            font-size: 16px;
                        ">${tag}</div>
                    `).join('')}
                </div>
                <div style="text-align: center;">
                    <button id="cancelTagSelection" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">Avbryt</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Event handlers
            const cleanup = () => {
                overlay.remove();
            };
            
            // Tag selection handlers
            overlay.querySelectorAll('.tag-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const selectedTag = item.dataset.tag;
                    cleanup();
                    if (callback) callback(selectedTag);
                });
                
                // Hover effects
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#e9ecef';
                    item.style.borderColor = '#007bff';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '#f8f9fa';
                    item.style.borderColor = '#ddd';
                });
            });
            
            document.getElementById('cancelTagSelection').onclick = cleanup;
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    cleanup();
                }
            });
        }

        // Show color picker for column view cards
        function showColumnColorPicker(event, nodeId) {
            // Close context menu first
            const menu = document.getElementById('columnContextMenu');
            if (menu) document.body.removeChild(menu);

            // Get the clicked node and selected nodes
            const clickedNode = cy.getElementById(nodeId);
            const selectedNodes = cy.$('node:selected');
            
            // Determine nodes to color - same logic as regular context menu
            const nodesToColor = clickedNode.selected() && selectedNodes.length > 1 ? selectedNodes : [clickedNode];
            
            // Create a fake event object for showColorPicker
            const fakeEvent = {
                clientX: event.clientX || window.innerWidth / 2,
                clientY: event.clientY || window.innerHeight / 2,
                pageX: event.pageX || window.innerWidth / 2,
                pageY: event.pageY || window.innerHeight / 2
            };
            
            // Use the existing color picker
            showColorPicker(fakeEvent, nodesToColor);
        }

        // Remove color from selected cards in column view
        function removeColorFromSelected() {
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length === 0) return;

            selectedNodes.forEach(node => {
                removeCardColor(node);
            });

            // Save and update views
            saveBoard();
            if (isColumnView) {
                renderColumnViewDebounced();
            }

            // Close context menu
            const menu = document.getElementById('columnContextMenu');
            if (menu) document.body.removeChild(menu);
        }
    </script>

</body>
</html>