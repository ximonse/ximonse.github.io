<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Notes - Sök och Klunga</title>
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
    <!-- Removed Konva - not needed for simple resize system -->
    <!-- Removed problematic node-editing extension -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }
        
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: transparent;
            border-bottom: 1px solid rgba(221, 221, 221, 0.2);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 10000;
            opacity: 0.8;
            gap: 5px;
        }
        
        .search-box {
            flex: 1;
            max-width: 280px;
            margin-right: 40px;
        }
        
        .tag-filter-box {
            flex: 0.7;
            max-width: 200px;
            margin-right: 25px;
        }
        
        
        .tag-filter-input {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #495057;
            box-sizing: border-box;
        }
        
        .tag-filter-input:focus {
            border-color: #adb5bd;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
        }
        
        .layout-selector {
            flex: 0.5;
            margin-right: 20px;
        }
        
        .layout-selector select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #495057;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #adb5bd;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
        }
        
        /* Unified Toolbar Button Styling */
        .toolbar-btn {
            background: linear-gradient(145deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(145deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .toolbar-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .search-select-btn {
            margin-left: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .add-card-btn {
            padding: 10px 20px;
            border-radius: 20px;
        }
        
        /* Project Selector Styling */
        .project-selector {
            position: relative;
            display: inline-block;
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .project-button {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(145deg, #007acc 0%, #005a9e 100%);
            color: white;
            border: 1px solid #005a9e;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 122, 204, 0.2);
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .project-button:hover {
            background: linear-gradient(145deg, #005a9e 0%, #004578 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 204, 0.3);
        }
        
        .project-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 122, 204, 0.2);
        }
        
        .project-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            min-width: 220px;
            display: none;
            margin-top: 2px;
        }
        
        .project-dropdown.show {
            display: block;
        }
        
        .project-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #495057;
            transition: background-color 0.2s ease;
        }
        
        .project-dropdown-item:hover {
            background: #f8f9fa;
        }
        
        .project-dropdown-item:last-child {
            border-bottom: none;
        }
        
        .project-dropdown-item.active {
            background: #e3f2fd;
            color: #1976d2;
            font-weight: 500;
        }
        
        
        .menu-dropdown {
            position: relative;
            display: inline-block;
        }
        
        
        
        .menu-button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background: rgba(255, 255, 255, 0.75);
            min-width: 220px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            z-index: 10000;
            border: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .dropdown-content button {
            background: none;
            border: none;
            color: #2d3748;
            padding: 10px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: 0;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .dropdown-content button:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .dropdown-content button:last-child {
            border-radius: 0 0 8px 8px;
        }
        
        .dropdown-content button:hover {
            background: linear-gradient(90deg, #f7fafc 0%, #edf2f7 100%);
            color: #1a202c;
            transform: translateX(2px);
        }
        
        .dropdown-content button:active {
            background: linear-gradient(90deg, #e2e8f0 0%, #cbd5e0 100%);
        }
        
        .menu-dropdown:hover .dropdown-content,
        .menu-dropdown.active .dropdown-content,
        .dropdown-content:hover {
            display: block;
        }
        
        /* Ensure the dropdown stays open when hovering the content area */
        .menu-dropdown {
            position: relative;
        }
        
        .dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
        }
        
        /* On desktop, keep hover behavior smooth */
        @media (min-width: 769px) {
            .menu-dropdown:hover .dropdown-content {
                display: block;
            }
        }
        
        #cy {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            transition: left 0.3s ease;
        }
        
        /* Canvas stays full width - toolbar floats on top */
        
        .search-results-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 122, 204, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10100;
            cursor: pointer;
            user-select: none;
        }
        
        .search-results-info.visible {
            opacity: 1;
        }
        
        .search-results-info.sync-success {
            background: rgba(40, 167, 69, 0.9);
            color: white;
        }
        
        .search-results-info.sync-error {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }
        
        .search-results-info.sync-loading {
            background: rgba(0, 122, 204, 0.9);
            color: white;
        }
        
        .search-results-info.sync-info {
            background: rgba(23, 162, 184, 0.9);
            color: white;
        }
        
        .selection-info {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 10100;
            max-width: 300px;
            line-height: 1.4;
        }
        
        .selection-info.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* The invisible ruler for measuring text height */
        #text-ruler {
            position: absolute;
            left: -1000px; /* Position off-screen */
            top: -1000px;
            visibility: hidden;
            white-space: pre-wrap; /* Respect newlines and wrap text */
            word-wrap: break-word;
        }
        
        /* Enhanced box selection styling */
        .cy-box-selection {
            background-color: rgba(33, 150, 243, 0.1) !important;
            border: 2px dashed rgba(33, 150, 243, 0.6) !important;
            border-radius: 4px !important;
        }
        
        /* Dark Theme CSS */
        body.dark-theme {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .dark-theme .toolbar {
            background: transparent;
            border-bottom: 1px solid rgba(74, 85, 104, 0.3);
        }
        
        .dark-theme .tag-filter-input,
        .dark-theme .search-input {
            background: linear-gradient(145deg, #4a5568 0%, #3a4458 100%);
            border: 1px solid #5a6572;
            color: #f7fafc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .tag-filter-input:focus,
        .dark-theme .search-input:focus {
            border-color: #6b7280;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            background: linear-gradient(145deg, #5a6572 0%, #4a5568 100%);
        }
        
        /* Dark theme unified toolbar buttons */
        .dark-theme .toolbar-btn {
            background: linear-gradient(145deg, #4a5568 0%, #3a4458 100%);
            color: #f7fafc;
            border: 1px solid #5a6572;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .toolbar-btn:hover {
            background: linear-gradient(145deg, #5a6572 0%, #4a5568 100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        .dark-theme .dropdown-content {
            background: rgba(45, 55, 72, 0.75);
            color: #e2e8f0;
            border: 1px solid #4a5568;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .dark-theme .dropdown-content button {
            color: #e2e8f0;
        }
        
        .dark-theme .dropdown-content button:hover {
            background: linear-gradient(90deg, #4a5568 0%, #3a4458 100%);
            color: #f7fafc;
        }
        
        .dark-theme .dropdown-content button:active {
            background: linear-gradient(90deg, #2d3748 0%, #1a202c 100%);
        }
        
        .dark-theme .search-results-info {
            background: rgba(77, 166, 255, 0.9);
            color: #1a1a1a;
        }
        
        .dark-theme .selection-info {
            background: rgba(102, 179, 255, 0.9);
            color: #1a1a1a;
        }
        
        .dark-theme .mobile-btn {
            background: #4da6ff;
            color: #1a1a1a;
        }
        
        /* Dark theme för Cytoscape korten */
        body.dark-theme #cy {
            background: linear-gradient(45deg, #2d2d2d 25%, transparent 25%), 
                        linear-gradient(-45deg, #2d2d2d 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #2d2d2d 75%), 
                        linear-gradient(-45deg, transparent 75%, #2d2d2d 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #1a1a1a;
        }
        
        /* Sepia Theme CSS */
        body.sepia-theme {
            background: #f4f1e8;
            color: #5d4e37;
        }
        
        .sepia-theme .toolbar {
            background: transparent;
            border-bottom: 1px solid rgba(200, 168, 130, 0.3);
        }
        
        .sepia-theme .tag-filter-input,
        .sepia-theme .search-input {
            background: linear-gradient(145deg, #e8d7c3 0%, #d6c1a0 100%);
            border: 1px solid #c8a882;
            color: #5d4e37;
            box-shadow: 0 2px 4px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .tag-filter-input:focus,
        .sepia-theme .search-input:focus {
            border-color: #a89471;
            box-shadow: 0 4px 8px rgba(139, 117, 86, 0.3);
            background: linear-gradient(145deg, #d6c1a0 0%, #c2a788 100%);
        }
        
        /* Sepia theme unified toolbar buttons */
        .sepia-theme .toolbar-btn {
            background: linear-gradient(145deg, #e8d7c3 0%, #d6c1a0 100%);
            color: #5d4e37;
            border: 1px solid #c8a882;
            box-shadow: 0 2px 4px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .toolbar-btn:hover {
            background: linear-gradient(145deg, #d6c1a0 0%, #c2a788 100%);
            box-shadow: 0 4px 8px rgba(139, 117, 86, 0.3);
        }
        
        .sepia-theme .dropdown-content {
            background: rgba(244, 241, 232, 0.75);
            color: #5d4e37;
            border: 1px solid #c8a882;
            box-shadow: 0 10px 40px rgba(139, 117, 86, 0.2);
        }
        
        .sepia-theme .dropdown-content button {
            color: #5d4e37;
        }
        
        .sepia-theme .dropdown-content button:hover {
            background: linear-gradient(90deg, #e8d7c3 0%, #d6c1a0 100%);
            color: #4a3d2a;
        }
        
        .sepia-theme .dropdown-content button:active {
            background: linear-gradient(90deg, #d6c1a0 0%, #c2a788 100%);
        }
        
        .sepia-theme .search-results-info {
            background: rgba(139, 117, 86, 0.9);
            color: #f4f1e8;
        }
        
        .sepia-theme .selection-info {
            background: rgba(160, 130, 98, 0.9);
            color: #f4f1e8;
        }
        
        .sepia-theme .mobile-btn {
            background: #8b7556;
            color: #f4f1e8;
        }
        
        /* Sepia theme för Cytoscape korten */
        body.sepia-theme #cy {
            background: linear-gradient(45deg, #e8d7c3 25%, transparent 25%), 
                        linear-gradient(-45deg, #e8d7c3 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #e8d7c3 75%), 
                        linear-gradient(-45deg, transparent 75%, #e8d7c3 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #f4f1e8;
        }
        
        /* Dark Theme - Enhanced selection visibility */
        .dark-theme .cy {
            /* Override default Cytoscape styling for better dark theme contrast */
        }
        
        /* Card Colors - Light Theme */
        .light-theme .card-color-1 { background-color: #ffebee !important; } /* Soft Red */
        .light-theme .card-color-2 { background-color: #e3f2fd !important; } /* Soft Blue */
        .light-theme .card-color-3 { background-color: #e8f5e8 !important; } /* Soft Green */
        .light-theme .card-color-4 { background-color: #fff3e0 !important; } /* Soft Orange */
        .light-theme .card-color-5 { background-color: #f3e5f5 !important; } /* Soft Purple */
        
        /* Card Colors - Dark Theme */
        .dark-theme .card-color-1 { background-color: #4a2c2a !important; } /* Dark Red */
        .dark-theme .card-color-2 { background-color: #1e3a5f !important; } /* Dark Blue */
        .dark-theme .card-color-3 { background-color: #2d4a2d !important; } /* Dark Green */
        .dark-theme .card-color-4 { background-color: #4a3429 !important; } /* Dark Orange */
        .dark-theme .card-color-5 { background-color: #3d2a4a !important; } /* Dark Purple */
        
        /* Card Colors - Sepia Theme */
        .sepia-theme .card-color-1 { background-color: #f4e6d7 !important; } /* Sepia Red */
        .sepia-theme .card-color-2 { background-color: #e6d7c3 !important; } /* Sepia Blue */
        .sepia-theme .card-color-3 { background-color: #e8e6d7 !important; } /* Sepia Green */
        .sepia-theme .card-color-4 { background-color: #f0e6d2 !important; } /* Sepia Orange */
        .sepia-theme .card-color-5 { background-color: #ede6d7 !important; } /* Sepia Purple */
        
        /* Color Picker Popup */
        .color-picker-popup {
            position: fixed;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 2000;
        }
        
        .dark-theme .color-picker-popup {
            background: #2d2d2d;
            border-color: #555;
            color: #e0e0e0;
        }
        
        .sepia-theme .color-picker-popup {
            background: #e8d7c3;
            border-color: #c8a882;
            color: #5d4e37;
        }
        
        .color-picker-grid {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .color-picker-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        
        .color-picker-dot:hover {
            transform: scale(1.1);
        }
        
        /* Dark theme adjustments for dot text */
        .dark-theme .color-picker-dot {
            color: #fff !important;
            border-color: #666;
        }
        
        /* Sepia theme adjustments for dot text */
        .sepia-theme .color-picker-dot {
            color: #5d4e37 !important;
            border-color: #8B7355;
        }
        
        /* Ensure numbers are visible with stronger contrast */
        .color-picker-dot {
            text-shadow: 0 0 3px rgba(0,0,0,0.7);
        }
        
        .dark-theme .color-picker-dot {
            text-shadow: 0 0 3px rgba(0,0,0,0.9);
        }
        
        /* Color picker dot colors - Light theme */
        .color-picker-dot.card-color-1 { background-color: #d4f2d4; } /* Grön */
        .color-picker-dot.card-color-2 { background-color: #ffe4b3; } /* Orange */
        .color-picker-dot.card-color-3 { background-color: #ffc1cc; } /* Röd */
        .color-picker-dot.card-color-4 { background-color: #fff7b3; } /* Gul */
        .color-picker-dot.card-color-5 { background-color: #f3e5f5; } /* Lila */
        .color-picker-dot.card-color-6 { background-color: #c7e7ff; } /* Blå */
        .color-picker-dot.card-color-7 { background-color: #e0e0e0; } /* Grå */
        .color-picker-dot.card-color-8 { background-color: #ffffff; } /* Vit */
        
        /* Dark theme color picker dots */
        .dark-theme .color-picker-dot.card-color-1 { background-color: #3d5a3d; } /* Mörk Grön */
        .dark-theme .color-picker-dot.card-color-2 { background-color: #5a4d3a; } /* Mörk Orange */
        .dark-theme .color-picker-dot.card-color-3 { background-color: #5a3c3a; } /* Mörk Röd */
        .dark-theme .color-picker-dot.card-color-4 { background-color: #5a5a3a; } /* Mörk Gul */
        .dark-theme .color-picker-dot.card-color-5 { background-color: #4a3d5a; } /* Mörk Lila */
        .dark-theme .color-picker-dot.card-color-6 { background-color: #2e4a6f; } /* Mörk Blå */
        .dark-theme .color-picker-dot.card-color-7 { background-color: #555555; } /* Mörk Grå */
        .dark-theme .color-picker-dot.card-color-8 { background-color: #8a8a8a; } /* Ljusgrå */
        
        /* Sepia theme color picker dots */
        .sepia-theme .color-picker-dot.card-color-1 { background-color: #ded6c7; } /* Sepia Grön */
        .sepia-theme .color-picker-dot.card-color-2 { background-color: #e6d6c2; } /* Sepia Orange */
        .sepia-theme .color-picker-dot.card-color-3 { background-color: #ead6c7; } /* Sepia Röd */
        .sepia-theme .color-picker-dot.card-color-4 { background-color: #ebe2d6; } /* Sepia Gul */
        .sepia-theme .color-picker-dot.card-color-5 { background-color: #e2d6c7; } /* Sepia Lila */
        .sepia-theme .color-picker-dot.card-color-6 { background-color: #d6c7b3; } /* Sepia Blå */
        .sepia-theme .color-picker-dot.card-color-7 { background-color: #c0b8a8; } /* Sepia Grå */
        .sepia-theme .color-picker-dot.card-color-8 { background-color: #f5f2e8; } /* Sepia Vit */
        
        .color-picker-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .color-picker-cancel {
            text-align: center;
            margin-top: 10px;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .dark-theme .color-picker-cancel {
            background: #555;
            color: #e0e0e0;
        }
        
        .sepia-theme .color-picker-cancel {
            background: #d7c8a8;
            color: #5d4e37;
        }
        
        .color-picker-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .color-picker-grid {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ddd;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .color-dot:hover {
            transform: scale(1.1);
            border-color: #333;
        }
        
        .dark-theme .color-dot {
            border-color: #555;
        }
        
        .dark-theme .color-dot:hover {
            border-color: #bbb;
        }
        
        .sepia-theme .color-dot {
            border-color: #c8a882;
        }
        
        .sepia-theme .color-dot:hover {
            border-color: #8b7556;
        }
        
        .color-picker-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .color-picker-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .color-picker-btn.remove {
            background: #ff6b6b;
            color: white;
        }
        
        .color-picker-btn.cancel {
            background: #6c757d;
            color: white;
        }
        
        /* Context Menu */
        .context-menu {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            min-width: 150px;
            overflow: hidden;
        }
        
        .dark-theme .context-menu {
            background: #2d2d2d;
            border-color: #555;
        }
        
        .sepia-theme .context-menu {
            background: #e8d7c3;
            border-color: #c8a882;
        }
        
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }
        
        .context-menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .dark-theme .context-menu-item {
            color: #e0e0e0;
            border-bottom-color: #444;
        }
        
        .dark-theme .context-menu-item:hover {
            background-color: #3a3a3a;
        }
        
        .sepia-theme .context-menu-item {
            color: #5d4e37;
            border-bottom-color: #d4c3a7;
        }
        
        .sepia-theme .context-menu-item:hover {
            background-color: #d4c3a7;
        }
        
        /* Mobile controls - floating buttons */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        /* Make toolbar mobile-friendly with icons */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 3px;
                padding: 5px;
                min-height: auto;
            }
            
            .search-box, .tag-filter-box {
                flex: 1 1 40%;
                min-width: 100px;
            }
            
            /* Convert google drive button to icon on mobile */
            .google-drive-btn {
                padding: 8px;
                font-size: 18px;
                min-width: auto;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            
            .menu-button {
                padding: 8px 12px;
                font-size: 16px;
            }
            
            .menu-button span:last-child {
                margin-left: 3px; /* Less space for arrow */
            }
        }
        
        /* Annotation Toolbar */
        .annotation-toolbar {
            position: fixed;
            top: 60px;
            left: 0;
            bottom: 0;
            width: 80px;
            padding: 20px 8px;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.08);
            display: none;
            z-index: 1001;
            overflow-y: auto;
        }

        .annotation-toolbar.active {
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            width: 25px;
            opacity: 0.9;
            padding: 8px 0;
        }

        .annotation-tool-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .annotation-tool-group:last-child {
            margin-bottom: 0;
        }

        .annotation-tool {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            user-select: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            opacity: 0.8;
        }

        .annotation-tool:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .annotation-tool.active {
            opacity: 1;
            transform: scale(1.3);
            color: #007bff;
        }

        .annotation-separator {
            width: 1px;
            height: 20px;
            background: #ddd;
            margin: 0 4px;
        }

        .dark-theme .annotation-toolbar.active {
            background: rgba(45, 55, 72, 0.3);
            color: #e0e0e0;
        }

        .dark-theme .annotation-tool {
            color: #e0e0e0;
        }

        .dark-theme .annotation-tool.active {
            color: #4da6ff;
        }

        .sepia-theme .annotation-toolbar.active {
            background: rgba(244, 241, 232, 0.3);
            color: #5d4e37;
        }

        .sepia-theme .annotation-tool {
            color: #5d4e37;
        }

        .sepia-theme .annotation-tool.active {
            color: #8b7556;
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(128, 128, 128, 0.7);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
            opacity: 0.8;
        }
        
        .mobile-btn:hover {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(1.05);
            opacity: 1;
        }
        
        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Dark theme discrete mobile buttons */
        .dark-theme .mobile-btn {
            background: rgba(80, 80, 80, 0.8);
            color: #e0e0e0;
        }
        
        .dark-theme .mobile-btn:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Sepia theme discrete mobile buttons */
        .sepia-theme .mobile-btn {
            background: rgba(139, 117, 86, 0.7);
            color: #f4f1e8;
        }
        
        .sepia-theme .mobile-btn:hover {
            background: rgba(109, 90, 68, 0.9);
        }
        
        /* Show mobile controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: flex !important;
            }
            .mobile-only {
                display: inline-block !important;
            }
        }
        
        /* Alternative: Show on small screens */
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex !important;
            }
            .mobile-only {
                display: inline-block !important;
            }
        }
        
        /* Desktop zoom-out button - smaller and more discrete */
        .desktop-zoom-btn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(128, 128, 128, 0.7); /* Discrete gray with transparency */
            color: white;
            border: none;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            transition: all 0.2s ease;
            opacity: 0.8;
        }
        
        .desktop-zoom-btn:hover {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(1.05);
            opacity: 1;
        }
        
        .desktop-zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* Dark theme discrete zoom button */
        .dark-theme .desktop-zoom-btn {
            background: rgba(80, 80, 80, 0.8);
            color: #e0e0e0;
        }
        
        .dark-theme .desktop-zoom-btn:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Sepia theme discrete zoom button */
        .sepia-theme .desktop-zoom-btn {
            background: rgba(139, 117, 86, 0.7);
            color: #f4f1e8;
        }
        
        .sepia-theme .desktop-zoom-btn:hover {
            background: rgba(109, 90, 68, 0.9);
        }
        
        /* Hide desktop button on mobile (where mobile-controls are shown) */
        @media (hover: none) and (pointer: coarse) {
            .desktop-zoom-btn {
                display: none !important;
            }
        }
        
        @media (max-width: 768px) {
            .desktop-zoom-btn {
                display: none !important;
            }
        }

        /* Column View Styles */
        .column-view {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f5f5f5;
            overflow-y: auto;
            padding: 20px;
            z-index: 1;
        }

        .column-container {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .column-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .column-card:hover {
            border-color: #aaa;
        }

        .column-card.search-match {
            border-color: #28a745;
            background: #f8fff9;
        }

        .column-card.selected {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .column-card-content {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .column-card-content h1 {
            font-size: 1.3em;
            margin: 0.5em 0 0.3em 0;
            font-weight: bold;
        }

        .column-card-content h2 {
            font-size: 1.1em;
            margin: 0.4em 0 0.2em 0;
            font-weight: bold;
        }

        .column-card-content h3 {
            font-size: 1em;
            margin: 0.3em 0 0.1em 0;
            font-weight: bold;
        }

        .column-card-image {
            max-width: 100%;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .column-card-annotation {
            font-style: italic;
            color: #666;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .column-card-tags {
            margin-top: 15px;
            font-size: 0.85em;
            color: #666;
        }

        .column-card-tags .tag {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
        }

        /* Dark theme for column view */
        .dark-theme .column-view {
            background: #2d3748;
        }

        .dark-theme .column-card {
            background: #4a5568;
            border-color: #718096;
            color: white;
        }

        .dark-theme .column-card:hover {
            border-color: #a0aec0;
        }

        .dark-theme .column-card.search-match {
            border-color: #48bb78;
            background: #2f4f3f;
        }

        .dark-theme .column-card.selected {
            border-color: #63b3ed;
            background: #2c5aa0;
        }

        /* Sepia theme for column view */
        .sepia-theme .column-view {
            background: #f4f1e8;
        }

        .sepia-theme .column-card {
            background: #faf8f1;
            border-color: #d4c4a8;
            color: #5d4e37;
        }

        .sepia-theme .column-card:hover {
            border-color: #b8a082;
        }

        .sepia-theme .column-card.search-match {
            border-color: #8fbc8f;
            background: #f0f8f0;
        }

        .sepia-theme .column-card.selected {
            border-color: #6b8db5;
            background: #e8f0f8;
        }

        /* AI Chat Panel */
        .ai-panel {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            z-index: 9000;
            display: none;
            flex-direction: column;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Desktop: Side panel */
        @media (min-width: 769px) {
            .ai-panel {
                right: 0;
                top: 60px;
                width: 400px;
                height: calc(100vh - 60px);
            }
        }

        /* Mobile/iPad: Bottom panel */
        @media (max-width: 768px) {
            .ai-panel {
                bottom: 0;
                left: 0;
                right: 0;
                height: 40vh;
                max-height: 280px;
                border-top: 2px solid #007bff;
            }

            .ai-panel-header {
                padding: 10px 15px;
                min-height: 40px;
            }

            .ai-panel-messages {
                flex: 1;
                min-height: 80px;
                max-height: calc(40vh - 120px);
                padding: 10px;
            }

            .ai-panel-input-area {
                padding: 10px;
                flex-shrink: 0;
            }

            .ai-panel-input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        .ai-panel.visible {
            display: flex;
        }

        .ai-panel-header {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-panel-title {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }

        .ai-panel-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-panel-close:hover {
            color: #333;
        }

        .ai-panel-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ai-message {
            padding: 12px;
            border-radius: 8px;
            max-width: 85%;
            word-wrap: break-word;
        }

        .ai-message.user {
            background: #007bff;
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .ai-message.assistant {
            background: #f1f3f5;
            color: #333;
            align-self: flex-start;
            border: 1px solid #dee2e6;
        }

        .ai-message.system {
            background: #fff3cd;
            color: #856404;
            align-self: center;
            font-size: 13px;
            font-style: italic;
            text-align: center;
        }

        .ai-panel-input-area {
            padding: 15px;
            border-top: 1px solid #dee2e6;
            background: white;
        }

        .ai-input-wrapper {
            display: flex;
            gap: 10px;
        }

        .ai-panel-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            resize: none;
            font-family: inherit;
        }

        .ai-panel-send {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }

        .ai-panel-send:hover {
            background: #0056b3;
        }

        .ai-panel-send:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .ai-loading {
            text-align: center;
            color: #666;
            font-size: 14px;
            padding: 10px;
        }

        /* Dark theme for AI panel */
        .dark-theme .ai-panel {
            background: #2d3748;
            border-color: #4a5568;
        }

        .dark-theme .ai-panel-header {
            background: #1a202c;
            border-color: #4a5568;
        }

        .dark-theme .ai-panel-title {
            color: #e2e8f0;
        }

        .dark-theme .ai-message.assistant {
            background: #4a5568;
            color: #e2e8f0;
            border-color: #718096;
        }

        .dark-theme .ai-panel-input-area {
            background: #2d3748;
            border-color: #4a5568;
        }

        .dark-theme .ai-panel-input {
            background: #4a5568;
            color: #e2e8f0;
            border-color: #718096;
        }

        /* ================================================================ */
        /* E-INK THEME - Optimized for e-ink devices (Viwood AiPaper Mini) */
        /* No gradients, no shadows, sharp black/white contrast            */
        /* ================================================================ */

        .eink-theme .toolbar {
            background: #ffffff;
            border-bottom: 2px solid #000000;
        }

        .eink-theme .tag-filter-input,
        .eink-theme .search-input {
            background: #ffffff;
            border: 1px solid #666666;
            color: #000000;
            box-shadow: none;
        }

        .eink-theme .tag-filter-input:focus,
        .eink-theme .search-input:focus {
            border: 2px solid #000000;
            background: #ffffff;
            box-shadow: none;
        }

        /* E-ink unified toolbar buttons - no gradients or shadows */
        .eink-theme .toolbar-btn {
            background: #ffffff;
            color: #000000;
            border: 1px solid #666666;
            box-shadow: none;
        }

        .eink-theme .toolbar-btn:hover {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .eink-theme .dropdown-content {
            background: #ffffff;
            color: #000000;
            border: 1px solid #666666;
            box-shadow: none;
        }

        .eink-theme .dropdown-content button {
            color: #000000;
        }

        .eink-theme .dropdown-content button:hover {
            background: #000000;
            color: #ffffff;
        }

        .eink-theme .dropdown-content button:active {
            background: #333333;
            color: #ffffff;
        }

        .eink-theme .search-results-info {
            background: #000000;
            color: #ffffff;
        }

        .eink-theme .selection-info {
            background: #000000;
            color: #ffffff;
        }

        .eink-theme .mobile-btn {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        /* E-ink canvas - simple checkerboard without gradients */
        body.eink-theme #cy {
            background-image:
                linear-gradient(45deg, #e8e8e8 25%, transparent 25%),
                linear-gradient(-45deg, #e8e8e8 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e8e8e8 75%),
                linear-gradient(-45deg, transparent 75%, #e8e8e8 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #f5f5f5;
        }

        .eink-theme .context-menu {
            background: #ffffff;
            border: 1px solid #666666;
            box-shadow: none;
        }

        .eink-theme .context-menu-item {
            color: #000000;
            border-bottom: 1px solid #cccccc;
        }

        .eink-theme .context-menu-item:hover {
            background-color: #000000;
            color: #ffffff;
        }

        .eink-theme .annotation-toolbar.active {
            background: #ffffff;
            color: #000000;
            border: 1px solid #666666;
        }

        .eink-theme .annotation-tool {
            color: #000000;
        }

        .eink-theme .annotation-tool.active {
            background: #000000;
            color: #ffffff;
        }

        .eink-theme .mobile-btn {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .eink-theme .mobile-btn:hover {
            background: #333333;
        }

        .eink-theme .desktop-zoom-btn {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .eink-theme .desktop-zoom-btn:hover {
            background: #333333;
        }

        .eink-theme .column-view {
            background: #ffffff;
        }

        .eink-theme .column-card {
            background: #ffffff;
            border: 1px solid #666666;
            color: #000000;
            box-shadow: none;
        }

        .eink-theme .column-card:hover {
            border: 2px solid #000000;
        }

        .eink-theme .column-card.search-match {
            border: 2px solid #000000;
            background: #f0f0f0;
        }

        .eink-theme .column-card.selected {
            background: #000000;
            color: #ffffff;
        }

        .eink-theme .color-picker-popup {
            background: #ffffff;
            border: 1px solid #666666;
            color: #000000;
            box-shadow: none;
        }

        .eink-theme .color-picker-dot {
            border: 1px solid #666666;
        }

        .eink-theme .color-picker-cancel {
            background: #ffffff;
            border: 1px solid #666666;
            color: #000000;
        }

        .eink-theme .ai-panel {
            background: #ffffff;
            border: 1px solid #666666;
        }

        .eink-theme .ai-panel-header {
            background: #f0f0f0;
            border-bottom: 1px solid #666666;
        }

        .eink-theme .ai-panel-title {
            color: #000000;
        }

        .eink-theme .ai-message.assistant {
            background: #f0f0f0;
            color: #000000;
            border: 1px solid #666666;
        }

        .eink-theme .ai-panel-input-area {
            background: #ffffff;
            border-top: 1px solid #666666;
        }

        .eink-theme .ai-panel-input {
            background: #ffffff;
            color: #000000;
            border: 1px solid #666666;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <!-- Mobile hamburger toggle (hidden on desktop) -->
        <button class="toolbar-btn mobile-only" id="mobileHamburgerBtn" onclick="toggleSimplifiedToolbar()" title="Växla till mini-meny" style="display: none; padding: 8px 12px;">
            ☰
        </button>
        
        <!-- Project Selector -->
        <div class="project-selector">
            <button class="project-button" id="projectButton" onclick="toggleProjectDropdown()">
                <span id="projectName">Nytt projekt</span>
                <span>▼</span>
            </button>
            <div class="project-dropdown" id="projectDropdown">
                <div class="project-dropdown-item" onclick="renameProject()">
                    <span>✏️</span>
                    <span>Byt namn på projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="createNewProject()">
                    <span>➕</span>
                    <span>Nytt projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="showProjectList()">
                    <span>📂</span>
                    <span>Öppna projekt</span>
                </div>
                <div class="project-dropdown-item" onclick="manageProjects()">
                    <span>🗂️</span>
                    <span>Hantera projekt</span>
                </div>
            </div>
        </div>
        
        <div class="search-box">
            <input type="text" class="search-input" placeholder='Sök: "bias and social" OR "not psychology"' id="searchInput">
            <button class="search-select-btn toolbar-btn" id="searchSelectBtn" onclick="selectSearchResults()" style="display: none;">
                📍 Markera funna
            </button>
        </div>
        <div class="tag-filter-box">
            <input type="text" class="tag-filter-input" placeholder='Tags: tech AND psychology NOT done' id="tagFilterInput">
        </div>
        <button class="toolbar-btn" id="annotationToggleBtn" onclick="toggleAnnotationToolbar()" title="Aktivera/inaktivera annotation-verktyg" style="padding: 8px 16px;">
            ⬜→⭕
        </button>
        <button class="toolbar-btn" id="imageUploadBtn" onclick="triggerImageUpload()" title="Tre bildval: Kamera, Galleri, Filväljare" style="padding: 8px 16px;">
            📷 Bilder
        </button>
        <button class="toolbar-btn" id="multiImportBtn" onclick="showMultiCardPasteDialog()" title="Skapa flera kort samtidigt (M)" style="padding: 8px 16px;">
            📋 Multi-import
        </button>
        <button class="toolbar-btn" id="aiAssistantBtn" onclick="toggleAIPanel()" title="Öppna AI-assistent" style="padding: 8px 16px;">
            🤖 AI
        </button>
        <button class="toolbar-btn" id="viewToggleBtn" onclick="toggleView()" title="Växla mellan brädvy och kolumnvy" style="padding: 8px 16px;">
            📋 Kolumnvy
        </button>

        <!-- Mobile controls (hidden on desktop) -->
        <div class="mobile-controls">
            <button class="mobile-btn zoom-out-btn" onclick="zoomOutToCenter()" title="Zooma ut centralt">🔍−</button>
            <button class="mobile-btn new-card-btn" onclick="addNewCard()" title="Tap: Nytt kort | Långtryck: Kamera/Bilder">➕</button>
        </div>
        <div class="menu-dropdown">
            <button class="menu-button toolbar-btn">
                ⚙️ Meny
                <span>▼</span>
            </button>
            <div class="dropdown-content">
                <button onclick="closeMenuDropdowns(); saveBoard()">💾 Spara (LocalStorage)</button>
                <button onclick="closeMenuDropdowns(); saveWithTimestamp()">💾 Spara fil</button>
                <button onclick="closeMenuDropdowns(); saveAs()">💾 Spara som...</button>
                <button onclick="closeMenuDropdowns(); loadBoard()">📂 Ladda fil</button>
                <button onclick="closeMenuDropdowns(); exportToJSON()">📋 Exportera JSON</button>
                <button onclick="closeMenuDropdowns(); importFromJSON()">📁 Importera JSON</button>
                <button onclick="closeMenuDropdowns(); importFromExtractor()">📥 Från PDF-Extractor</button>
                <button onclick="closeMenuDropdowns(); document.getElementById('zoteroHtmlInput').click()">📚 Från Zotero</button>
                <button onclick="closeMenuDropdowns(); toggleGoogleDriveAuth()" id="googleDriveBtn">🔗 Google Drive</button>
                <button onclick="closeMenuDropdowns(); toggleMetadataView()" id="metadataBtn">🔍 Metadata</button>
                <button onclick="closeMenuDropdowns(); debugDumpPositions()">🐛 Debug Positioner</button>
                <button onclick="closeMenuDropdowns(); toggleDarkTheme()" id="themeBtn">🌙 Mörkt Tema</button>
                <button onclick="closeMenuDropdowns(); clearBoard()">🗑️ Rensa</button>
            </div>
        </div>
        
        <!-- Keyboard commands dropdown -->
        <div class="menu-dropdown">
            <button class="menu-button toolbar-btn">
                ⌨️
                <span>▼</span>
            </button>
            <div class="dropdown-content">
                <button onclick="closeMenuDropdowns(); executeCommand('H')">H</button>
                <button onclick="closeMenuDropdowns(); executeCommand('V')">V</button>
                <button onclick="closeMenuDropdowns(); executeCommand('G+V')">G+V</button>
                <button onclick="closeMenuDropdowns(); executeCommand('G+H')">G+H</button>
                <button onclick="closeMenuDropdowns(); executeCommand('G+T')">G+T</button>
                <button onclick="closeMenuDropdowns(); executeCommand('QQ')">QQ</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Q')">Q</button>
                <button onclick="closeMenuDropdowns(); executeCommand('C')">C</button>
                <button onclick="closeMenuDropdowns(); executeCommand('T')">🎨 T</button>
                <button onclick="closeMenuDropdowns(); showSortMenu(event)">📊 Sortera</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Pin')">📌 Pin</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Unpin')">🔓 Unpin</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Delete')">🗑️ Delete</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Ctrl+Z')">Ctrl+Z</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Ctrl+Y')">Ctrl+Y</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Ctrl+A')">Ctrl+A</button>
                <button onclick="closeMenuDropdowns(); executeCommand('Ctrl+S')">Ctrl+S</button>
            </div>
        </div>
    </div>
    
    <div class="search-results-info" id="searchInfo"></div>
    <div class="selection-info" id="selectionInfo"></div>
    
    <!-- The invisible ruler -->
    <div id="text-ruler"></div>
    
    <!-- Desktop zoom-out button -->
    <button class="desktop-zoom-btn" onclick="zoomOutToCenter()" title="Zooma ut för att visa alla kort">🔍</button>
    
    <div id="cy"></div>
    
    <!-- Column view container -->
    <div id="columnView" class="column-view" style="display: none;">
        <div class="column-container" id="columnContainer">
            <!-- Column view cards will be rendered here -->
        </div>
    </div>

    <!-- Annotation Toolbar -->
    <div class="annotation-toolbar" id="annotationToolbar">
        <div class="annotation-tool-group">
            <div class="annotation-tool active" data-tool="select" title="Välj och flytta">🔍 Välj</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="rect" title="Rektangel">⬜</div>
            <div class="annotation-tool" data-tool="circle" title="Cirkel">⭕</div>
            <div class="annotation-tool" data-tool="triangle" title="Triangel">🔺</div>
            <div class="annotation-tool" data-tool="diamond" title="Diamant">◆</div>
            <div class="annotation-tool" data-tool="star" title="Stjärna">⭐</div>
            <div class="annotation-tool" data-tool="hexagon" title="Hexagon">⬢</div>
        </div>
        <div class="annotation-tool-group">
            <div class="annotation-tool" data-tool="text-small" title="Liten text">🅰️ S</div>
            <div class="annotation-tool" data-tool="text-medium" title="Medium text">🅰️ M</div>
            <div class="annotation-tool" data-tool="text-large" title="Stor text">🅰️ L</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="arrow" title="Pil mellan objekt">→</div>
            <div class="annotation-tool" data-tool="line" title="Linje mellan objekt">➖</div>
            <div class="annotation-separator"></div>
            <div class="annotation-tool" data-tool="resize" title="Aktivera storleksändring (högerklick på figur)">↗️</div>
        </div>
        <div class="annotation-tool-group">
            <div class="annotation-tool" data-tool="color-red" title="Röd färg" style="background: #ff6b6b; color: white;">●</div>
            <div class="annotation-tool" data-tool="color-blue" title="Blå färg" style="background: #4ecdc4; color: white;">●</div>
            <div class="annotation-tool" data-tool="color-green" title="Grön färg" style="background: #45b7d1; color: white;">●</div>
            <div class="annotation-tool" data-tool="color-yellow" title="Gul färg" style="background: #f9ca24; color: white;">●</div>
            <div class="annotation-tool" data-tool="color-purple" title="Lila färg" style="background: #a55eea; color: white;">●</div>
        </div>
    </div>

    <!-- Hidden file inputs for image upload -->
    <input type="file" id="hiddenCameraInput" accept="image/*" multiple capture="camera" style="display: none;">
    <input type="file" id="hiddenGalleryInput" accept="image/*" multiple style="display: none;">

    <!-- Hidden file input for Zotero HTML import -->
    <input type="file" id="zoteroHtmlInput" accept=".html" style="display: none;">

    <!-- AI Chat Panel -->
    <div class="ai-panel" id="aiPanel">
        <div class="ai-panel-header">
            <div class="ai-panel-title">🤖 AI-assistent</div>
            <button class="ai-panel-close" onclick="toggleAIPanel()">✕</button>
        </div>
        <div class="ai-panel-messages" id="aiMessages">
            <!-- Chat messages will appear here -->
        </div>
        <div class="ai-panel-input-area">
            <div class="ai-input-wrapper">
                <textarea class="ai-panel-input" id="aiPanelInput" placeholder="Fråga AI om dina anteckningar...
Exempel: Visa alla kort om projektet, Sortera todos i veckogrid" rows="2"></textarea>
                <button class="ai-panel-send" id="aiPanelSend" onclick="sendAIMessage()">Skicka</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let cy;
        let searchActive = false;
        let copiedCards = []; // Store copied cards for arrangement commands
        
        // Annotation system variables
        let annotationMode = 'select';
        let annotationColor = '#ff6b6b';
        let connectionStartNode = null;
        let annotationToolbarVisible = false;
        let resizeMode = false;
        
        // Mouse position tracking
        let lastMousePosition = { x: null, y: null };

        // IMAGE HANDLING SYSTEM - Integration with existing architecture
        
        // Detect if user is on mobile/tablet device
        function isMobileDevice() {
            const result = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
            console.log('DEBUG isMobileDevice:', result, 'userAgent:', navigator.userAgent, 'maxTouchPoints:', navigator.maxTouchPoints);
            return result;
        }
        
        // Direct image upload - use the three-choice function directly
        function triggerImageUpload() {
            document.getElementById('hiddenGalleryInput').click();
        }

        // Show image source menu at specific position (for iPad/mobile)
        function showImageSourceMenu(clientX, clientY) {
            // Remove any existing menu
            const existingMenu = document.getElementById('imageSourceMenu');
            if (existingMenu) {
                document.body.removeChild(existingMenu);
            }

            // Create menu
            const menu = document.createElement('div');
            menu.id = 'imageSourceMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${Math.min(clientX, window.innerWidth - 200)}px;
                top: ${Math.min(clientY, window.innerHeight - 200)}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 180px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 16px;
                padding: 8px 0;
            `;

            menu.innerHTML = `
                <div class="image-menu-item" data-action="clipboard" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #eee;">
                    📋 Klistra in
                </div>
                <div class="image-menu-item" data-action="camera" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #eee;">
                    📷 Ta foto
                </div>
                <div class="image-menu-item" data-action="gallery" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #eee;">
                    🖼️ Välj från galleri
                </div>
                <div class="image-menu-item" data-action="file" style="padding: 12px 16px; cursor: pointer;">
                    📁 Välj fil
                </div>
            `;

            document.body.appendChild(menu);

            // Handle menu item clicks
            menu.querySelectorAll('.image-menu-item').forEach(item => {
                item.addEventListener('click', async () => {
                    const action = item.dataset.action;
                    if (action === 'clipboard') {
                        // Paste from clipboard - call the existing paste function
                        try {
                            await pasteClipboardContent(clientX, clientY);
                        } catch (err) {
                            console.error('Clipboard paste failed:', err);
                            alert('Kunde inte klistra in från clipboard. Kontrollera behörigheter.');
                        }
                    } else if (action === 'camera') {
                        document.getElementById('hiddenCameraInput').click();
                    } else if (action === 'gallery') {
                        document.getElementById('hiddenGalleryInput').click();
                    } else if (action === 'file') {
                        document.getElementById('hiddenGalleryInput').click();
                    }
                    document.body.removeChild(menu);
                });

                // Add hover effect
                item.addEventListener('mouseenter', function() {
                    this.style.background = '#f0f0f0';
                });
                item.addEventListener('mouseleave', function() {
                    this.style.background = 'white';
                });
            });

            // Close menu when clicking outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', closeHandler);
                        document.removeEventListener('touchstart', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
                document.addEventListener('touchstart', closeHandler);
            }, 100);
        }

        // Process uploaded images
        function handleImageFiles(files) {
            Array.from(files).forEach(file => {
                if (file && file.type.startsWith('image/')) {
                    processImage(file).then(imageData => {
                        createImageNode(imageData, file.name);
                    }).catch(err => {
                        console.error('Image processing failed:', err);
                    });
                }
            });
        }

        // Process image to 800px width with S-curve + strong light-gray whitening for handwritten notes (~35-90 KB)
        function processImage(file) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Scale to 800px width for better quality, maintain aspect ratio
                    const ratio = 800 / img.width;
                    canvas.width = 800;
                    canvas.height = Math.round(img.height * ratio);
                    
                    // Draw image to canvas
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Enhance for handwritten notes - moderate contrast improvement
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Simple contrast enhancement without aggressive processing
                        let r = data[i];
                        let g = data[i + 1];
                        let b = data[i + 2];
                        
                        // Calculate grayscale value for contrast enhancement
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // Gentle contrast curve - improve readability without artifacts
                        let enhanced;
                        if (gray < 128) {
                            // Darken text slightly
                            enhanced = gray * 0.8;
                        } else {
                            // Lighten background slightly
                            enhanced = gray + (255 - gray) * 0.3;
                        }
                        
                        // Apply enhancement proportionally to preserve color balance
                        const factor = enhanced / Math.max(gray, 1);
                        
                        data[i] = Math.min(255, Math.max(0, r * factor));
                        data[i + 1] = Math.min(255, Math.max(0, g * factor));
                        data[i + 2] = Math.min(255, Math.max(0, b * factor));
                        // Alpha channel (data[i + 3]) remains unchanged
                    }
                    
                    // Apply the enhanced image data back to canvas
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Try WebP for best quality/size ratio, fallback to PNG, then JPEG
                    let base64;
                    let format = 'unknown';
                    
                    try {
                        // Try WebP first (best compression + quality)
                        base64 = canvas.toDataURL('image/webp', 0.95);
                        if (base64.startsWith('data:image/webp')) {
                            format = 'WebP 95%';
                        } else {
                            throw new Error('WebP not supported');
                        }
                    } catch {
                        try {
                            // Fallback to PNG
                            base64 = canvas.toDataURL('image/png');
                            format = 'PNG (lossless)';
                            
                            // If PNG too large, use max JPEG
                            if (base64.length > 300000) { // ~225KB in base64
                                base64 = canvas.toDataURL('image/jpeg', 1.0);
                                format = 'JPEG 100%';
                            }
                        } catch {
                            // Final fallback
                            base64 = canvas.toDataURL('image/jpeg', 1.0);
                            format = 'JPEG 100%';
                        }
                    }
                    
                    console.log(`📷 Using ${format} (${Math.round(base64.length/1024)} KB)`);
                    
                    resolve({
                        data: base64,
                        width: canvas.width,
                        height: canvas.height,
                        originalName: file.name
                    });
                };
                
                img.onerror = () => reject('Image loading failed');
                img.src = URL.createObjectURL(file);
            });
        }

        // Create image node integrated with existing system
        function createImageNode(imageData, filename) {
            const position = getArrangementPosition();
            const nodeId = generateCardId();

            // Calculate proper aspect ratio height
            const displayWidth = 300;
            const ratio = imageData.height / imageData.width;
            const displayHeight = Math.round(displayWidth * ratio);
            const calculatedHeight = displayHeight; // Keep for backwards compatibility

            cy.add({
                group: 'nodes',
                data: {
                    id: nodeId,
                    type: 'image', // New node type
                    imageData: imageData.data,
                    imageWidth: imageData.width,  // Store original dimensions
                    imageHeight: imageData.height, // Store original dimensions
                    displayWidth: displayWidth,    // Display width (can be changed by user)
                    displayHeight: displayHeight,  // Display height (maintains aspect ratio)
                    calculatedHeight: calculatedHeight, // Pre-calculated height for arrangement
                    annotation: '',
                    searchableText: '',
                    originalFileName: filename,
                    title: '', // No visible title for images
                    text: '', // Keep consistent with existing structure
                    tags: [],
                    isManualCard: true // Integrate with existing categorization
                },
                position: position
            });

            console.log(`📷 Created image node: ${filename} (${Math.round(imageData.data.length/1024)} KB) - ${imageData.width}x${imageData.height} → ${displayWidth}x${displayHeight}`);
        }

        // Handle paste events (Ctrl+V) for images
        function handlePasteImage(event) {
            const items = event.clipboardData?.items;
            if (!items) return;

            for (let item of items) {
                if (item.type.startsWith('image/')) {
                    event.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        processImage(file).then(imageData => {
                            createImageNode(imageData, 'pasted-image-' + Date.now() + '.jpg');
                        }).catch(err => {
                            console.error('Paste image processing failed:', err);
                        });
                    }
                    break;
                }
            }
        }

        // Handle canvas long press - different behavior for mobile vs desktop
        function handleCanvasLongPress(clientX, clientY) {
            if (isMobileDevice()) {
                // Mobile/tablet: Show image source menu at touch position
                showImageSourceMenu(clientX, clientY);
            } else {
                // Desktop: Paste clipboard content
                pasteClipboardContent(clientX, clientY);
            }
        }
        
        // Paste clipboard content (text or image) at specific position
        async function pasteClipboardContent(clientX, clientY) {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (let item of clipboardItems) {
                    // Check for image first
                    for (let type of item.types) {
                        if (type.startsWith('image/')) {
                            const blob = await item.getAsType(type);
                            const position = getCanvasPosition(clientX, clientY);
                            processImage(blob).then(imageData => {
                                createImageNodeAtPosition(imageData, 'pasted-' + Date.now() + '.jpg', position);
                            }).catch(err => {
                                console.error('Image paste processing failed:', err);
                            });
                            return;
                        }
                    }
                }
                
                // If no image, try text
                const text = await navigator.clipboard.readText();
                if (text && text.trim()) {
                    const position = getCanvasPosition(clientX, clientY);
                    createTextNodeAtPosition(text.trim(), position);
                }
            } catch (err) {
                console.error('Kunde inte komma åt urklipp:', err);
            }
        }
        
        // Get canvas position from client coordinates
        function getCanvasPosition(clientX, clientY) {
            const cyContainer = document.getElementById('cy');
            const rect = cyContainer.getBoundingClientRect();
            const relativeX = clientX - rect.left;
            const relativeY = clientY - rect.top;
            
            // Convert to Cytoscape coordinates
            const pan = cy.pan();
            const zoom = cy.zoom();
            
            return {
                x: (relativeX - pan.x) / zoom,
                y: (relativeY - pan.y) / zoom
            };
        }
        
        // Create text node at specific position
        function createTextNodeAtPosition(text, position) {
            const cardId = generateCardId();
            cy.add({
                group: 'nodes',
                data: {
                    id: cardId,
                    label: text,
                    isManualCard: true,
                    tags: [],
                    annotation: '',
                    searchableText: text
                },
                position: position
            });
        }
        
        // Create image node at specific position
        function createImageNodeAtPosition(imageData, filename, position) {
            const displayWidth = 300;
            const ratio = imageData.height / imageData.width;
            const displayHeight = Math.round(displayWidth * ratio);
            const calculatedHeight = displayHeight; // Keep for backwards compatibility
            const cardId = generateCardId();

            cy.add({
                group: 'nodes',
                data: {
                    id: cardId,
                    label: '📝',
                    type: 'image',
                    imageData: imageData.data,
                    imageWidth: imageData.width,
                    imageHeight: imageData.height,
                    displayWidth: displayWidth,
                    displayHeight: displayHeight,
                    calculatedHeight: calculatedHeight,
                    annotation: '',
                    searchableText: '',
                    originalFileName: filename,
                    title: '',
                    text: '',
                    tags: [],
                    isManualCard: true
                },
                position: position
            });
        }


        // Generate unique timestamp-based card ID
        function generateCardId() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            
            const baseId = `${year}${month}${day}-${hour}${minute}${second}`;
            
            // Check if ID already exists, if so add letter suffix
            let uniqueId = baseId;
            let suffix = 'a';
            
            while (cy && cy.getElementById(uniqueId).length > 0) {
                uniqueId = `${baseId}-${suffix}`;
                suffix = String.fromCharCode(suffix.charCodeAt(0) + 1);
                
                // Fallback to numbers if we run out of letters (very unlikely)
                if (suffix > 'z') {
                    const timestamp = Date.now();
                    uniqueId = `${baseId}-${timestamp.toString(36).slice(-3)}`;
                    break;
                }
            }
            
            return uniqueId;
        }
        
        // ====================================================================================================
        // 🔧 FALLBACK RESIZE FUNCTIONALITY
        // ====================================================================================================
        
        function setupFallbackResize() {
            console.log('🛠️ Setting up simple resize with Ctrl+click...');
            
            // Add Ctrl+click OR right-click resize for annotation nodes
            cy.on('cxttap', 'node', function(evt) {
                const node = evt.target;
                console.log('🖱️ Right-click on node:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'resizeMode:', resizeMode, 'classes:', node.classes());
                
                if (node.data('isAnnotation') && resizeMode) {
                    console.log('🎯 Processing right-click resize for annotation node...');
                    evt.stopPropagation();
                    evt.preventDefault();
                    
                    const currentWidth = node.data('customWidth') || 120;
                    const currentHeight = node.data('customHeight') || 120;
                    
                    console.log('📐 Current size:', currentWidth, 'x', currentHeight);
                    
                    // Simple resize: cycle through 4 sizes
                    let newWidth, newHeight;
                    
                    if (currentWidth <= 80) {
                        newWidth = 120;
                        newHeight = 120;
                    } else if (currentWidth <= 120) {
                        newWidth = 160;
                        newHeight = 160;
                    } else if (currentWidth <= 160) {
                        newWidth = 200;
                        newHeight = 200;
                    } else {
                        newWidth = 80;
                        newHeight = 80;
                    }
                    
                    console.log('📏 Resizing to:', newWidth, 'x', newHeight);
                    
                    // Update the data properties and force style refresh
                    node.data('customWidth', newWidth);
                    node.data('customHeight', newHeight);
                    
                    // Force Cytoscape to recalculate styles by triggering style refresh
                    node.removeStyle('width height');
                    node.trigger('data');
                    cy.style().update();
                    
                    console.log(`✅ Resized annotation ${node.id()} to ${newWidth}x${newHeight}`);
                    return false;
                }
            });
            
            // Backup: Also try Ctrl+click 
            cy.on('click', 'node', function(evt) {
                const node = evt.target;
                console.log('🖱️ Node clicked:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'resizeMode:', resizeMode, 'ctrlKey:', evt.originalEvent?.ctrlKey);
                
                if (node.data('isAnnotation') && resizeMode && evt.originalEvent?.ctrlKey) {
                    console.log('🎯 Processing Ctrl+click resize for annotation node...');
                    evt.stopPropagation();
                    evt.preventDefault();
                    
                    const currentWidth = node.data('customWidth') || 120;
                    const currentHeight = node.data('customHeight') || 120;
                    
                    console.log('📐 Current size:', currentWidth, 'x', currentHeight);
                    
                    // Simple resize: cycle through 4 sizes
                    let newWidth, newHeight;
                    
                    if (currentWidth <= 80) {
                        newWidth = 120;
                        newHeight = 120;
                    } else if (currentWidth <= 120) {
                        newWidth = 160;
                        newHeight = 160;
                    } else if (currentWidth <= 160) {
                        newWidth = 200;
                        newHeight = 200;
                    } else {
                        newWidth = 80;
                        newHeight = 80;
                    }
                    
                    console.log('📏 Resizing to:', newWidth, 'x', newHeight);
                    
                    // Update the data properties and force style refresh
                    node.data('customWidth', newWidth);
                    node.data('customHeight', newHeight);
                    
                    // Force Cytoscape to recalculate styles by triggering style refresh
                    node.removeStyle('width height');
                    node.trigger('data');
                    cy.style().update();
                    
                    console.log(`✅ Resized annotation ${node.id()} to ${newWidth}x${newHeight}`);
                    return false; // Prevent further event handling
                }
            });
            
            console.log('✅ Fallback resize setup complete - Ctrl+click annotations in resize mode');
        }
        
        // ====================================================================================================
        // 🎨 ANNOTATION SYSTEM FUNCTIONS
        // ====================================================================================================
        
        // Toggle annotation toolbar visibility
        function toggleAnnotationToolbar() {
            annotationToolbarVisible = !annotationToolbarVisible;
            const toolbar = document.getElementById('annotationToolbar');
            const toggleBtn = document.getElementById('annotationToggleBtn');
            
            if (annotationToolbarVisible) {
                toolbar.classList.add('active');
                toggleBtn.style.background = '#28a745';
                console.log('🎨 Annotation toolbar activated');
            } else {
                toolbar.classList.remove('active');
                toggleBtn.style.background = '';
                setAnnotationMode('select');
                console.log('📐 Annotation toolbar deactivated');
            }
        }
        
        // Set annotation mode and update UI
        function setAnnotationMode(mode) {
            annotationMode = mode;
            connectionStartNode = null;
            
            // Update tool buttons
            document.querySelectorAll('.annotation-tool').forEach(tool => {
                tool.classList.remove('active');
            });
            
            const activeTool = document.querySelector(`[data-tool="${mode}"]`);
            if (activeTool) {
                activeTool.classList.add('active');
            }
            
            console.log('🎯 Annotation mode set to:', mode);
        }
        
        // Set annotation color
        function setAnnotationColor(color) {
            annotationColor = color;
            console.log('🎨 Annotation color set to:', color);
        }
        
        // Toggle resize mode for annotations
        function toggleResizeMode() {
            resizeMode = !resizeMode;
            
            console.log('↗️ Resize mode:', resizeMode ? 'enabled' : 'disabled');
            
            // Show user-friendly status message
            if (window.showBriefMessage) {
                if (resizeMode) {
                    window.showBriefMessage('↗️ Storleksändring aktiverad - Högerklicka på annotations för att ändra storlek');
                } else {
                    window.showBriefMessage('📐 Storleksändring avstängd');
                }
            }
        }
        
        // Create geometric shape annotation
        function createShapeAnnotation(shape, position) {
            const id = generateCardId();
            const shapes = {
                'rect': { shape: 'rectangle', label: '' },
                'circle': { shape: 'ellipse', label: '' },
                'triangle': { shape: 'triangle', label: '' },
                'diamond': { shape: 'diamond', label: '' },
                'star': { shape: 'star', label: '' },
                'hexagon': { shape: 'hexagon', label: '' }
            };
            
            const shapeInfo = shapes[shape] || shapes.rect;
            
            cy.add({
                data: {
                    id: id,
                    label: shapeInfo.label,
                    isAnnotation: true,
                    annotationType: 'shape',
                    shape: shape
                },
                position: position,
                classes: 'annotation-shape'
            });
            
            // Apply color immediately
            const node = cy.getElementById(id);
            node.style('background-color', annotationColor);
            
            console.log(`🔷 Created ${shape} annotation at`, position);
            return node;
        }
        
        // Create text annotation
        function createTextAnnotation(size, position) {
            const id = generateCardId();
            const sizes = {
                'text-small': { fontSize: '16px', label: 'Liten text' },
                'text-medium': { fontSize: '22px', label: 'Medium text' },
                'text-large': { fontSize: '28px', label: 'Stor text' }
            };
            
            const sizeInfo = sizes[size] || sizes['text-medium'];
            
            cy.add({
                data: {
                    id: id,
                    label: sizeInfo.label,
                    isAnnotation: true,
                    annotationType: 'text',
                    textSize: size
                },
                position: position,
                classes: 'annotation-text'
            });
            
            const node = cy.getElementById(id);
            node.style({
                'font-size': sizeInfo.fontSize,
                'background-color': annotationColor,
                'shape': 'rectangle'
            });
            
            console.log(`📝 Created ${size} text annotation at`, position);
            return node;
        }
        
        // Create connection (arrow or line) between nodes
        function createConnection(sourceNode, targetNode, type) {
            const id = generateCardId();
            const isArrow = type === 'arrow';
            
            cy.add({
                data: {
                    id: id,
                    source: sourceNode.id(),
                    target: targetNode.id(),
                    isAnnotation: true,
                    annotationType: 'connection',
                    connectionType: type
                },
                classes: 'annotation-connection'
            });
            
            const edge = cy.getElementById(id);
            edge.style({
                'line-color': annotationColor,
                'target-arrow-color': annotationColor,
                'target-arrow-shape': isArrow ? 'triangle' : 'none',
                'curve-style': 'bezier',
                'width': 5,
                'arrow-scale': 1.8
            });
            
            console.log(`🔗 Created ${type} connection between`, sourceNode.id(), 'and', targetNode.id());
            return edge;
        }
        
        // Edit annotation text function
        function editAnnotationText(node) {
            const currentText = node.data('label') || 'Text';
            
            // Create overlay for editing
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 400px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera annotation text</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editAnnotationText" 
                        style="width: 100%; height: 120px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="text-align: right;">
                    <button id="cancelAnnotationEdit" style="margin-right: 10px; padding: 8px 16px; 
                           background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="saveAnnotationEdit" style="padding: 8px 16px; 
                           background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Spara</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on text area and select all
            const textArea = document.getElementById('editAnnotationText');
            textArea.focus();
            textArea.select();
            
            // Event listeners
            document.getElementById('saveAnnotationEdit').addEventListener('click', function() {
                const newText = textArea.value.trim();
                if (newText) {
                    node.data('label', newText);
                    console.log('✅ Updated annotation text to:', newText);
                }

                // Save immediately to prevent data loss from autosave/Drive sync
                saveBoard();

                document.body.removeChild(overlay);
            });
            
            document.getElementById('cancelAnnotationEdit').addEventListener('click', function() {
                document.body.removeChild(overlay);
            });
            
            // Close on ESC key
            overlay.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                }
            });
            
            // Close on overlay click (outside dialog)
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        // MINIMAL UNDO/REDO SYSTEM - Define early so functions can use it
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 20;
        
        // Generate unique timestamp-based ID for new cards
        function generateUniqueId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() +
                            (now.getMonth() + 1).toString().padStart(2, '0') +
                            now.getDate().toString().padStart(2, '0') + '-' +
                            now.getHours().toString().padStart(2, '0') +
                            now.getMinutes().toString().padStart(2, '0') +
                            now.getSeconds().toString().padStart(2, '0');
            
            return timestamp + '-copy';
        }
        
        // Save current state for undo
        function saveState() {
            try {
                const state = {
                    timestamp: Date.now(),
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        data: node.data(),
                        position: { x: node.position().x, y: node.position().y },
                        selected: node.selected(),
                        classes: node.classes().join(' ')
                    }))
                };
                
                undoStack.push(state);
                if (undoStack.length > MAX_UNDO_STEPS) {
                    undoStack.shift(); // Remove oldest
                }
                redoStack = []; // Clear redo when new action
                console.log('State saved, undo stack size:', undoStack.length);
            } catch (error) {
                console.warn('Failed to save state:', error);
            }
        }
        
        // Restore state for undo/redo
        function restoreState(state) {
            if (!state || !state.cards) return false;
            
            try {
                // Clear current state
                cy.nodes().remove();
                
                // Recreate all cards from saved state
                state.cards.forEach(cardState => {
                    const newNode = cy.add({
                        data: cardState.data,
                        position: cardState.position
                    });
                    
                    // Restore classes (like 'pinned')
                    if (cardState.classes) {
                        newNode.addClass(cardState.classes);
                    }
                    
                    // Make draggable
                    newNode.grabify();
                    
                    // Restore selection
                    if (cardState.selected) {
                        newNode.select();
                    }
                });
                
                console.log('State restored');
                return true;
            } catch (error) {
                console.warn('Failed to restore state:', error);
                return false;
            }
        }
        
        // Get arrangement position based on mouse or fallback to screen center
        function getArrangementPosition() {
            // If we have a valid mouse position, use it
            if (lastMousePosition.x !== null && lastMousePosition.y !== null) {
                // Convert browser coordinates to cytoscape model coordinates
                const cyContainer = cy.container();
                const containerRect = cyContainer.getBoundingClientRect();
                const relativeX = lastMousePosition.x - containerRect.left;
                const relativeY = lastMousePosition.y - containerRect.top;
                
                // Convert to cytoscape world coordinates
                const pan = cy.pan();
                const zoom = cy.zoom();
                const modelX = (relativeX - pan.x) / zoom;
                const modelY = (relativeY - pan.y) / zoom;
                
                console.log('Mouse position conversion:', {
                    mouse: lastMousePosition,
                    container: containerRect,
                    relative: {x: relativeX, y: relativeY},
                    pan, zoom,
                    model: {x: modelX, y: modelY}
                });
                
                return { x: modelX, y: modelY };
            }
            
            // Fallback to visible viewport center (better for mobile)
            const viewportCenter = cy.pan();
            const zoom = cy.zoom();
            const containerWidth = cy.width();
            const containerHeight = cy.height();
            
            // Calculate center of visible viewport in model coordinates  
            const visibleCenterX = (-viewportCenter.x + containerWidth/2) / zoom;
            const visibleCenterY = (-viewportCenter.y + containerHeight/2) / zoom;
            
            console.log('Using visible viewport center:', {
                x: visibleCenterX,
                y: visibleCenterY,
                pan: viewportCenter,
                zoom: zoom,
                container: {w: containerWidth, h: containerHeight}
            });
            
            return {
                x: visibleCenterX,
                y: visibleCenterY
            };
        }
        
        // Text measurement using invisible ruler
        let textRuler = null;
        
        function initTextRuler() {
            textRuler = document.getElementById('text-ruler');
        }
        
        // Memoization cache for getMeasuredTextHeight
        const heightCache = new Map();
        
        // Generate content hash for memoization
        function getContentHash(node) {
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = node.data('tags') || [];
            const isImported = node.data('export_source') === 'pdf_extractor' || 
                             node.data('source_file') || 
                             node.data('matched_terms');
            const isWelcomeCard = node.id().startsWith('welcome-');
            
            // Create hash from content and styling factors
            return `${title}|${text}|${tags.join(',')}|${isImported}|${isWelcomeCard}`;
        }
        
        // Clear cache for a specific node (when content changes)
        function clearNodeCache(node) {
            // Remove all cached entries that might match this node
            // We need to remove by pattern since content might have changed
            const nodeId = node.id();
            const keysToDelete = [];
            for (const key of heightCache.keys()) {
                // Simple heuristic: if cache gets too large, clear it periodically
                if (heightCache.size > 500) {
                    heightCache.clear();
                    break;
                }
            }
        }
        
        /**
         * Measures the actual rendered height of a node's text using the invisible ruler (with memoization).
         * @param {object} node The Cytoscape node.
         * @returns {number} The measured height of the text in pixels.
         */
        function getMeasuredTextHeight(node) {
            // SPECIAL HANDLING FOR IMAGE NODES
            if (node.data('type') === 'image' && node.data('imageData')) {
                // Use pre-calculated height if available (for new images)
                const preCalculated = node.data('calculatedHeight');
                if (preCalculated) {
                    return preCalculated;
                }
                
                // For imported images, calculate from stored dimensions
                const imageWidth = node.data('imageWidth');
                const imageHeight = node.data('imageHeight');
                if (imageWidth && imageHeight) {
                    const ratio = imageHeight / imageWidth;
                    return Math.round(300 * ratio); // 300px width, maintain aspect ratio
                }
                
                // Last resort: Use a reasonable default to avoid creating Image objects
                // which can be expensive and cause performance issues
                return 260; // Safe default for images - avoid creating Image objects
            }
            
            // NORMAL TEXT NODE PROCESSING
            // Check cache first
            const hash = getContentHash(node);
            if (heightCache.has(hash)) {
                return heightCache.get(hash);
            }
            
            if (!textRuler) initTextRuler();
            
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = node.data('tags') || [];
            
            // Get the final text content without custom wrapping
            let rawText = text.replace(/\*\*|`|\*|\[|\]/g, '').replace(/^- /gm, '• ');
            
            // Add tags to the measurement
            let tagDisplay = '';
            if (tags.length > 0) {
                tagDisplay = '\n\n' + tags.map(tag => `#${tag}`).join(' ');
            }
            
            const mainText = title ? `${title.toUpperCase()}\n\n${rawText}` : rawText;
            const fullLabel = mainText + tagDisplay;

            // Use EXACT same text-max-width calculation as Cytoscape will use
            const nodeWidth = 300; // Fixed width for all cards
            const textMaxWidth = nodeWidth - 15;

            // Style the ruler to match the node's text properties EXACTLY
            textRuler.style.width = `${textMaxWidth}px`;
            textRuler.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            
            // Use same font-size logic as the Cytoscape style
            const isImported = node.data('export_source') === 'pdf_extractor' || 
                             node.data('source_file') || 
                             node.data('matched_terms');
            const isWelcomeCard = node.id().startsWith('welcome-');
            
            // Imported cards and welcome cards get 18px, all others get 23px
            textRuler.style.fontSize = (isImported || isWelcomeCard) ? '18px' : '23px';
            textRuler.style.lineHeight = '1.2';
            textRuler.style.padding = '0';
            textRuler.style.margin = '0';
            textRuler.style.border = 'none';
            textRuler.style.textAlign = 'center'; // Match Cytoscape text alignment
            textRuler.style.wordWrap = 'break-word';
            
            // Set the text and measure
            textRuler.textContent = fullLabel;
            const measuredTextHeight = textRuler.offsetHeight;
            
            // Add padding that Cytoscape applies to cards
            // Cards need minimum padding for visual breathing room
            const minCardHeight = 140; // 140px minimum height
            
            // Dynamic padding: less padding for longer text, more for short text
            let paddingBuffer;
            if (measuredTextHeight <= 50) {
                paddingBuffer = 25; // Short text needs more padding
            } else if (measuredTextHeight <= 100) {
                paddingBuffer = 20; // Medium text gets normal padding
            } else if (measuredTextHeight <= 200) {
                paddingBuffer = 15; // Long text needs less extra padding
            } else {
                paddingBuffer = 10; // Very long text needs minimal padding
            }
            
            const totalHeight = Math.max(minCardHeight, measuredTextHeight + paddingBuffer);
            
            // Cache the result
            heightCache.set(hash, totalHeight);
            
            return totalHeight;
        }
        
        // Subtle orphan prevention - use non-breaking spaces to keep last 2-3 words together
        function preventOrphansSubtly(text) {
            const words = text.split(' ');
            
            // If text is short, don't modify
            if (words.length <= 4) return text;
            
            // Join last 2-3 words with non-breaking spaces to prevent orphan words
            const lastWords = words.slice(-3); // Last 3 words
            const beforeWords = words.slice(0, -3); // Everything before last 3 words
            
            // Use non-breaking space (Unicode 00A0) to keep last words together
            const joinedLastWords = lastWords.join('\u00A0');
            
            return beforeWords.length > 0 ? 
                beforeWords.join(' ') + ' ' + joinedLastWords : 
                joinedLastWords;
        }
        
        // Sample data - strukturerade kort med titel och text (arrangerade med G+V layout)
        const initialCards = [
            {
                id: 'welcome-1',
                title: '👋 Välkommen till Spatial Notes!',
                text: 'Visuell anteckningsapp där du organiserar tankar i 2D-rum.\n\nBETA-VERSION: Allt funkar inte hundra. Spara ofta!\n\nHälsningar Ximon\n\nMail: spatial-notes@ximon.se\n\n(räkna inte med svar)',
                tags: ['välkommen'],
                x: 667,
                y: 193
            },
            {
                id: 'welcome-2', 
                title: '🎯 Grundläggande',
                text: 'SKAPA KORT: Klicka "Nytt kort" eller dubbelklicka i tom yta\n\nTA BORT: Välj kort → Delete-tangent\n\nMARKERA: Klicka kort (håll Ctrl för flera) eller dra-markera\n\nFLYTTA: Håll nere muspekare på det du vill flytta och flytta muspeklaren\n\nÅNGRA/GÖR OM: Ctrl+Z / Ctrl+Y',
                tags: ['grunderna'],
                x: 987,
                y: 204
            },
            {
                id: 'welcome-3',
                title: '📐 Arrangera Kort',
                text: 'Markera flera kort, tryck sedan:\n\nH = Horisontell rad (20% mellanrum)\nV = Vertikal kolumn (20% mellanrum)\n\nG+V = Grid Vertical (max 6 bred, 20% mellanrum)\nG+H = Grid Horizontal (rader, 20% mellan rader)\nG+T = Grid Tight (max 6 bred, 40px överlapp)\n\nQ = Kluster (sporadisk skräphög)\nQQ = Stack (prydlig hög, dubbla Q)\nAlt+S = Stack (samma som QQ)\n\nKorten arrangeras runt muspekaren!',
                tags: ['arrangemang'],
                x: 1307,
                y: 247
            },
            {
                id: 'welcome-4',
                title: '📌 Pinna Kort',
                text: 'PINNA: Högerklicka kort → "Pinna kort"\n\nUNPINNA: Högerklicka → "Ta bort pinning"\n\nFÖRDELAR:\n\nPinnae kort stannar på plats\n\nKopiera kort och pinna originalen\n\nFlytta kopior medan original är säkra\n\nPerfekt för att organisera idéer!',
                tags: ['pinning'],
                x: 667,
                y: 642
            },
            {
                id: 'welcome-5',
                title: '🚀 Next Level: Kopiera + Arrangera',
                text: '1. Markera kort du vill kopiera\n\n2. Tryck C för att kopiera\n\n3. Använd H, G+V, G+H, G+T eller Q\n\nKopiorna arrangeras runt muspekaren!',
                tags: ['kopiera', 'avancerat'],
                x: 987,
                y: 598
            },
            {
                id: 'welcome-6',
                title: '🔥 The Shit: Sök + Arrangera',
                text: '1. SÖK: Skriv i sökrutan för att hitta kort\n\n2. MARKERA: Tryck Enter för att välja alla sökresultat\n\n3. ARRANGERA: Använd H, G+V, G+H, G+T eller Q för att arrangera\n\n4. KOPIERA: Eller tryck C och arrangera kopior!\n\nDu kan också söka → kopiera → arrangera. Epic!',
                tags: ['sökning', 'expert'],
                x: 1307,
                y: 728
            }
        ];
        

        // Initialize Cytoscape
        function initCytoscape() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                
                elements: initialCards.map((card, index) => ({
                    data: {
                        id: card.id,
                        title: card.title || '',
                        text: card.text || '', 
                        tags: card.tags || [],
                        searchMatch: false,
                        // Hidden metadata for advanced analysis
                        export_timestamp: card.export_timestamp || null,
                        export_session: card.export_session || null,
                        export_source: card.export_source || null,
                        source_file: card.source_file || null,
                        page_number: card.page_number || null,
                        matched_terms: card.matched_terms || null,
                        card_index: card.card_index || null
                    },
                    position: {
                        x: card.x !== undefined ? card.x : (200 + (index % 3) * 300),
                        y: card.y !== undefined ? card.y : (200 + Math.floor(index / 3) * 200)
                    }
                })),
                
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#ffffff',
                            'border-width': 2,
                            'border-color': '#ddd',
                            'width': function(node) {
                                // Skip width override for annotation nodes (they have their own sizing)
                                if (node.data('isAnnotation')) {
                                    return node.data('customWidth') || 120;
                                }
                                // Fixed width for all cards to ensure consistency
                                return 300;
                            },
                            'height': function(node) {
                                // Skip height override for annotation nodes (they have their own sizing)
                                if (node.data('isAnnotation')) {
                                    return node.data('customHeight') || 120;
                                }
                                
                                const isManualCard = node.data('isManualCard') || false;
                                
                                if (isManualCard) {
                                    // Same padding logic as other cards, but with double padding
                                    const measuredHeight = getMeasuredTextHeight(node);
                                    return Math.max(140, measuredHeight + 40); // Double padding for larger text
                                }
                                
                                // Use the ruler to get exact height for other cards
                                const measuredHeight = getMeasuredTextHeight(node);
                                return Math.max(140, measuredHeight + 10); // Standard padding, 140px minimum
                            },
                            'shape': 'round-rectangle',
                            'label': function(node) {
                                const title = node.data('title') || '';
                                const text = node.data('text') || '';
                                const tags = node.data('tags') || [];
                                const isManualCard = node.data('isManualCard') || false;
                                
                                
                                // Simple markdown conversion for display
                                let displayText = text;
                                displayText = displayText.replace(/\*\*(.*?)\*\*/g, '$1'); // Remove **bold**
                                displayText = displayText.replace(/\*(.*?)\*/g, '$1'); // Remove *italic*
                                displayText = displayText.replace(/`(.*?)`/g, '$1'); // Remove `code`
                                displayText = displayText.replace(/^- /gm, '• '); // Convert - to bullets
                                
                                // Apply subtle orphan prevention using non-breaking spaces
                                displayText = preventOrphansSubtly(displayText);
                                
                                // Add tags at the bottom if they exist (filter out PDF filename tags)
                                let tagDisplay = '';
                                if (tags.length > 0) {
                                    // Filter out tags that look like PDF filenames (author-year-title format)
                                    const visibleTags = tags.filter(tag => {
                                        // Hide tags that match PDF filename pattern: Author-YYYY-title-words
                                        const pdfPattern = /^[A-Za-z\-]+\-\d{4}\-[a-z\-]+$/;
                                        return !pdfPattern.test(tag);
                                    });
                                    
                                    if (visibleTags.length > 0) {
                                        tagDisplay = '\n\n' + visibleTags.map(tag => `#${tag}`).join(' ');
                                    }
                                }
                                
                                // For manually created cards, show ONLY text (no title processing)
                                // For imported cards, show title in caps + text
                                const mainText = (isManualCard || !title) ? displayText : `${title.toUpperCase()}\n\n${displayText}`;
                                return mainText + tagDisplay;
                            },
                            'text-wrap': 'wrap',
                            'text-max-width': 285, // Fixed 285px for all cards to match getMeasuredTextHeight ruler
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': function(node) {
                                const isImported = node.data('export_source') === 'pdf_extractor' || 
                                                 node.data('source_file') || 
                                                 node.data('matched_terms');
                                const isWelcomeCard = node.id().startsWith('welcome-');
                                
                                // Imported cards and welcome cards get 18px
                                if (isImported || isWelcomeCard) {
                                    return 18;
                                }
                                
                                // ALL other cards (manual) get 23px
                                return 23;
                            },
                            'font-family': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                            'color': '#333'
                        }
                    },
                    {
                        selector: 'node.search-match',
                        style: {
                            'background-color': '#fff9c4',
                            'border-color': '#f57f17',
                            'border-width': 2
                        }
                    },
                    {
                        selector: 'node.tag-filtered',
                        style: {
                            'background-color': '#f0f0f0',
                            'border-color': '#ddd',
                            'opacity': 0.3
                        }
                    },
                    {
                        selector: 'node.search-non-match',
                        style: {
                            'opacity': 0.3
                        }
                    },
                    {
                        selector: 'node:selected',
                        style: {
                            'border-color': '#1565c0',
                            'border-width': 4
                        }
                    },
                    {
                        selector: 'node.pinned',
                        style: {
                            'border-color': '#2e7d32',
                            'border-width': 4,
                            'background-color': '#c8e6c9'
                        }
                    },
                    // ====================================================================================================
                    // 📷 IMAGE NODE STYLES - Post-it feel (~10cm) with image background
                    // ====================================================================================================
                    {
                        selector: 'node[type="image"]',
                        style: {
                            'width': 300, // Same as regular cards
                            'height': function(node) {
                                // Use the same logic as getMeasuredTextHeight for consistency
                                return getMeasuredTextHeight(node);
                            },
                            'background-image': 'data(imageData)',
                            'background-fit': 'cover',
                            'background-color': function(node) {
                                // Support color styling for image cards
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                    return colorValue;
                                }
                                return '#ffffff'; // Default white background
                            },
                            'border-width': function(node) {
                                // Thicker border when colored to show the color better
                                const cardColor = node.data('cardColor');
                                return cardColor ? 6 : 3;
                            },
                            'border-color': function(node) {
                                // Use the card color for border, or default gray
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                    return colorValue;
                                }
                                return '#ddd';
                            },
                            'shape': 'round-rectangle',
                            'label': function(node) {
                                // Only show annotation icon if present, no filename
                                const hasAnnotation = (node.data('annotation') || '').length > 0;
                                return hasAnnotation ? '📝' : '';
                            },
                            'text-valign': 'bottom',
                            'text-halign': 'center',
                            'text-background-color': 'rgba(255, 255, 255, 0.9)',
                            'text-background-padding': '4px',
                            'text-background-shape': 'round-rectangle',
                            'font-size': '14px',
                            'font-weight': 'bold',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': 280
                        }
                    },
                    {
                        selector: 'node[type="image"]:selected',
                        style: {
                            'border-color': '#1565c0',
                            'border-width': 5
                        }
                    },
                    {
                        selector: 'node[type="image"].search-match',
                        style: {
                            'border-color': '#f57f17',
                            'border-width': 4
                        }
                    },
                    // ====================================================================================================
                    // 🎨 ANNOTATION STYLES
                    // ====================================================================================================
                    {
                        selector: 'node.annotation-shape',
                        style: {
                            'width': function(node) {
                                // Allow dynamic width for annotation shapes
                                return node.data('customWidth') || 120;
                            },
                            'height': function(node) {
                                // Allow dynamic height for annotation shapes
                                return node.data('customHeight') || 120;
                            },
                            'background-color': '#ff6b6b',
                            'border-width': 3,
                            'border-color': '#444',
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '32px',
                            'color': '#333',
                            'text-wrap': 'none',
                            'z-index': function(node) {
                                // Cytoscape z-index must be non-negative integers
                                // 0 = background, 1 = normal, 2 = foreground
                                const zIndex = node.data('customZIndex');
                                if (zIndex === -1) return 0; // Background
                                if (zIndex === 0) return 1;  // Normal
                                if (zIndex === 1) return 2;  // Foreground
                                return 1; // Default to normal
                            },
                            'shape': function(node) {
                                const shape = node.data('shape') || 'rectangle';
                                const shapeMap = {
                                    'rect': 'rectangle',
                                    'circle': 'ellipse',
                                    'triangle': 'triangle',
                                    'diamond': 'diamond',
                                    'star': 'star',
                                    'hexagon': 'hexagon'
                                };
                                return shapeMap[shape] || 'rectangle';
                            }
                        }
                    },
                    {
                        selector: 'node.annotation-text',
                        style: {
                            'width': function(node) {
                                // Allow dynamic width for annotation text
                                return node.data('customWidth') || 180;
                            },
                            'height': function(node) {
                                // Allow dynamic height for annotation text
                                return node.data('customHeight') || 90;
                            },
                            'background-color': '#fff',
                            'border-width': 2,
                            'border-color': '#ccc',
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '18px',
                            'color': '#333',
                            'text-wrap': 'wrap',
                            'text-max-width': function(node) {
                                // Adjust text width based on node width
                                const width = node.data('customWidth') || 180;
                                return (width - 10) + 'px';
                            },
                            'shape': 'rectangle'
                        }
                    },
                    {
                        selector: 'edge.annotation-connection',
                        style: {
                            'width': 5,
                            'line-color': '#ff6b6b',
                            'target-arrow-color': '#ff6b6b',
                            'arrow-scale': 1.8,
                            'curve-style': 'bezier',
                            'control-point-step-size': 40
                        }
                    }
                ],
                
                layout: {
                    name: 'preset'
                },
                
                // Enable panning and zooming
                zoomingEnabled: true,
                userZoomingEnabled: true,
                wheelSensitivity: 0.3,
                minZoom: 0.1,
                maxZoom: 3,
                panningEnabled: false,  // Start with panning disabled
                userPanningEnabled: true,  // Keep user controls available
                boxSelectionEnabled: true,
                selectionType: 'additive',  // Allow multiple selection
                
                // Configure user interaction
                autoungrabify: false,
                autounselectify: false
            });
            
            // Make nodes draggable
            cy.nodes().grabify();
            
            // Save state before dragging starts (for undo support)
            cy.on('grab', 'node', function(evt) {
                saveState();
            });
            
            // Double-click to edit card
            cy.on('dblclick', 'node', function(evt) {
                const node = evt.target;
                console.log('🖱️ Double-click on node:', node.id(), 'isAnnotation:', node.data('isAnnotation'), 'classes:', node.classes());
                
                if (node.data('isAnnotation') && node.hasClass('annotation-text')) {
                    console.log('📝 Opening text editor for annotation text...');
                    editAnnotationText(node);
                } else {
                    console.log('📝 Opening card editor for regular node...');
                    editCard(node);
                }
            });
            
            // Right-click context menu
            cy.on('cxttap', 'node', function(evt) {
                evt.preventDefault();
                const node = evt.target;
                showContextMenu(evt.originalEvent || evt, node);
            });
            
            // Touch and hold to edit card on mobile
            let touchTimer = null;
            let touchedNode = null;
            
            cy.on('touchstart', 'node', function(evt) {
                touchedNode = evt.target;
                touchTimer = setTimeout(() => {
                    if (touchedNode) {
                        editCard(touchedNode);
                        touchedNode = null;
                    }
                }, 1000); // 1 second hold
            });
            
            cy.on('touchend touchmove', 'node', function(evt) {
                if (touchTimer) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
                if (evt.type === 'touchend') {
                    touchedNode = null;
                }
            });
            
            // Update selection info when selection changes
            cy.on('select unselect', 'node', function(evt) {
                updateSelectionInfo();
            });
            
            // ====================================================================================================
            // 🎨 ANNOTATION EVENT HANDLERS
            // ====================================================================================================
            
            // Canvas click for creating annotations
            cy.on('tap', function(evt) {
                if (!annotationToolbarVisible || annotationMode === 'select') return;
                
                // Only create on background, not on nodes
                if (evt.target === cy) {
                    const position = evt.position || evt.cyPosition;
                    
                    if (['rect', 'circle', 'triangle', 'diamond', 'star', 'hexagon'].includes(annotationMode)) {
                        createShapeAnnotation(annotationMode, position);
                    } else if (['text-small', 'text-medium', 'text-large'].includes(annotationMode)) {
                        createTextAnnotation(annotationMode, position);
                    }
                }
            });
            
            // Node click for connections
            cy.on('tap', 'node', function(evt) {
                if (!annotationToolbarVisible) return;
                
                const node = evt.target;
                
                if (annotationMode === 'arrow' || annotationMode === 'line') {
                    if (!connectionStartNode) {
                        // First click - select start node
                        connectionStartNode = node;
                        node.style('border-color', '#ff0000');
                        node.style('border-width', '4px');
                        console.log('🎯 Connection start node selected:', node.id());
                    } else if (connectionStartNode !== node) {
                        // Second click - create connection
                        createConnection(connectionStartNode, node, annotationMode);
                        
                        // Reset start node styling
                        connectionStartNode.style('border-color', '');
                        connectionStartNode.style('border-width', '');
                        connectionStartNode = null;
                        
                        console.log('✅ Connection created');
                    }
                }
            });
            
            // Track mouse position for arrangement positioning
            cy.on('mousemove', function(evt) {
                lastMousePosition.x = evt.originalEvent.clientX;
                lastMousePosition.y = evt.originalEvent.clientY;
            });
            
            // Also track mouse on the container directly
            document.addEventListener('mousemove', function(evt) {
                lastMousePosition.x = evt.clientX;
                lastMousePosition.y = evt.clientY;
                // Debug: uncomment to see if mouse tracking works
                // console.log('Mouse moved to:', evt.clientX, evt.clientY);
            });
            
            // ====================================================================================================
            // 🎨 ANNOTATION TOOLBAR EVENT LISTENERS
            // ====================================================================================================
            
            // Add click listeners to annotation tools
            document.querySelectorAll('.annotation-tool').forEach(tool => {
                tool.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const toolType = tool.dataset.tool;
                    
                    if (toolType.startsWith('color-')) {
                        // Color selection
                        const colors = {
                            'color-red': '#ff6b6b',
                            'color-blue': '#4ecdc4', 
                            'color-green': '#45b7d1',
                            'color-yellow': '#f9ca24',
                            'color-purple': '#a55eea'
                        };
                        setAnnotationColor(colors[toolType]);
                    } else if (toolType === 'resize') {
                        // Toggle resize mode
                        toggleResizeMode();
                        tool.classList.toggle('active', resizeMode);
                    } else {
                        // Tool selection
                        setAnnotationMode(toolType);
                    }
                });
            });
            
            // Starta med panorering på, så att zoom fungerar direkt
            cy.panningEnabled(true);
            
            // Auto-center on mobile devices after initial load
            if (window.matchMedia && window.matchMedia("(max-width: 768px)").matches) {
                setTimeout(() => {
                    cy.fit(null, 50); // Fit all nodes with 50px padding
                    cy.center(); // Center the view
                    console.log('Mobile auto-center applied');
                }, 500); // Small delay to ensure nodes are rendered
            }
            
            // Re-center when orientation changes on mobile
            window.addEventListener('orientationchange', function() {
                if (window.matchMedia && window.matchMedia("(max-width: 768px)").matches) {
                    setTimeout(() => {
                        cy.fit(null, 50);
                        cy.center();
                        console.log('Mobile orientation-change auto-center applied');
                    }, 300);
                }
            });

            // Hantera Ctrl+drag för att växla mellan panorering och markeringsruta
            cy.on('mousedown', function(evt) {
                if (evt.originalEvent.ctrlKey) {
                    // Med Ctrl nedtryckt: aktivera panorering, inaktivera markeringsruta
                    cy.boxSelectionEnabled(false);
                    cy.panningEnabled(true);
                } else {
                    // Utan Ctrl: inaktivera panorering, aktivera markeringsruta
                    cy.boxSelectionEnabled(true);
                    cy.panningEnabled(false);
                }
            });

            cy.on('mouseup', function(evt) {
                // Återställ alltid till att panorering är på, så att zoom fungerar igen
                cy.panningEnabled(true);
                cy.boxSelectionEnabled(true);
            });

            // ====================================================================================================
            // 📷 IMAGE SYSTEM EVENT LISTENERS - Integration with existing architecture
            // ====================================================================================================
            
            // File input change handlers
            document.getElementById('hiddenCameraInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleImageFiles(e.target.files);
                    // Reset input to allow same file again
                    e.target.value = '';
                }
            });
            
            document.getElementById('hiddenGalleryInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleImageFiles(e.target.files);
                    // Reset input to allow same file again
                    e.target.value = '';
                }
            });

            // Zotero HTML import file input handler
            document.getElementById('zoteroHtmlInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    importFromZoteroHTML(e.target.files[0]);
                    // Reset input to allow same file again
                    e.target.value = '';
                }
            });

            // Paste event listener for Ctrl+V images
            document.addEventListener('paste', handlePasteImage);
            
            // Long press on canvas to paste clipboard content (text or image)
            let canvasPressTimer = null;
            const cyContainer = document.getElementById('cy');
            
            // Canvas background long press using Cytoscape events
            let backgroundTouchTimer = null;
            let backgroundTouchPos = null;
            
            // Touch handling on canvas background (not on nodes)
            cy.on('touchstart', function(evt) {
                console.log('DEBUG touchstart:', evt.target, 'target===cy:', evt.target === cy, 'touches:', evt.originalEvent?.touches?.length);
                if (!evt.target || evt.target === cy) { // Background touch
                    const touch = evt.originalEvent.touches[0];
                    backgroundTouchPos = { clientX: touch.clientX, clientY: touch.clientY };
                    let backgroundTouchStartTime = Date.now();
                    console.log('DEBUG background touchstart, pos:', backgroundTouchPos);
                    
                    backgroundTouchTimer = setTimeout(() => {
                        console.log('DEBUG LONG PRESS timeout fired, isMobileDevice():', isMobileDevice(), 'backgroundTouchPos:', backgroundTouchPos);
                        if (isMobileDevice() && backgroundTouchPos) {
                            // Check if we have selected cards
                            const selectedNodes = cy.$('node:selected');
                            console.log('DEBUG selectedNodes.length:', selectedNodes.length);
                            if (selectedNodes.length > 0) {
                                // Show mobile card menu for selected cards
                                console.log('DEBUG calling showMobileCardMenu with pos:', backgroundTouchPos, 'nodeId:', selectedNodes[0].id());
                                showMobileCardMenu(backgroundTouchPos, selectedNodes[0].id());
                            } else {
                                // Show image source menu if no cards selected
                                console.log('DEBUG calling showImageSourceMenu');
                                showImageSourceMenu(backgroundTouchPos.clientX, backgroundTouchPos.clientY);
                            }
                        }
                        backgroundTouchStartTime = null; // Mark as long press handled
                    }, 1000);
                    
                    // Store start time for short tap detection
                    evt._boardTouchStartTime = backgroundTouchStartTime;
                }
            });
            
            cy.on('touchend', function(evt) {
                if (backgroundTouchTimer) {
                    clearTimeout(backgroundTouchTimer);
                    backgroundTouchTimer = null;
                }
                
                if (backgroundTouchPos && evt._boardTouchStartTime && (!evt.target || evt.target === cy)) {
                    const tapDuration = Date.now() - evt._boardTouchStartTime;
                    console.log('DEBUG board background touch end, duration:', tapDuration);
                    
                    if (tapDuration < 300) { // Short tap
                        console.log('DEBUG board background short tap - deselecting all cards');
                        cy.nodes().unselect();
                    }
                }
                
                backgroundTouchPos = null;
            });
            
            cy.on('touchmove', function(evt) {
                if (backgroundTouchTimer) {
                    clearTimeout(backgroundTouchTimer);
                    backgroundTouchTimer = null;
                    backgroundTouchPos = null;
                }
            });
            
            // Desktop mouse handling on background
            cy.on('mousedown', function(evt) {
                if (!evt.target || evt.target === cy) { // Background click
                    const mouseEvent = evt.originalEvent;
                    let mouseDownTime = Date.now();
                    
                    canvasPressTimer = setTimeout(() => {
                        if (!isMobileDevice()) {
                            pasteClipboardContent(mouseEvent.clientX, mouseEvent.clientY);
                        }
                        mouseDownTime = null; // Mark as long press handled
                    }, 1000);
                    
                    evt._mouseDownTime = mouseDownTime;
                }
            });
            
            cy.on('mouseup', function(evt) {
                if (canvasPressTimer) {
                    clearTimeout(canvasPressTimer);
                    canvasPressTimer = null;
                }
                
                if (evt._mouseDownTime && (!evt.target || evt.target === cy)) {
                    const clickDuration = Date.now() - evt._mouseDownTime;
                    console.log('DEBUG board background click end, duration:', clickDuration);
                    
                    if (clickDuration < 300) { // Short click
                        console.log('DEBUG board background short click - deselecting all cards');
                        cy.nodes().unselect();
                    }
                }
            });
            
            cy.on('mousemove', function(evt) {
                if (canvasPressTimer) {
                    clearTimeout(canvasPressTimer);
                    canvasPressTimer = null;
                }
            });
            
            // Drag and drop support (bonus functionality)
            // cyContainer already declared above
            cyContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
            
            cyContainer.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type.startsWith('image/')
                );
                
                if (files.length > 0) {
                    handleImageFiles(files);
                    console.log(`📷 ${files.length} bild(er) droppade`);
                }
            });
            
            // Background click events temporarily disabled to test zoom
            // TODO: Re-enable with zoom preservation
            
            // Disable context menu on right click
            cy.container().addEventListener('contextmenu', function(evt) {
                evt.preventDefault();
            });
            
            // ====================================================================================================
            // 🎯 SIMPLE RESIZE SYSTEM
            // ====================================================================================================
            
            // Setup simple resize functionality using mouse events
            console.log('🔄 Setting up simple resize functionality...');
            setupFallbackResize();
            
            
        }
        
        // Boolean search functionality
        function performSearch(query) {
            if (!query.trim()) {
                clearSearch();
                return;
            }
            
            searchActive = true;
            let matchCount = 0;
            
            cy.nodes().forEach(node => {
                const title = (node.data('title') || '').toLowerCase();
                const text = (node.data('text') || '').toLowerCase();
                const tags = (node.data('tags') || []).join(' ').toLowerCase();
                const hiddenTags = (node.data('hidden_tags') || []).join(' ').toLowerCase();
                
                // IMAGE SEARCH INTEGRATION - Add image annotation and filename to searchable text
                const imageAnnotation = (node.data('annotation') || '').toLowerCase();
                const originalFileName = (node.data('originalFileName') || '').toLowerCase();
                const searchableImageText = imageAnnotation + ' ' + originalFileName;
                
                const searchableText = title + ' ' + text + ' ' + tags + ' ' + hiddenTags + ' ' + searchableImageText;
                
                const matches = evaluateBooleanQuery(query.toLowerCase(), searchableText);
                
                if (matches) {
                    node.addClass('search-match');
                    node.removeClass('search-non-match'); // Remove blur if it was there
                    node.data('searchMatch', true);
                    // Don't select directly - let ESC convert to selected
                    matchCount++;
                } else {
                    node.removeClass('search-match');
                    node.addClass('search-non-match'); // Add blur for non-matches
                    node.data('searchMatch', false);
                    node.unselect(); // Avmarkera kortet
                }
            });
            
            // Show search results info
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `${matchCount} kort hittade`;
            searchInfo.classList.add('visible');
            
            // Show/hide mobile select button
            const selectBtn = document.getElementById('searchSelectBtn');
            if (matchCount > 0) {
                selectBtn.style.display = 'inline-block';
            } else {
                selectBtn.style.display = 'none';
            }
            
            // Apply smart sorting to search results if in column view
            if (isColumnView && matchCount > 0) {
                applySmartSearchSorting();
            }
        }
        
        // Smart search sorting: week+todo priorities, then color order
        function applySmartSearchSorting() {
            // Get all search-matched nodes
            const matchedNodes = cy.nodes('.search-match').toArray();
            
            // Sort with complex priority system
            const sortedNodes = matchedNodes.sort((a, b) => {
                // Priority 1: Week tags + todo tags (oldest week first)
                const aWeekTodo = getWeekTodoPriority(a);
                const bWeekTodo = getWeekTodoPriority(b);
                if (aWeekTodo !== bWeekTodo) {
                    return aWeekTodo - bWeekTodo; // Lower number = higher priority
                }
                
                // Priority 2: Color order (röd, orange, vit, gul, lila, blå, grön, grå)
                const aColor = getColorPriority(a);
                const bColor = getColorPriority(b);
                return aColor - bColor;
            });
            
            // Apply visual order in column view
            if (isColumnView) {
                setTimeout(() => {
                    renderColumnView(); // This will use the sorted order
                }, 50);
            }
        }
        
        function getWeekTodoPriority(node) {
            const tags = (node.data('tags') || []).map(tag => tag.toLowerCase());
            const hasTodo = tags.some(tag => tag.includes('todo'));
            
            if (!hasTodo) return 1000; // No todo = lowest priority
            
            // Find week tags (format: 25v40, 24v52, etc.)
            const weekTags = tags.filter(tag => /\d{2}v\d{1,2}/.test(tag));
            if (weekTags.length === 0) return 500; // Todo but no week = medium priority
            
            // Get earliest week number for sorting
            let earliestWeek = 9999;
            weekTags.forEach(weekTag => {
                const match = weekTag.match(/(\d{2})v(\d{1,2})/);
                if (match) {
                    const year = parseInt(match[1]);
                    const week = parseInt(match[2]);
                    const sortValue = year * 100 + week; // 2540 for 25v40
                    earliestWeek = Math.min(earliestWeek, sortValue);
                }
            });
            
            return earliestWeek; // Lower week number = higher priority
        }
        
        function getColorPriority(node) {
            const cardColor = node.data('cardColor');
            if (!cardColor) return 8; // No color = lowest color priority
            
            // Extract color number (card-color-3 -> 3)
            const colorMatch = cardColor.match(/card-color-(\d)/);
            if (!colorMatch) return 8;
            
            const colorNum = parseInt(colorMatch[1]);
            
            // Color priority order: röd(3), orange(2), vit(8), gul(4), lila(5), blå(6), grön(1), grå(7)
            const colorOrder = {
                3: 1, // röd
                2: 2, // orange  
                8: 3, // vit
                4: 4, // gul
                5: 5, // lila
                6: 6, // blå
                1: 7, // grön
                7: 8  // grå
            };
            
            return colorOrder[colorNum] || 9;
        }
        
        // Boolean query evaluation
        function evaluateBooleanQuery(query, searchableText) {
            // Handle different boolean operators
            
            // Split by OR first (lowest precedence)
            if (query.includes(' or ')) {
                const orParts = query.split(' or ');
                return orParts.some(part => evaluateBooleanQuery(part.trim(), searchableText));
            }
            
            // Handle NOT operations - improved logic
            if (query.includes(' not ')) {
                const notIndex = query.indexOf(' not ');
                const beforeNot = query.substring(0, notIndex).trim();
                const afterNot = query.substring(notIndex + 5).trim(); // ' not '.length = 5
                
                // If there's something before NOT, it must match
                let beforeMatches = true;
                if (beforeNot) {
                    beforeMatches = evaluateBooleanQuery(beforeNot, searchableText);
                }
                
                // The part after NOT must NOT match
                const afterMatches = evaluateBooleanQuery(afterNot, searchableText);
                
                return beforeMatches && !afterMatches;
            }
            
            // Handle AND operations (default behavior and explicit)
            const andParts = query.includes(' and ') ? 
                query.split(' and ') : 
                query.split(' ').filter(term => term.length > 0);
                
            return andParts.every(term => {
                term = term.trim();
                if (term.startsWith('"') && term.endsWith('"')) {
                    // Exact phrase search
                    const phrase = term.slice(1, -1);
                    return searchableText.includes(phrase);
                } else {
                    // Regular word search
                    return searchableText.includes(term);
                }
            });
        }
        
        // Pin/unpin functionality
        function pinCard(node) {
            node.addClass('pinned');
            node.data('pinned', true);
            node.ungrabify(); // Prevent dragging
        }

        function unpinCard(node) {
            node.removeClass('pinned');
            node.data('pinned', false);
            node.grabify(); // Allow dragging again
        }
        
        // Context Menu System
        function showContextMenu(event, node) {
            // Remove any existing context menu
            hideContextMenu();
            
            // Get mouse position
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.position = 'fixed';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.zIndex = '3000';
            
            // Pin/Unpin option
            const isPinned = node.hasClass('pinned');
            const pinOption = document.createElement('div');
            pinOption.className = 'context-menu-item';
            pinOption.innerHTML = isPinned ? '📌 Ta bort pinning' : '📌 Pinna kort';
            pinOption.onclick = () => {
                if (isPinned) {
                    unpinCard(node);
                } else {
                    pinCard(node);
                }
                hideContextMenu();
            };
            menu.appendChild(pinOption);
            
            // Color option
            const colorOption = document.createElement('div');
            colorOption.className = 'context-menu-item';
            colorOption.innerHTML = '🎨 Färga kort';
            colorOption.onclick = () => {
                hideContextMenu();
                // If the right-clicked node is selected, color all selected nodes
                // Otherwise, color just the right-clicked node
                const selectedNodes = cy.$('node:selected');
                const nodesToColor = node.selected() && selectedNodes.length > 1 ? selectedNodes : [node];
                showColorPicker(event, nodesToColor);
            };
            menu.appendChild(colorOption);
            
            // Remove color option (if card has color)
            if (node.data('cardColor')) {
                const removeColorOption = document.createElement('div');
                removeColorOption.className = 'context-menu-item';
                removeColorOption.innerHTML = '❌ Ta bort färg';
                removeColorOption.onclick = () => {
                    // If the right-clicked node is selected, remove color from all selected nodes
                    // Otherwise, remove color from just the right-clicked node
                    const selectedNodes = cy.$('node:selected');
                    const nodesToProcess = node.selected() && selectedNodes.length > 1 ? selectedNodes : [node];
                    nodesToProcess.forEach(n => removeCardColor(n));

                    // Save immediately to prevent data loss from autosave/Drive sync
                    saveBoard();

                    hideContextMenu();
                };
                menu.appendChild(removeColorOption);
            }

            // Resize option for image nodes
            if (node.data('type') === 'image' || node.data('isImageCard')) {
                const resizeOption = document.createElement('div');
                resizeOption.className = 'context-menu-item';
                resizeOption.innerHTML = '↗️ Ändra storlek';
                resizeOption.onclick = () => {
                    hideContextMenu();
                    showImageResizeDialog(node);
                };
                menu.appendChild(resizeOption);
            }

            // Resize option for annotation/geometric shapes
            if (node.data('isAnnotation') && node.data('annotationType') !== 'connection') {
                const resizeOption = document.createElement('div');
                resizeOption.className = 'context-menu-item';
                resizeOption.innerHTML = '↗️ Ändra storlek';
                resizeOption.onclick = () => {
                    hideContextMenu();
                    showResizeDialog(node);
                };
                menu.appendChild(resizeOption);
                
                // Font size option for geometric shapes
                const fontSizeOption = document.createElement('div');
                fontSizeOption.className = 'context-menu-item';
                fontSizeOption.innerHTML = '🔤 Ändra fontstorlek';
                fontSizeOption.onclick = () => {
                    hideContextMenu();
                    showFontSizeDialog(node);
                };
                menu.appendChild(fontSizeOption);
            }
            
            // Arrow visibility toggle (global option)
            const arrowToggleOption = document.createElement('div');
            arrowToggleOption.className = 'context-menu-item';
            const arrowsVisible = !window.arrowsHidden;
            arrowToggleOption.innerHTML = arrowsVisible ? '👁️ Dölj pilar' : '👁️ Visa pilar';
            arrowToggleOption.onclick = () => {
                hideContextMenu();
                toggleArrowVisibility();
            };
            menu.appendChild(arrowToggleOption);
            
            // Remove arrows between selected cards (if multiple cards selected)
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length > 1) {
                const removeArrowsOption = document.createElement('div');
                removeArrowsOption.className = 'context-menu-item';
                removeArrowsOption.innerHTML = '🗑️ Ta bort pilar mellan markerade';
                removeArrowsOption.onclick = () => {
                    hideContextMenu();
                    removeArrowsBetweenSelected();
                };
                menu.appendChild(removeArrowsOption);
                
                // Bulk tag option for multiple selected cards
                const bulkTagOption = document.createElement('div');
                bulkTagOption.className = 'context-menu-item';
                bulkTagOption.innerHTML = '🏷️ Lägg till tagg på alla markerade';
                bulkTagOption.onclick = () => {
                    hideContextMenu();
                    showBulkTagDialog(selectedNodes);
                };
                menu.appendChild(bulkTagOption);
            }
            
            document.body.appendChild(menu);
            
            // Close menu on click elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }
        
        function hideContextMenu() {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
        }
        
        // Resize dialog for geometric shapes
        function showResizeDialog(node) {
            // Get current size or defaults
            const currentWidth = node.data('customWidth') || 120;
            const currentHeight = node.data('customHeight') || 120;
            const currentZIndex = node.data('customZIndex') || -1;
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; text-align: center;">↗️ Ändra storlek & lager</h3>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Bredd (px):</label>
                    <input type="number" id="resizeWidth" value="${currentWidth}" min="20" max="500" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Höjd (px):</label>
                    <input type="number" id="resizeHeight" value="${currentHeight}" min="20" max="500" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Lagerhöjd:</label>
                    <select id="layerSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="-1" ${currentZIndex === -1 ? 'selected' : ''}>🔻 Bakgrund (under kort)</option>
                        <option value="0" ${currentZIndex === 0 ? 'selected' : ''}>📄 Normal nivå</option>
                        <option value="1" ${currentZIndex === 1 ? 'selected' : ''}>🔺 Förgrund (över kort)</option>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">Bakgrund: figurerna hamnar under korten som underlägg</small>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="keepAspectRatio" checked>
                        <span>Behåll proportioner</span>
                    </label>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelResize" style="padding: 10px 20px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="applyResize" style="padding: 10px 20px; border: none; background: #007acc; color: white; border-radius: 4px; cursor: pointer;">Tillämpa</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus first input
            const widthInput = document.getElementById('resizeWidth');
            const heightInput = document.getElementById('resizeHeight');
            const aspectCheckbox = document.getElementById('keepAspectRatio');
            widthInput.focus();
            
            // Keep aspect ratio functionality
            const originalAspectRatio = currentWidth / currentHeight;
            
            widthInput.addEventListener('input', () => {
                if (aspectCheckbox.checked) {
                    heightInput.value = Math.round(widthInput.value / originalAspectRatio);
                }
            });
            
            heightInput.addEventListener('input', () => {
                if (aspectCheckbox.checked) {
                    widthInput.value = Math.round(heightInput.value * originalAspectRatio);
                }
            });
            
            // Handle buttons
            document.getElementById('cancelResize').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('applyResize').onclick = () => {
                const newWidth = parseInt(widthInput.value) || currentWidth;
                const newHeight = parseInt(heightInput.value) || currentHeight;
                const newZIndex = parseInt(document.getElementById('layerSelect').value);
                
                // Apply resize and layer change
                resizeAnnotationNode(node, newWidth, newHeight, newZIndex);
                
                document.body.removeChild(overlay);
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyResize').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }

        // Show resize dialog for image nodes (maintains aspect ratio)
        function showImageResizeDialog(node) {
            // Get current and original dimensions
            const currentWidth = node.data('displayWidth') || 300;
            const imageWidth = node.data('imageWidth');
            const imageHeight = node.data('imageHeight');
            const aspectRatio = imageHeight / imageWidth;
            const currentHeight = Math.round(currentWidth * aspectRatio);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;

            dialog.innerHTML = `
                <h3 style="margin-top: 0; text-align: center;">📏 Ändra bildstorlek</h3>
                <p style="color: #666; font-size: 13px; margin-bottom: 15px;">Original: ${imageWidth}×${imageHeight}px</p>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Bredd (px):</label>
                    <input type="range" id="imageWidthSlider" min="100" max="800" value="${currentWidth}" step="10"
                           style="width: 100%; margin-bottom: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <input type="number" id="imageWidthInput" value="${currentWidth}" min="100" max="800"
                               style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                        <span id="imageDimensions" style="color: #666; font-size: 13px;">${currentWidth}×${currentHeight}px</span>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <p style="color: #888; font-size: 12px; margin: 0;">
                        ℹ️ Proportionerna bevaras automatiskt
                    </p>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelImageResize" style="padding: 10px 20px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="applyImageResize" style="padding: 10px 20px; border: none; background: #007acc; color: white; border-radius: 4px; cursor: pointer;">Tillämpa</button>
                </div>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // Get elements
            const widthSlider = document.getElementById('imageWidthSlider');
            const widthInput = document.getElementById('imageWidthInput');
            const dimensionsDisplay = document.getElementById('imageDimensions');

            // Update display when slider or input changes
            const updateDimensions = () => {
                const width = parseInt(widthSlider.value);
                const height = Math.round(width * aspectRatio);
                widthInput.value = width;
                dimensionsDisplay.textContent = `${width}×${height}px`;
            };

            widthSlider.addEventListener('input', updateDimensions);
            widthInput.addEventListener('input', () => {
                widthSlider.value = widthInput.value;
                updateDimensions();
            });

            // Handle buttons
            document.getElementById('cancelImageResize').onclick = () => {
                document.body.removeChild(overlay);
            };

            document.getElementById('applyImageResize').onclick = () => {
                const newWidth = parseInt(widthSlider.value);
                const newHeight = Math.round(newWidth * aspectRatio);

                // Update node data and styling
                node.data('displayWidth', newWidth);
                node.data('displayHeight', newHeight);
                node.style({
                    'width': newWidth + 'px',
                    'height': newHeight + 'px'
                });

                console.log(`📏 Resized image to ${newWidth}×${newHeight}px`);
                saveBoard(); // Save changes

                document.body.removeChild(overlay);
            };

            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape' && document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);

            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter' && document.body.contains(overlay)) {
                    document.getElementById('applyImageResize').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);

            // Focus input
            widthInput.focus();
            widthInput.select();
        }

        // Apply resize and layer change to annotation node
        function resizeAnnotationNode(node, newWidth, newHeight, newZIndex = null) {
            console.log('🔧 Resizing annotation node:', node.id(), 'to', newWidth, 'x', newHeight, 'z-index:', newZIndex);
            
            // Store the new size and layer in node data
            node.data('customWidth', newWidth);
            node.data('customHeight', newHeight);
            if (newZIndex !== null) {
                node.data('customZIndex', newZIndex);
            }
            
            // Update the visual properties using Cytoscape style
            cy.batch(() => {
                const styleUpdate = {
                    'width': newWidth + 'px',
                    'height': newHeight + 'px'
                };
                
                if (newZIndex !== null) {
                    // Convert internal z-index to Cytoscape z-index
                    let cyZIndex = 1; // default
                    if (newZIndex === -1) cyZIndex = 0; // Background
                    if (newZIndex === 0) cyZIndex = 1;  // Normal
                    if (newZIndex === 1) cyZIndex = 2;  // Foreground
                    styleUpdate['z-index'] = cyZIndex;
                }
                
                node.style(styleUpdate);
            });
            
            const layerName = newZIndex === -1 ? 'bakgrund' : newZIndex === 0 ? 'normal' : 'förgrund';
            console.log('✅ Resize and layer change applied successfully, now in:', layerName);
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Font size dialog for geometric shapes
        function showFontSizeDialog(node) {
            // Get current font size or default
            const currentFontSize = node.style('font-size') || '16px';
            const currentFontSizeValue = parseInt(currentFontSize.replace('px', ''));
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 350px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">🔤 Ändra fontstorlek</h3>
                <div style="margin: 20px 0;">
                    <label for="fontSizeInput" style="display: block; margin-bottom: 5px; font-weight: bold;">Fontstorlek (px):</label>
                    <input type="number" id="fontSizeInput" value="${currentFontSizeValue}" min="8" max="72" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <div style="text-align: right; margin-top: 25px;">
                    <button id="cancelFontSize" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">Avbryt</button>
                    <button id="applyFontSize" style="padding: 8px 16px; border: none; border-radius: 5px; background: #007bff; color: white; cursor: pointer;">Tillämpa</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the input
            document.getElementById('fontSizeInput').focus();
            document.getElementById('fontSizeInput').select();
            
            // Cancel button
            document.getElementById('cancelFontSize').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            // Apply button
            document.getElementById('applyFontSize').onclick = () => {
                const fontSizeInput = document.getElementById('fontSizeInput');
                const newFontSize = parseInt(fontSizeInput.value) || currentFontSizeValue;
                
                // Apply font size change
                changeFontSize(node, newFontSize);
                
                document.body.removeChild(overlay);
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyFontSize').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }
        
        // Apply font size change to geometric shape
        function changeFontSize(node, newFontSize) {
            console.log('🔤 Changing font size for node:', node.id(), 'to', newFontSize + 'px');
            
            // Store the new font size in node data for persistence
            node.data('customFontSize', newFontSize);
            
            // Update the visual properties using Cytoscape style
            cy.batch(() => {
                node.style('font-size', newFontSize + 'px');
            });
            
            console.log('✅ Font size changed successfully to:', newFontSize + 'px');
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Arrow visibility toggle
        function toggleArrowVisibility() {
            console.log('👁️ Toggling arrow visibility...');
            
            const edges = cy.edges();
            const currentOpacity = edges.length > 0 ? edges[0].style('opacity') : 1;
            const newOpacity = currentOpacity == 0 ? 1 : 0;
            
            cy.batch(() => {
                edges.style('opacity', newOpacity);
            });
            
            // Store visibility state globally
            window.arrowsHidden = newOpacity == 0;
            
            console.log('✅ Arrows', newOpacity == 0 ? 'hidden' : 'visible');
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Remove arrows between selected cards
        function removeArrowsBetweenSelected() {
            const selectedNodes = cy.$('node:selected');
            const selectedNodeIds = new Set(selectedNodes.map(node => node.id()));
            
            console.log('🗑️ Removing arrows between', selectedNodes.length, 'selected cards...');
            
            // Find edges that connect any two selected nodes
            const edgesToRemove = cy.edges().filter(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                return selectedNodeIds.has(sourceId) && selectedNodeIds.has(targetId);
            });
            
            console.log('Found', edgesToRemove.length, 'arrows to remove between selected cards');
            
            if (edgesToRemove.length > 0) {
                cy.batch(() => {
                    edgesToRemove.remove();
                });
                
                console.log('✅ Removed', edgesToRemove.length, 'arrows between selected cards');
                
                // Save the board to persist changes
                saveBoard();
            } else {
                console.log('ℹ️ No arrows found between selected cards');
            }
        }
        
        // Bulk tag dialog for multiple selected cards
        function showBulkTagDialog(selectedNodes) {
            console.log('🏷️ Opening bulk tag dialog for', selectedNodes.length, 'cards');
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">🏷️ Lägg till tagg</h3>
                <p style="color: #666; margin-bottom: 20px;">Lägg till samma tagg på alla ${selectedNodes.length} markerade kort</p>
                <div style="margin: 20px 0;">
                    <label for="bulkTagInput" style="display: block; margin-bottom: 5px; font-weight: bold;">Tagg namn:</label>
                    <input type="text" id="bulkTagInput" placeholder="skriv tagg här..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                    <small style="color: #888; display: block; margin-top: 5px;">Tips: använd inga mellanslag, t.ex. "viktigt" eller "projekt2025"</small>
                </div>
                <div style="text-align: right; margin-top: 25px;">
                    <button id="cancelBulkTag" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">Avbryt</button>
                    <button id="applyBulkTag" style="padding: 8px 16px; border: none; border-radius: 5px; background: #007bff; color: white; cursor: pointer;">Lägg till tagg</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the input
            const tagInput = document.getElementById('bulkTagInput');
            tagInput.focus();
            
            // Cancel button
            document.getElementById('cancelBulkTag').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            // Apply button
            document.getElementById('applyBulkTag').onclick = () => {
                const tagName = tagInput.value.trim();
                if (tagName) {
                    applyBulkTag(selectedNodes, tagName);
                    document.body.removeChild(overlay);
                } else {
                    tagInput.style.borderColor = 'red';
                    tagInput.focus();
                }
            };
            
            // ESC to close
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Enter to apply
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('applyBulkTag').click();
                    document.removeEventListener('keydown', handleEnter);
                }
            };
            document.addEventListener('keydown', handleEnter);
        }
        
        // Apply bulk tag to multiple cards
        function applyBulkTag(selectedNodes, tagName) {
            console.log('🏷️ Applying tag "' + tagName + '" to', selectedNodes.length, 'cards');
            
            let addedCount = 0;
            let skippedCount = 0;
            
            selectedNodes.forEach(node => {
                const currentTags = node.data('tags') || [];
                
                // Check if tag already exists (case insensitive)
                const tagExists = currentTags.some(tag => 
                    tag.toLowerCase() === tagName.toLowerCase()
                );
                
                if (!tagExists) {
                    // Add the tag
                    const newTags = [...currentTags, tagName];
                    node.data('tags', newTags);
                    
                    // Apply auto-gray coloring for #done tags
                    applyAutoDoneColoring(node);
                    
                    addedCount++;
                    console.log(`Added tag "${tagName}" to card: ${node.data('title') || node.id()}`);
                } else {
                    skippedCount++;
                    console.log(`Tag "${tagName}" already exists on card: ${node.data('title') || node.id()}`);
                }
            });
            
            // Show success message
            const searchInfo = document.getElementById('searchInfo');
            let message = `🏷️ Tagg "${tagName}" tillagd på ${addedCount} kort`;
            if (skippedCount > 0) {
                message += ` (${skippedCount} kort hade redan taggen)`;
            }
            
            searchInfo.textContent = message;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 3000);
            
            console.log(`✅ Bulk tag completed: ${addedCount} added, ${skippedCount} skipped`);
            
            // Save the board to persist changes
            saveBoard();
        }
        
        // Color picker system
        function showColorPicker(event, nodes) {
            console.log('showColorPicker called with', nodes.length, 'nodes');
            
            // Remove any existing color picker
            hideColorPicker();
            
            // Get mouse position or use event position
            const x = event.clientX || event.pageX || window.innerWidth / 2;
            const y = event.clientY || event.pageY || window.innerHeight / 2;
            console.log('Color picker position:', x, y);
            
            // Create color picker popup
            const picker = document.createElement('div');
            picker.className = 'color-picker-popup';
            picker.style.position = 'fixed';
            picker.style.left = x + 'px';
            picker.style.top = y + 'px';
            picker.style.zIndex = '4000';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'color-picker-title';
            title.textContent = `Välj färg för ${nodes.length} kort`;
            picker.appendChild(title);
            
            // Create color grid
            const colorGrid = document.createElement('div');
            colorGrid.className = 'color-picker-grid';
            
            // Add the 8 color options
            for (let i = 1; i <= 8; i++) {
                const colorDot = document.createElement('div');
                colorDot.className = `color-picker-dot card-color-${i}`;
                colorDot.textContent = i; // Add number inside the dot
                colorDot.style.lineHeight = '26px'; // Center vertically
                colorDot.style.textAlign = 'center'; // Center horizontally
                colorDot.style.fontSize = '14px';
                colorDot.style.fontWeight = 'bold';
                colorDot.style.color = '#333';
                colorDot.style.textShadow = '0 0 3px rgba(255,255,255,0.8)';
                colorDot.onclick = () => {
                    console.log(`Clicked color ${i}, applying to ${nodes.length} cards`);
                    // Apply color to all nodes
                    nodes.forEach(node => {
                        console.log(`Setting color card-color-${i} on node:`, node.id());
                        node.data('cardColor', `card-color-${i}`);
                        // Update cytoscape styling immediately
                        const colorValue = getCardColorValue(`card-color-${i}`, getCurrentTheme());
                        console.log(`Color value:`, colorValue);
                        node.style('background-color', colorValue);
                    });

                    // Save immediately to prevent data loss from autosave/Drive sync
                    saveBoard();

                    hideColorPicker();
                    console.log(`Applied color ${i} to ${nodes.length} cards`);
                };
                colorGrid.appendChild(colorDot);
            }
            
            picker.appendChild(colorGrid);
            
            // Add cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'color-picker-cancel';
            cancelBtn.textContent = 'Avbryt';
            cancelBtn.onclick = hideColorPicker;
            picker.appendChild(cancelBtn);
            
            console.log('Adding picker to body:', picker);
            document.body.appendChild(picker);
            console.log('Picker added, should be visible now');
            
            // Close picker on click elsewhere
            setTimeout(() => {
                currentClickHandler = function(e) {
                    if (!picker.contains(e.target)) {
                        hideColorPicker();
                    }
                };
                document.addEventListener('click', currentClickHandler);
            }, 100);
        }
        
        let currentClickHandler = null;
        
        function hideColorPicker() {
            const existingPicker = document.querySelector('.color-picker-popup');
            if (existingPicker) {
                existingPicker.remove();
            }
            // Remove the click handler if it exists
            if (currentClickHandler) {
                document.removeEventListener('click', currentClickHandler);
                currentClickHandler = null;
            }
            console.log('Color picker hidden and event listeners cleaned up');
        }
        
        function removeCardColor(node) {
            node.removeData('cardColor');
            // Reset to default theme color
            const theme = getCurrentTheme();
            const defaultColor = theme === 'dark' ? '#2a2a2a' : (theme === 'sepia' ? '#f5f5dc' : '#ffffff');
            node.style('background-color', defaultColor);
            console.log('Removed color from card:', node.id());
        }
        
        function getCurrentTheme() {
            if (document.body.classList.contains('dark-theme')) return 'dark';
            if (document.body.classList.contains('sepia-theme')) return 'sepia';
            if (document.body.classList.contains('eink-theme')) return 'eink';
            return 'light';
        }
        
        // Multi-card paste dialog
        function showMultiCardPasteDialog() {
            // Remove any existing dialog
            const existingDialog = document.querySelector('.multi-card-paste-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'multi-card-paste-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 5000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                width: 90%;
                max-width: 600px;
                max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">Skapa flera kort från text</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    Klistra in text. Två tomma rader = nytt kort.<br>
                    Sista raden med #tagg1 #tagg2 blir riktiga taggar.
                </p>
                <textarea id="multiCardText" placeholder="Första anteckningen här...

Andra anteckningen...
#work #urgent

Tredje anteckningen...
#personal #todo" style="
                    width: 100%;
                    height: 300px;
                    padding: 10px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-family: monospace;
                    font-size: 14px;
                    resize: vertical;
                    box-sizing: border-box;
                "></textarea>
                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelMultiCard" style="
                        padding: 8px 16px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Avbryt</button>
                    <button id="createMultiCards" style="
                        padding: 8px 16px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Skapa kort</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus textarea
            const textarea = document.getElementById('multiCardText');
            textarea.focus();
            
            // Event handlers
            document.getElementById('cancelMultiCard').onclick = () => {
                overlay.remove();
            };
            
            document.getElementById('createMultiCards').onclick = () => {
                const text = textarea.value.trim();
                if (text) {
                    createMultipleCardsFromText(text);
                    overlay.remove();
                } else {
                    alert('Skriv in lite text först!');
                }
            };
            
            // Close on Escape
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
        }
        
        // Parse and create multiple cards from text
        function createMultipleCardsFromText(text) {
            // Split on double line breaks (two consecutive newlines)
            const blocks = text.split(/\n\s*\n/).filter(block => block.trim());
            
            console.log('Found', blocks.length, 'text blocks');
            
            let createdCount = 0;
            const startPosition = { x: 200, y: 200 };
            
            blocks.forEach((block, index) => {
                const lines = block.trim().split('\n');
                const lastLine = lines[lines.length - 1].trim();
                
                let cardText = '';
                let tags = [];
                
                // Check if last line contains tags (starts with # and has #words)
                if (lastLine.startsWith('#') && lastLine.includes('#')) {
                    // Extract tags from last line: #tagg1 #tagg2 #tagg3
                    const tagMatches = lastLine.match(/#\w+/g);
                    if (tagMatches) {
                        tags = tagMatches.map(tag => tag.substring(1)); // Remove # prefix
                        // Card text is everything except the last line
                        cardText = lines.slice(0, -1).join('\n').trim();
                    } else {
                        // Last line starts with # but no valid tags, include it in text
                        cardText = lines.join('\n').trim();
                    }
                } else {
                    // No tags, all lines become card text
                    cardText = lines.join('\n').trim();
                }
                
                // Skip empty cards
                if (!cardText) return;
                
                // Create card
                const cardId = generateCardId();
                const position = {
                    x: startPosition.x + (index * 50), // Offset each card
                    y: startPosition.y + (index * 50)
                };
                
                const nodeData = {
                    id: cardId,
                    text: cardText,
                    isManualCard: true,
                    tags: tags
                };
                
                const newNode = cy.add({
                    group: 'nodes',
                    data: nodeData,
                    position: position
                });
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(newNode);
                
                createdCount++;
                console.log(`Created card ${index + 1}: "${cardText.substring(0, 30)}..." with tags:`, tags);
            });
            
            // Show success message
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `Skapade ${createdCount} kort från texten`;
                statusDiv.classList.add('visible');
                setTimeout(() => {
                    statusDiv.classList.remove('visible');
                }, 3000);
            }
            
            console.log(`Multi-card paste complete: ${createdCount} cards created`);
        }

        // ====================================================================================================
        // 🤖 AI ASSISTANT - Claude Integration with Chat Panel
        // ====================================================================================================

        let aiChatHistory = [];

        // Toggle AI Panel
        function toggleAIPanel() {
            const panel = document.getElementById('aiPanel');
            const apiKey = localStorage.getItem('claudeApiKey');

            if (!apiKey) {
                showClaudeAPIKeyDialog();
                return;
            }

            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
            } else {
                panel.classList.add('visible');
                // Focus input
                setTimeout(() => {
                    document.getElementById('aiPanelInput').focus();
                }, 100);
            }
        }

        // Send AI Message from panel
        async function sendAIMessage() {
            const input = document.getElementById('aiPanelInput');
            const sendBtn = document.getElementById('aiPanelSend');
            const query = input.value.trim();

            if (!query) return;

            const apiKey = localStorage.getItem('claudeApiKey');
            if (!apiKey) {
                addChatMessage('system', 'API-nyckel saknas. Stäng panelen och öppna igen för att ange nyckel.');
                return;
            }

            // Add user message to chat
            addChatMessage('user', query);
            input.value = '';

            // Disable send button
            sendBtn.disabled = true;

            // Show loading
            addChatMessage('system', 'AI tänker...');

            try {
                const response = await askClaudeAboutNotes(query, apiKey);

                // Remove loading message
                removeLastSystemMessage();

                // Add assistant response
                addChatMessage('assistant', response);
            } catch (error) {
                removeLastSystemMessage();
                addChatMessage('system', `Fel: ${error.message}`);
                console.error('AI error:', error);
            } finally {
                sendBtn.disabled = false;
            }
        }

        // Add message to chat
        function addChatMessage(role, text) {
            const messagesContainer = document.getElementById('aiMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${role}`;
            messageDiv.textContent = text;
            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Add to history (except system messages)
            if (role !== 'system') {
                aiChatHistory.push({ role, text });
            }
        }

        // Remove last system message (loading indicator)
        function removeLastSystemMessage() {
            const messagesContainer = document.getElementById('aiMessages');
            const systemMessages = messagesContainer.querySelectorAll('.ai-message.system');
            if (systemMessages.length > 0) {
                systemMessages[systemMessages.length - 1].remove();
            }
        }

        // Handle Enter key in AI input
        document.addEventListener('DOMContentLoaded', function() {
            const aiInput = document.getElementById('aiPanelInput');
            if (aiInput) {
                aiInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendAIMessage();
                    }
                });
            }
        });

        // Dialog to enter Claude API key
        function showClaudeAPIKeyDialog() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 30px;
                width: 90%;
                max-width: 500px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;

            dialog.innerHTML = `
                <h2 style="margin: 0 0 20px 0; color: #333;">🤖 Claude AI-assistent</h2>
                <p style="margin: 0 0 20px 0; color: #666; line-height: 1.6;">
                    För att använda AI-assistenten behöver du en Claude API-nyckel från Anthropic.
                </p>
                <p style="margin: 0 0 15px 0; color: #666; line-height: 1.6;">
                    <strong>Så här skaffar du en nyckel:</strong><br>
                    1. Gå till <a href="https://console.anthropic.com/" target="_blank" style="color: #007bff;">console.anthropic.com</a><br>
                    2. Skapa ett konto eller logga in<br>
                    3. Gå till "API Keys" och skapa en ny nyckel<br>
                    4. Klistra in nyckeln här nedan
                </p>
                <p style="margin: 0 0 15px 0; color: #e67e22; font-size: 13px;">
                    ⚠️ Din API-nyckel sparas endast lokalt i din webbläsare.
                </p>
                <input type="password" id="claudeApiKeyInput" placeholder="sk-ant-api03-..." style="
                    width: 100%;
                    padding: 12px;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                    font-family: monospace;
                    font-size: 14px;
                    box-sizing: border-box;
                    margin-bottom: 20px;
                ">
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelApiKey" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Avbryt</button>
                    <button id="saveApiKey" style="
                        padding: 10px 20px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Spara och fortsätt</button>
                </div>
                <p style="margin: 20px 0 0 0; padding-top: 20px; border-top: 1px solid #eee; color: #999; font-size: 12px;">
                    Du kan senare ta bort din API-nyckel via Inställningar-menyn.
                </p>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            const input = document.getElementById('claudeApiKeyInput');
            input.focus();

            document.getElementById('cancelApiKey').onclick = () => {
                overlay.remove();
            };

            document.getElementById('saveApiKey').onclick = () => {
                const apiKey = input.value.trim();
                if (apiKey && apiKey.startsWith('sk-ant-')) {
                    localStorage.setItem('claudeApiKey', apiKey);
                    overlay.remove();
                    toggleAIPanel();
                } else {
                    alert('Ogiltig API-nyckel. Claude API-nycklar börjar med "sk-ant-"');
                }
            };

            // Save on Enter
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('saveApiKey').click();
                }
            });

            // Close on Escape
            overlay.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                }
            });
        }

        // Dialog to ask AI a question
        function showAIQueryDialog() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 30px;
                width: 90%;
                max-width: 700px;
                max-height: 85vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;

            dialog.innerHTML = `
                <h2 style="margin: 0 0 10px 0; color: #333;">🤖 Fråga AI om dina anteckningar</h2>
                <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">
                    AI:n kan söka, sammanfatta och analysera dina kort.
                </p>
                <textarea id="aiQueryInput" placeholder="Exempel:
- Vilka kort handlar om projektplanering?
- Sammanfatta mina anteckningar om AI
- Hitta alla todo-uppgifter för nästa vecka
- Vad har jag skrivit om design?" style="
                    width: 100%;
                    height: 120px;
                    padding: 12px;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                    font-family: inherit;
                    font-size: 14px;
                    resize: vertical;
                    box-sizing: border-box;
                    margin-bottom: 15px;
                "></textarea>
                <div id="aiResponseArea" style="
                    display: none;
                    background: #f8f9fa;
                    border: 1px solid #dee2e6;
                    border-radius: 6px;
                    padding: 15px;
                    margin-bottom: 15px;
                    max-height: 300px;
                    overflow-y: auto;
                    white-space: pre-wrap;
                    font-size: 14px;
                    line-height: 1.6;
                "></div>
                <div id="aiLoadingArea" style="
                    display: none;
                    text-align: center;
                    padding: 20px;
                    color: #666;
                ">
                    <div style="display: inline-block; animation: spin 1s linear infinite;">⏳</div>
                    <p style="margin: 10px 0 0 0;">AI tänker...</p>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelAIQuery" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Stäng</button>
                    <button id="askAI" style="
                        padding: 10px 20px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Fråga AI</button>
                </div>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // Add spinner animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);

            const input = document.getElementById('aiQueryInput');
            input.focus();

            document.getElementById('cancelAIQuery').onclick = () => {
                overlay.remove();
            };

            document.getElementById('askAI').onclick = async () => {
                const query = input.value.trim();
                if (!query) {
                    alert('Skriv en fråga först!');
                    return;
                }

                // Show loading, hide previous response
                document.getElementById('aiLoadingArea').style.display = 'block';
                document.getElementById('aiResponseArea').style.display = 'none';
                document.getElementById('askAI').disabled = true;

                try {
                    const response = await askClaudeAboutNotes(query);

                    // Show response
                    document.getElementById('aiLoadingArea').style.display = 'none';
                    const responseArea = document.getElementById('aiResponseArea');
                    responseArea.textContent = response;
                    responseArea.style.display = 'block';
                    document.getElementById('askAI').disabled = false;
                } catch (error) {
                    document.getElementById('aiLoadingArea').style.display = 'none';
                    document.getElementById('askAI').disabled = false;
                    alert('Fel vid AI-anrop: ' + error.message);
                }
            };

            // Ask on Ctrl+Enter
            input.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'Enter') {
                    document.getElementById('askAI').click();
                }
            });

            // Close on Escape
            overlay.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                }
            });
        }

        // Extract keywords from query for smart filtering
        function extractKeywords(query) {
            // Remove common Swedish stop words
            const stopWords = ['och', 'eller', 'om', 'för', 'från', 'till', 'med', 'i', 'på', 'att', 'är', 'den', 'det', 'som', 'har', 'kan', 'var', 'ska', 'vad', 'hur', 'när', 'vilka', 'alla', 'mina', 'dina'];

            const words = query.toLowerCase()
                .split(/\s+/)
                .filter(word => word.length > 2 && !stopWords.includes(word));

            return [...new Set(words)]; // Remove duplicates
        }

        // Calculate relevance score for a card based on keywords
        function calculateRelevanceScore(node, keywords) {
            const title = (node.data('title') || '').toLowerCase();
            const text = (node.data('text') || '').toLowerCase();
            const tags = (node.data('tags') || []).join(' ').toLowerCase();
            const fullContent = `${title} ${text} ${tags}`;

            let score = 0;

            keywords.forEach(keyword => {
                // Title match = 3 points
                if (title.includes(keyword)) score += 3;
                // Tag match = 2 points
                if (tags.includes(keyword)) score += 2;
                // Text match = 1 point
                if (text.includes(keyword)) score += 1;
            });

            return score;
        }

        // Call Claude API with smart note filtering
        async function askClaudeAboutNotes(query) {
            const apiKey = localStorage.getItem('claudeApiKey');

            if (!apiKey) {
                throw new Error('Ingen API-nyckel hittades. Klicka på AI-assistenten igen för att lägga till en.');
            }

            const totalCards = cy.nodes().length;
            const MAX_CARDS = 100; // Analyze up to 100 most relevant cards

            // Smart filtering: only send relevant cards if we have many
            let cardsToSend;
            let filterInfo = '';

            if (totalCards <= MAX_CARDS) {
                // Send all cards if we have 50 or fewer
                cardsToSend = cy.nodes().toArray();
                filterInfo = `Analyserar alla ${totalCards} kort.`;
            } else {
                // Extract keywords and rank cards by relevance
                const keywords = extractKeywords(query);
                console.log('📊 Extracted keywords:', keywords);

                // Score all cards
                const scoredCards = cy.nodes().map(node => ({
                    node: node,
                    score: calculateRelevanceScore(node, keywords)
                }));

                // Sort by score (highest first) and take top MAX_CARDS
                scoredCards.sort((a, b) => b.score - a.score);

                // Take cards with score > 0, up to MAX_CARDS
                const relevantCards = scoredCards.filter(item => item.score > 0).slice(0, MAX_CARDS);

                if (relevantCards.length === 0) {
                    // No relevant cards found, take most recent MAX_CARDS
                    cardsToSend = cy.nodes().slice(0, MAX_CARDS).toArray();
                    filterInfo = `Inga specifikt matchande kort hittades. Analyserar de ${cardsToSend.length} senaste korten.`;
                } else {
                    cardsToSend = relevantCards.map(item => item.node);
                    filterInfo = `Filtrerade från ${totalCards} kort till de ${cardsToSend.length} mest relevanta (sparar ~${Math.round((1 - cardsToSend.length / totalCards) * 100)}% tokens).`;
                }

                console.log('📊 Filter info:', filterInfo);
            }

            // Collect notes from selected cards
            const selectedNotes = cardsToSend.map(node => {
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const tags = (node.data('tags') || []).join(', ');
                const hidden_tags = (node.data('hidden_tags') || []).join(', ');
                const cardColor = node.data('cardColor') || '';
                const export_source = node.data('export_source') || '';
                const id = node.id();

                let noteText = '';
                if (title) noteText += `Titel: ${title}\n`;
                if (text) noteText += `Text: ${text}\n`;
                if (tags) noteText += `Taggar: ${tags}\n`;
                if (cardColor) noteText += `Färg: ${cardColor}\n`;
                if (export_source) noteText += `Källa: ${export_source}\n`;
                if (hidden_tags) noteText += `Metadata: ${hidden_tags}\n`;
                noteText += `ID: ${id}`;

                return noteText;
            }).filter(note => note.trim());

            const notesContext = selectedNotes.join('\n\n---\n\n');

            // Create prompt
            let prompt = `Du är en VISUELL organisationsexpert för anteckningar.

VIKTIGT - Anpassa ditt svar efter situationen:

KONKRET UPPDRAG (användaren ber dig göra något specifikt):
- Använd verktyg direkt utan att prata mycket
- Kortfattat svar (max 2 meningar)
- Exempel: "organisera i högar", "skapa mindmap", "visa som flöde"

VAGA FRÅGOR (användaren är osäker eller ber om förslag):
- Ge konkreta förslag på vad du kan göra
- Förklara alternativ (kluster vs mindmap vs flöde)
- Fråga om förtydligande om nödvändigt
- Exempel: "vad kan du göra?", "hjälp mig organisera", "hur ska jag strukturera detta?"

VERKTYG du kan använda:
- arrange_clusters: Dela kort i separata högar/kategorier med färgade etiketter. Systemet beräknar automatiskt positioner så högar INTE överlappar. Du behöver bara ange gruppnamn och vilka kort som hör till varje grupp.
- create_arrows: Rita pilar mellan kort (perfekt för mindmaps och flödesscheman)
- arrange_grid: Arrangera kort i rutnät
- arrange_circle: Arrangera kort i cirkel (bra för att visa relationer)
- create_annotation: Skapa stora textetiketter

EXEMPEL PÅ VAD DU KAN ERBJUDA:
- Dela kort i ämnesområden (använd arrange_clusters - positioner hanteras automatiskt)
- Skapa mindmap med central idé och pilar (använd create_arrows)
- Skapa flödesschema med sekventiella pilar (använd arrange_grid + create_arrows)
- Hitta samband mellan kort och visa med pilar

`;

            if (totalCards > MAX_CARDS) {
                prompt += `OBS: Användaren har totalt ${totalCards} kort, men du får bara se de ${cardsToSend.length} mest relevanta för denna fråga.

`;
            }

            prompt += `Här är ${selectedNotes.length} anteckningar:

${notesContext}

Användarens fråga: ${query}

Svara på svenska. Om uppdraget är tydligt: använd verktyg direkt och var kortfattad. Om uppdraget är vagt: ge förslag och fråga om förtydligande.`;

            // Define tools that AI can use to manipulate cards
            const tools = [
                {
                    name: "filter_and_show",
                    description: "Filter and show only specific cards, hiding all others. Use when user wants to see only certain cards.",
                    input_schema: {
                        type: "object",
                        properties: {
                            card_ids: {
                                type: "array",
                                items: { type: "string" },
                                description: "Array of card IDs to show"
                            },
                            reason: {
                                type: "string",
                                description: "Brief explanation of why these cards were selected"
                            }
                        },
                        required: ["card_ids", "reason"]
                    }
                },
                {
                    name: "create_annotation",
                    description: "Create a large visual label/annotation box with text. Use for creating visual markers or category headers.",
                    input_schema: {
                        type: "object",
                        properties: {
                            text: {
                                type: "string",
                                description: "Text to display in the annotation"
                            },
                            color: {
                                type: "string",
                                enum: ["red", "blue", "green", "yellow", "purple", "orange"],
                                description: "Color of the annotation box"
                            },
                            x: {
                                type: "number",
                                description: "X position (default center if not specified)"
                            },
                            y: {
                                type: "number",
                                description: "Y position (default center if not specified)"
                            }
                        },
                        required: ["text", "color"]
                    }
                },
                {
                    name: "arrange_grid",
                    description: "Arrange cards in a grid layout. Perfect for organizing cards by category.",
                    input_schema: {
                        type: "object",
                        properties: {
                            card_ids: {
                                type: "array",
                                items: { type: "string" },
                                description: "Card IDs to arrange"
                            },
                            columns: {
                                type: "number",
                                description: "Number of columns in grid (default 5)"
                            },
                            start_x: {
                                type: "number",
                                description: "Starting X position (default 100)"
                            },
                            start_y: {
                                type: "number",
                                description: "Starting Y position (default 100)"
                            }
                        },
                        required: ["card_ids"]
                    }
                },
                {
                    name: "arrange_circle",
                    description: "Arrange cards in a circle around a center point. Great for showing relationships.",
                    input_schema: {
                        type: "object",
                        properties: {
                            card_ids: {
                                type: "array",
                                items: { type: "string" },
                                description: "Card IDs to arrange in circle"
                            },
                            center_x: {
                                type: "number",
                                description: "Center X position"
                            },
                            center_y: {
                                type: "number",
                                description: "Center Y position"
                            },
                            radius: {
                                type: "number",
                                description: "Circle radius in pixels (default 400)"
                            }
                        },
                        required: ["card_ids", "center_x", "center_y"]
                    }
                },
                {
                    name: "arrange_timeline",
                    description: "Arrange cards in a week grid (Monday-Sunday columns) based on their dates. Perfect for todos and tasks.",
                    input_schema: {
                        type: "object",
                        properties: {
                            card_ids: {
                                type: "array",
                                items: { type: "string" },
                                description: "Card IDs to arrange in timeline"
                            }
                        },
                        required: ["card_ids"]
                    }
                },
                {
                    name: "arrange_clusters",
                    description: "Organize cards into separate visual clusters/piles with labels. System automatically calculates positions to prevent overlap. Perfect for categorizing cards into distinct groups.",
                    input_schema: {
                        type: "object",
                        properties: {
                            groups: {
                                type: "array",
                                items: {
                                    type: "object",
                                    properties: {
                                        name: {
                                            type: "string",
                                            description: "Name/label for this cluster"
                                        },
                                        card_ids: {
                                            type: "array",
                                            items: { type: "string" },
                                            description: "Card IDs in this cluster"
                                        }
                                    },
                                    required: ["name", "card_ids"]
                                },
                                description: "Array of groups/clusters to create. System will auto-position them with proper spacing."
                            }
                        },
                        required: ["groups"]
                    }
                },
                {
                    name: "create_arrows",
                    description: "Create arrows between cards to show relationships, flow, or hierarchy. Perfect for mindmaps and flowcharts.",
                    input_schema: {
                        type: "object",
                        properties: {
                            connections: {
                                type: "array",
                                items: {
                                    type: "object",
                                    properties: {
                                        from: {
                                            type: "string",
                                            description: "Source card ID"
                                        },
                                        to: {
                                            type: "string",
                                            description: "Target card ID"
                                        },
                                        color: {
                                            type: "string",
                                            enum: ["red", "blue", "green", "yellow", "purple", "orange", "black"],
                                            description: "Arrow color (default red)"
                                        }
                                    },
                                    required: ["from", "to"]
                                },
                                description: "Array of arrow connections to create"
                            }
                        },
                        required: ["connections"]
                    }
                }
            ];

            // Build messages array with conversation history
            // Include last 10 messages (5 exchanges) for better context
            const messages = [];
            const recentHistory = aiChatHistory.slice(-10); // Last 10 messages max

            // Add history messages
            recentHistory.forEach(msg => {
                messages.push({
                    role: msg.role,
                    content: msg.text
                });
            });

            // Add current user message
            messages.push({
                role: 'user',
                content: prompt
            });

            console.log(`📝 Sending ${messages.length} messages to API (${recentHistory.length} from history + 1 new)`);

            // Call Claude API with tools
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'content-type': 'application/json',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-sonnet-20241022',
                    max_tokens: 8192,
                    system: "Du är en intelligent och hjälpsam visuell organisationsassistent. Analysera användarens behov innan du agerar. Var vänlig, professionell och förklara ditt resonemang när det är användbart. Om något är oklart, fråga istället för att gissa.",
                    tools: tools,
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.text();
                console.error('Claude API error:', error);
                throw new Error(`API-fel (${response.status}): ${error}`);
            }

            const data = await response.json();

            // Handle tool use
            let textResponse = '';
            const toolCalls = [];

            for (const content of data.content) {
                if (content.type === 'text') {
                    textResponse += content.text;
                } else if (content.type === 'tool_use') {
                    toolCalls.push(content);
                }
            }

            // Execute tool calls
            if (toolCalls.length > 0) {
                console.log('🤖 AI wants to execute tools:', toolCalls);
                for (const toolCall of toolCalls) {
                    await executeAITool(toolCall.name, toolCall.input);
                }
            }

            // Return text response with filter info
            return `💡 ${filterInfo}\n\n${textResponse || 'AI utförde visuella åtgärder.'}`;
        }

        // Execute AI tool based on name
        async function executeAITool(toolName, input) {
            console.log(`🔧 Executing tool: ${toolName}`, input);

            switch (toolName) {
                case 'filter_and_show':
                    await aiFilterAndShow(input);
                    break;
                case 'create_annotation':
                    await aiCreateAnnotation(input);
                    break;
                case 'arrange_grid':
                    await aiArrangeGrid(input);
                    break;
                case 'arrange_circle':
                    await aiArrangeCircle(input);
                    break;
                case 'arrange_timeline':
                    await aiArrangeTimeline(input);
                    break;
                case 'arrange_clusters':
                    await aiArrangeClusters(input);
                    break;
                case 'create_arrows':
                    await aiCreateArrows(input);
                    break;
                default:
                    console.warn(`Unknown tool: ${toolName}`);
            }
        }

        // AI Tool: Filter and show specific cards
        async function aiFilterAndShow(input) {
            const { card_ids, reason } = input;

            console.log(`🔍 Filtering to show ${card_ids.length} cards: ${reason}`);

            // Hide all cards first
            cy.nodes().style('display', 'none');

            // Show only specified cards
            card_ids.forEach(cardId => {
                const node = cy.getElementById(cardId);
                if (node.length > 0) {
                    node.style('display', 'element');
                }
            });

            // Zoom to fit visible cards
            const visibleNodes = cy.nodes().filter(node => node.style('display') === 'element');
            if (visibleNodes.length > 0) {
                cy.fit(visibleNodes, 50);
            }

            // Show status message
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI visar ${card_ids.length} kort: ${reason}. (Rensa sökfältet för att visa alla kort igen)`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 8000);
            }
        }

        // AI Tool: Create annotation/label
        async function aiCreateAnnotation(input) {
            const { text, color, x, y } = input;

            console.log(`📝 Creating annotation: "${text}" in ${color}`);

            // Color mapping
            const colorMap = {
                'red': '#ff4444',
                'blue': '#4444ff',
                'green': '#44ff44',
                'yellow': '#ffff44',
                'purple': '#ff44ff',
                'orange': '#ffaa44'
            };

            // Position: use provided or default to center
            const position = {
                x: x || 500,
                y: y || 300
            };

            // Create annotation node
            const annotationId = 'annotation-' + Date.now();
            const newNode = cy.add({
                group: 'nodes',
                data: {
                    id: annotationId,
                    label: text,
                    isAnnotation: true,
                    annotationType: 'shape',
                    backgroundColor: colorMap[color] || '#ff4444'
                },
                position: position
            });

            // Style the annotation
            newNode.addClass('annotation-shape');
            newNode.style({
                'width': Math.max(text.length * 45, 600),
                'height': 300,
                'background-color': colorMap[color] || '#ff4444',
                'label': text,
                'text-valign': 'center',
                'text-halign': 'center',
                'font-size': '50px',
                'font-weight': 'bold',
                'color': '#ffffff',
                'text-outline-width': 2,
                'text-outline-color': '#000000',
                'shape': 'rectangle',
                'border-width': 4,
                'border-color': '#000000'
            });

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI skapade etikett: "${text}"`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 3000);
            }

            saveBoard();
        }

        // AI Tool: Arrange cards in grid
        async function aiArrangeGrid(input) {
            const { card_ids, columns = 5, start_x = 100, start_y = 100 } = input;

            console.log(`📐 Arranging ${card_ids.length} cards in ${columns}-column grid`);

            const spacing_x = 180;
            const spacing_y = 150;

            card_ids.forEach((cardId, index) => {
                const node = cy.getElementById(cardId);
                if (node.length > 0) {
                    const col = index % columns;
                    const row = Math.floor(index / columns);

                    node.position({
                        x: start_x + (col * spacing_x),
                        y: start_y + (row * spacing_y)
                    });
                }
            });

            // Fit view to arranged cards
            const arrangedNodes = card_ids.map(id => cy.getElementById(id)).filter(n => n.length > 0);
            if (arrangedNodes.length > 0) {
                cy.fit(cy.collection(arrangedNodes), 50);
            }

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI arrangerade ${card_ids.length} kort i grid (${columns} kolumner)`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 3000);
            }

            saveBoard();
        }

        // AI Tool: Arrange cards in circle
        async function aiArrangeCircle(input) {
            const { card_ids, center_x, center_y, radius = 400 } = input;

            console.log(`⭕ Arranging ${card_ids.length} cards in circle around (${center_x}, ${center_y})`);

            const angleStep = (2 * Math.PI) / card_ids.length;

            card_ids.forEach((cardId, index) => {
                const node = cy.getElementById(cardId);
                if (node.length > 0) {
                    const angle = index * angleStep - (Math.PI / 2); // Start from top
                    const x = center_x + (radius * Math.cos(angle));
                    const y = center_y + (radius * Math.sin(angle));

                    node.position({ x, y });
                }
            });

            // Fit view
            const arrangedNodes = card_ids.map(id => cy.getElementById(id)).filter(n => n.length > 0);
            if (arrangedNodes.length > 0) {
                cy.fit(cy.collection(arrangedNodes), 100);
            }

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI arrangerade ${card_ids.length} kort i cirkel`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 3000);
            }

            saveBoard();
        }

        // AI Tool: Arrange cards in timeline (week grid)
        async function aiArrangeTimeline(input) {
            const { card_ids } = input;

            console.log(`📅 Arranging ${card_ids.length} cards in week timeline`);

            // Create week day columns
            const weekDays = ['Måndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lördag', 'Söndag'];
            const columnWidth = 200;
            const rowHeight = 150;
            const startX = 100;
            const startY = 150;

            // Create column headers (annotations)
            weekDays.forEach((day, index) => {
                const headerId = `week-header-${index}`;
                // Remove existing header if present
                cy.getElementById(headerId).remove();

                const headerNode = cy.add({
                    group: 'nodes',
                    data: {
                        id: headerId,
                        label: day,
                        isAnnotation: true,
                        annotationType: 'shape'
                    },
                    position: {
                        x: startX + (index * columnWidth),
                        y: startY - 80
                    }
                });

                headerNode.addClass('annotation-shape');
                headerNode.style({
                    'width': 150,
                    'height': 50,
                    'background-color': '#4444ff',
                    'label': day,
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '16px',
                    'font-weight': 'bold',
                    'color': '#ffffff',
                    'shape': 'rectangle',
                    'border-width': 2,
                    'border-color': '#000000'
                });
            });

            // Sort cards by date and place in columns
            const cardsByDay = [[], [], [], [], [], [], []]; // Mon-Sun

            card_ids.forEach(cardId => {
                const node = cy.getElementById(cardId);
                if (node.length > 0) {
                    // Try to extract date from card
                    const text = (node.data('text') || '') + ' ' + (node.data('tags') || []).join(' ');
                    const datePatterns = parseDateFromContent(text);

                    if (datePatterns.length > 0) {
                        const date = datePatterns[0].date;
                        const dayOfWeek = (date.getDay() + 6) % 7; // Mon=0, Sun=6
                        cardsByDay[dayOfWeek].push(node);
                    } else {
                        // No date found, put in first column
                        cardsByDay[0].push(node);
                    }
                }
            });

            // Position cards in their columns
            cardsByDay.forEach((cards, dayIndex) => {
                cards.forEach((node, cardIndex) => {
                    node.position({
                        x: startX + (dayIndex * columnWidth),
                        y: startY + (cardIndex * rowHeight)
                    });
                });
            });

            // Fit view
            cy.fit(null, 50);

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI skapade vecko-timeline med ${card_ids.length} kort`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 3000);
            }

            saveBoard();
        }

        // AI Tool: Arrange cards in clusters with labels (auto-calculated positions)
        async function aiArrangeClusters(input) {
            const { groups } = input;

            console.log(`📦 Creating ${groups.length} clusters with auto-spacing`);

            // Rotate through colors automatically
            const colors = ['#ff4444', '#4444ff', '#44ff44', '#ffff44', '#ff44ff', '#ffaa44'];

            // Card and spacing constants
            const CARD_SPACING_X = 220;  // Horizontal space between cards (increased from 180)
            const CARD_SPACING_Y = 180;  // Vertical space between cards (increased from 150)
            const CLUSTER_MARGIN = 600;  // Space between clusters (increased from 400)
            const START_Y = 200;         // Starting Y position

            let currentX = 200;  // Starting X position for first cluster

            groups.forEach((group, groupIndex) => {
                const { name, card_ids } = group;
                const color = colors[groupIndex % colors.length];

                // Calculate cluster grid dimensions
                const cols = Math.ceil(Math.sqrt(card_ids.length));
                const rows = Math.ceil(card_ids.length / cols);

                // Calculate cluster dimensions (total width/height needed)
                const clusterWidth = cols * CARD_SPACING_X;
                const clusterHeight = rows * CARD_SPACING_Y;

                // Cluster center for label placement
                const clusterCenterX = currentX + (clusterWidth / 2);

                // Create cluster label above cluster
                const labelId = 'cluster-label-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
                const labelNode = cy.add({
                    group: 'nodes',
                    data: {
                        id: labelId,
                        label: name,
                        isAnnotation: true,
                        annotationType: 'shape'
                    },
                    position: {
                        x: clusterCenterX,
                        y: START_Y - 100
                    }
                });

                // Style label
                labelNode.addClass('annotation-shape');
                labelNode.style({
                    'width': Math.max(name.length * 30, 400),
                    'height': 80,
                    'background-color': color,
                    'label': name,
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '32px',
                    'font-weight': 'bold',
                    'color': '#ffffff',
                    'text-outline-width': 2,
                    'text-outline-color': '#000000',
                    'shape': 'rectangle',
                    'border-width': 3,
                    'border-color': '#000000'
                });

                // Arrange cards in grid starting from currentX (left edge, not center)
                card_ids.forEach((cardId, index) => {
                    const node = cy.getElementById(cardId);
                    if (node.length > 0) {
                        const col = index % cols;
                        const row = Math.floor(index / cols);

                        node.position({
                            x: currentX + (col * CARD_SPACING_X),
                            y: START_Y + (row * CARD_SPACING_Y)
                        });
                    }
                });

                // Move currentX for next cluster (current cluster width + margin)
                currentX += clusterWidth + CLUSTER_MARGIN;
            });

            // Fit view to all clusters
            cy.fit(null, 100);

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                const totalCards = groups.reduce((sum, g) => sum + g.card_ids.length, 0);
                statusDiv.textContent = `AI skapade ${groups.length} kluster med ${totalCards} kort`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 4000);
            }

            saveBoard();
        }

        // AI Tool: Create arrows between cards
        async function aiCreateArrows(input) {
            const { connections } = input;

            console.log(`🔗 Creating ${connections.length} arrows`);

            const colorMap = {
                'red': '#ff4444',
                'blue': '#4444ff',
                'green': '#44ff44',
                'yellow': '#ffff44',
                'purple': '#ff44ff',
                'orange': '#ffaa44',
                'black': '#000000'
            };

            connections.forEach(conn => {
                const { from, to, color = 'red' } = conn;

                const sourceNode = cy.getElementById(from);
                const targetNode = cy.getElementById(to);

                if (sourceNode.length > 0 && targetNode.length > 0) {
                    const edgeId = generateCardId();
                    const arrowColor = colorMap[color] || colorMap['red'];

                    cy.add({
                        data: {
                            id: edgeId,
                            source: from,
                            target: to,
                            isAnnotation: true,
                            annotationType: 'connection',
                            connectionType: 'arrow'
                        },
                        classes: 'annotation-connection'
                    });

                    const edge = cy.getElementById(edgeId);
                    edge.style({
                        'line-color': arrowColor,
                        'target-arrow-color': arrowColor,
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'width': 5,
                        'arrow-scale': 1.8
                    });

                    console.log(`🔗 Created arrow: ${from} → ${to} (${color})`);
                }
            });

            // Show status
            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = `AI skapade ${connections.length} pilar`;
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 3000);
            }

            saveBoard();
        }


        // Show all cards (reset AI filter and zoom)
        function showAllCards() {
            cy.nodes().style('display', 'element');
            cy.fit(null, 50);

            const statusDiv = document.getElementById('selectionInfo');
            if (statusDiv) {
                statusDiv.textContent = 'Alla kort visas nu';
                statusDiv.classList.add('visible');
                setTimeout(() => statusDiv.classList.remove('visible'), 2000);
            }
        }

        // Clear search
        function clearSearch() {
            searchActive = false;

            cy.nodes().removeClass('search-match');
            cy.nodes().removeClass('search-non-match'); // Remove blur from non-matches
            cy.nodes().data('searchMatch', false);
            cy.nodes().unselect(); // Avmarkera alla kort när sökning rensas

            // Show all cards (reset display from AI filter)
            cy.nodes().style('display', 'element');

            const searchInfo = document.getElementById('searchInfo');
            searchInfo.classList.remove('visible');

            // Hide mobile select button
            const selectBtn = document.getElementById('searchSelectBtn');
            selectBtn.style.display = 'none';
        }
        
        // Tag filtering functions with Boolean logic
        function performTagFilter(filterText) {
            if (!filterText.trim()) {
                clearTagFilter();
                return;
            }
            
            const query = filterText.toLowerCase().trim();
            let matchCount = 0;
            
            cy.nodes().forEach(node => {
                const nodeTags = node.data('tags') || [];
                const nodeTagsLower = nodeTags.map(tag => tag.toLowerCase());
                
                // Create searchable tag string (space-separated for boolean evaluation)
                const searchableTagText = nodeTagsLower.join(' ');
                
                // Use boolean evaluation on tags
                const matches = evaluateBooleanTagQuery(query, searchableTagText, nodeTagsLower);
                
                if (matches) {
                    node.removeClass('tag-filtered');
                    matchCount++;
                } else {
                    node.addClass('tag-filtered');
                }
            });
            
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `${matchCount} kort matchade tag-filter: "${filterText}"`;
            searchInfo.classList.add('visible');
        }
        
        // Boolean query evaluation specifically for tags
        function evaluateBooleanTagQuery(query, searchableTagText, nodeTagsArray) {
            // Handle different boolean operators for tags
            
            // Split by OR first (lowest precedence)
            if (query.includes(' or ')) {
                const orParts = query.split(' or ');
                return orParts.some(part => evaluateBooleanTagQuery(part.trim(), searchableTagText, nodeTagsArray));
            }
            
            // Handle NOT operations
            if (query.includes(' not ')) {
                const notIndex = query.indexOf(' not ');
                const beforeNot = query.substring(0, notIndex).trim();
                const afterNot = query.substring(notIndex + 5).trim(); // ' not '.length = 5
                
                // If there's something before NOT, it must match
                let beforeMatches = true;
                if (beforeNot) {
                    beforeMatches = evaluateBooleanTagQuery(beforeNot, searchableTagText, nodeTagsArray);
                }
                
                // The part after NOT must NOT match
                const afterMatches = evaluateBooleanTagQuery(afterNot, searchableTagText, nodeTagsArray);
                
                return beforeMatches && !afterMatches;
            }
            
            // Handle AND operations (default behavior and explicit)
            const andParts = query.includes(' and ') ? 
                query.split(' and ') : 
                query.split(' ').filter(term => term.length > 0);
                
            return andParts.every(term => {
                term = term.trim();
                
                if (term.startsWith('"') && term.endsWith('"')) {
                    // Exact tag search - must match complete tag
                    const exactTag = term.slice(1, -1);
                    return nodeTagsArray.some(tag => tag === exactTag);
                } else {
                    // Partial tag search - can be part of any tag
                    return nodeTagsArray.some(tag => tag.includes(term));
                }
            });
        }
        
        function clearTagFilter() {
            cy.nodes().removeClass('tag-filtered');
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.classList.remove('visible');
        }
        
        // Multi-selection functions
        function pinSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            selectedNodes.forEach(node => {
                if (!node.hasClass('pinned')) {
                    pinCard(node);
                }
            });
            if (selectedNodes.length > 0) {
                console.log(`Pinned ${selectedNodes.length} cards`);
                updateSelectionInfo(); // Update after pinning
            }
        }
        
        function unpinSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            selectedNodes.forEach(node => {
                if (node.hasClass('pinned')) {
                    unpinCard(node);
                }
            });
            if (selectedNodes.length > 0) {
                console.log(`Unpinned ${selectedNodes.length} cards`);
                updateSelectionInfo(); // Update after unpinning
            }
        }
        
        function deleteSelectedCards() {
            // Get all selected nodes and edges
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            const selectedEdges = cy.$('edge:selected');
            console.log(`Delete attempt on ${selectedNodes.length} selected nodes and ${selectedEdges.length} selected edges`);
            
            if (selectedNodes.length === 0 && selectedEdges.length === 0) return;
            
            // Save state for undo before deleting
            saveState();
            
            // Delete selected edges (arrows) first - they have no protection
            if (selectedEdges.length > 0) {
                const edgeCount = selectedEdges.length;
                cy.batch(() => {
                    selectedEdges.remove();
                });
                console.log(`✅ Deleted ${edgeCount} selected arrows`);
                
                // Save the board to persist changes
                saveBoard();
            }
            
            // Filter out ALL pinned cards using proper filtering
            const unpinnedNodes = selectedNodes.filter(function(node) {
                const hasClass = node.hasClass('pinned');
                const hasData = node.data('pinned');
                const isPinned = hasClass || hasData;
                
                console.log(`Node ${node.id()}: hasClass=${hasClass}, hasData=${hasData}, isPinned=${isPinned}`);
                return !isPinned;
            });
            
            const pinnedNodes = selectedNodes.filter(function(node) {
                const hasClass = node.hasClass('pinned');
                const hasData = node.data('pinned');
                return hasClass || hasData;
            });
            
            console.log(`Unpinned to delete: ${unpinnedNodes.length}, Pinned to skip: ${pinnedNodes.length}`);
            
            // Only delete unpinned nodes
            if (unpinnedNodes.length > 0) {
                const count = unpinnedNodes.length;
                unpinnedNodes.remove();
                console.log(`Successfully deleted ${count} unpinned cards`);
                updateSelectionInfo(); // Update after deletion
            }
            
            // Show message if user tried to delete pinned cards
            if (pinnedNodes.length > 0) {
                const pinnedCount = pinnedNodes.length;
                console.log(`PROTECTED: Skipped ${pinnedCount} pinned cards - unpin them first to delete`);
                
                // Show a brief visual feedback
                const searchInfo = document.getElementById('searchInfo');
                if (searchInfo) {
                    searchInfo.textContent = `🔒 ${pinnedCount} pinnade kort skyddade - ta bort pinning först`;
                    searchInfo.classList.add('visible');
                    setTimeout(() => {
                        searchInfo.classList.remove('visible');
                    }, 4000);
                }
            }
        }
        
        // ========================================
        // SORTING SYSTEM - EASY TO FIND
        // ========================================
        // Global sorting state
        let sortMode = null; // null, 'textLength-asc', 'textLength-desc', 'alphabetic-asc', 'alphabetic-desc', 'color', 'date-asc', 'date-desc', 'temporal-asc', 'temporal-desc', 'tagCount'
        
        function showSortMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Column view: no selection required, automatic sorting
            if (isColumnView) {
                // Show column view specific sort menu
                showColumnViewSortMenu(event);
                return;
            }
            
            // Board view: Check if we have selected nodes
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) {
                alert('Markera minst 2 kort för att sortera');
                return;
            }
            
            // Create sort menu
            const sortMenu = document.createElement('div');
            sortMenu.id = 'sortMenu';
            sortMenu.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: white; border: 2px solid #007acc; border-radius: 8px;
                padding: 15px; z-index: 10001; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            sortMenu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; text-align: center; color: #007acc;">📊 Sortera ${selectedNodes.length} kort</h3>
                <p style="margin: 0 0 15px 0; text-align: center; font-size: 14px; color: #666;">
                    Välj sortering, tryck sedan H/V/G+V/G+H/G+T för layout
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="setSortMode('textLength-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📝 Text: Kort → Lång</button>
                    <button onclick="setSortMode('textLength-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📝 Text: Lång → Kort</button>
                    <button onclick="setSortMode('alphabetic-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🔤 A → Z</button>
                    <button onclick="setSortMode('alphabetic-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🔤 Z → A</button>
                    <button onclick="setSortMode('color')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🎨 Färg 1→6</button>
                    <button onclick="setSortMode('date-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📅 Skapande: Äldst → Nyast</button>
                    <button onclick="setSortMode('date-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📅 Skapande: Nyast → Äldst</button>
                    <button onclick="setSortMode('temporal-asc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🕒 Datum: Tidigare → Senare</button>
                    <button onclick="setSortMode('temporal-desc')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🕒 Datum: Senare → Tidigare</button>
                    <button onclick="setSortMode('today-first')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🌅 Idag först</button>
                    <button onclick="setSortMode('tagCount')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🏷️ Färre → Fler taggar</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="closeSortMenu()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                </div>
            `;
            
            document.body.appendChild(sortMenu);
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeSortOnClick(e) {
                    if (!sortMenu.contains(e.target)) {
                        closeSortMenu();
                        document.removeEventListener('click', closeSortOnClick);
                    }
                });
            }, 100);
        }
        
        function setSortMode(mode) {
            sortMode = mode;
            console.log('Sort mode set to:', mode);
            closeSortMenu();
            
            if (isColumnView) {
                // Column view: apply sorting immediately
                setColumnViewSortFromBoardMode(mode);
            } else {
                // Board view: show instruction
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Sorteringsläge: ${getSortModeDescription(mode)}. Tryck H/V/G+V/G+H/G+T för layout.`;
                    statusDiv.classList.add('visible');
                    
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        if (sortMode === mode) { // Only hide if we're still in same sort mode
                            statusDiv.classList.remove('visible');
                        }
                    }, 5000);
                }
            }
        }

        // Column view specific sort menu
        function showColumnViewSortMenu(event) {
            // Create sort menu
            const sortMenu = document.createElement('div');
            sortMenu.id = 'sortMenu';
            sortMenu.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: white; border: 2px solid #007acc; border-radius: 8px;
                padding: 15px; z-index: 10001; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            sortMenu.innerHTML = `
                <h3 style="margin: 0 0 15px 0; text-align: center; color: #007acc;">📊 Kolumnvy Sortering</h3>
                <p style="margin: 0 0 15px 0; text-align: center; font-size: 14px; color: #666;">
                    Välj sortering - appliceras automatiskt på alla kort
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button onclick="setColumnViewSort('alphabetical')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🔤 A → Z</button>
                    <button onclick="setColumnViewSort('reverse-alphabetical')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🔤 Z → A</button>
                    <button onclick="setColumnViewSort('creation')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📅 Skapande: Äldst → Nyast</button>
                    <button onclick="setColumnViewSort('reverse-creation')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📅 Skapande: Nyast → Äldst</button>
                    <button onclick="setColumnViewSort('tags')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🏷️ Tags</button>
                    <button onclick="setColumnViewSort('color')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🎨 Färg 1→6</button>
                    <button onclick="setColumnViewSort('tagged-date')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📆 @datum Äldst → Nyast</button>
                    <button onclick="setColumnViewSort('reverse-tagged-date')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">📆 @datum Nyast → Äldst</button>
                    <button onclick="setColumnViewSort('today-first')" style="padding: 8px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">🌅 Idag först</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="closeSortMenu()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Avbryt</button>
                </div>
            `;
            
            document.body.appendChild(sortMenu);
        }

        // Convert board sort mode to column sort mode
        function setColumnViewSortFromBoardMode(boardMode) {
            let columnMode = 'creation'; // default
            
            switch(boardMode) {
                case 'alphabetic-asc':
                    columnMode = 'alphabetical';
                    break;
                case 'alphabetic-desc':
                    columnMode = 'reverse-alphabetical';
                    break;
                case 'date-asc':
                    columnMode = 'creation';
                    break;
                case 'date-desc':
                    columnMode = 'reverse-creation';
                    break;
                case 'tagCount':
                    columnMode = 'tags';
                    break;
                default:
                    columnMode = 'creation';
            }
            
            setColumnViewSort(columnMode);
        }
        
        function closeSortMenu() {
            const sortMenu = document.getElementById('sortMenu');
            if (sortMenu) {
                document.body.removeChild(sortMenu);
            }
        }
        
        function getSortModeDescription(mode) {
            switch(mode) {
                case 'textLength-asc': return 'Text kort → lång';
                case 'textLength-desc': return 'Text lång → kort';
                case 'alphabetic-asc': return 'Alfabetisk A → Z';
                case 'alphabetic-desc': return 'Alfabetisk Z → A';
                case 'color': return 'Färg 1 → 6';
                case 'date-asc': return 'Skapande: Äldst → nyast';
                case 'date-desc': return 'Skapande: Nyast → äldst';
                case 'temporal-asc': return 'Datum: Tidigare → senare';
                case 'temporal-desc': return 'Datum: Senare → tidigare';
                case 'today-first': return 'Idag först';
                case 'tagCount': return 'Färre → fler taggar';
                default: return 'Okänt';
            }
        }
        
        function sortNodes(nodes) {
            if (!sortMode) return nodes;
            
            return nodes.sort((a, b) => {
                switch(sortMode) {
                    case 'textLength-asc':
                        const aTextLength = (a.data('text') || '').length;
                        const bTextLength = (b.data('text') || '').length;
                        return aTextLength - bTextLength;
                        
                    case 'textLength-desc':
                        const aTextLengthDesc = (a.data('text') || '').length;
                        const bTextLengthDesc = (b.data('text') || '').length;
                        return bTextLengthDesc - aTextLengthDesc;
                        
                    case 'alphabetic-asc':
                        const aText = (a.data('text') || '').toLowerCase();
                        const bText = (b.data('text') || '').toLowerCase();
                        return aText.localeCompare(bText, 'sv');
                        
                    case 'alphabetic-desc':
                        const aTextDesc = (a.data('text') || '').toLowerCase();
                        const bTextDesc = (b.data('text') || '').toLowerCase();
                        return bTextDesc.localeCompare(aTextDesc, 'sv');
                        
                    case 'color':
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Same color order as background-color: röd, orange, gul, lila, blå, vit, grön, grå
                        const colorOrder = {
                            'card-color-3': 1, // röd
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // blå
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // grön
                            'card-color-7': 8, // grå
                            '': 9              // ofärgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        return aPriority - bPriority;
                        
                    case 'date-asc':
                        const aDate = extractDateFromId(a.id());
                        const bDate = extractDateFromId(b.id());
                        return aDate - bDate;
                        
                    case 'date-desc':
                        const aDateDesc = extractDateFromId(a.id());
                        const bDateDesc = extractDateFromId(b.id());
                        return bDateDesc - aDateDesc;
                        
                    case 'temporal-asc':
                        const aTemporalDate = getEarliestDateFromContent(a);
                        const bTemporalDate = getEarliestDateFromContent(b);
                        return aTemporalDate - bTemporalDate;
                        
                    case 'temporal-desc':
                        const aTemporalDateDesc = getEarliestDateFromContent(a);
                        const bTemporalDateDesc = getEarliestDateFromContent(b);
                        return bTemporalDateDesc - aTemporalDateDesc;
                        
                    case 'tagCount':
                        const aTagCount = (a.data('tags') || []).length;
                        const bTagCount = (b.data('tags') || []).length;
                        return aTagCount - bTagCount;
                        
                    case 'today-first':
                        const aTodayScore = getTodayScore(a);
                        const bTodayScore = getTodayScore(b);
                        return bTodayScore - aTodayScore; // Higher score = today content = first
                        
                    default:
                        return 0;
                }
            });
        }
        
        // Get nodes sorted by arrow connections (topological sort)
        function getArrowBasedOrder(selectedNodes) {
            console.log('🔍 getArrowBasedOrder called with:', selectedNodes.length, 'nodes');
            
            // Get all edges connecting the selected nodes
            const nodeIds = new Set(selectedNodes.map(node => node.id()));
            console.log('📝 Selected node IDs:', Array.from(nodeIds));
            
            const allEdges = cy.edges();
            console.log('📊 Total edges in graph:', allEdges.length);
            
            const relevantEdges = allEdges.filter(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                const isRelevant = nodeIds.has(sourceId) && nodeIds.has(targetId);
                if (isRelevant) {
                    console.log('✅ Found relevant edge:', sourceId, '→', targetId);
                }
                return isRelevant;
            });
            
            console.log('🔗 Relevant edges found:', relevantEdges.length);
            
            if (relevantEdges.length === 0) {
                console.log('❌ No arrows between selected nodes, returning original order');
                return selectedNodes; // No arrows, return original order
            }
            
            // Build adjacency list for topological sort
            const adjList = new Map();
            const inDegree = new Map();
            
            // Initialize all selected nodes
            selectedNodes.forEach(node => {
                const id = node.id();
                adjList.set(id, []);
                inDegree.set(id, 0);
            });
            
            // Build graph from edges
            relevantEdges.forEach(edge => {
                const sourceId = edge.source().id();
                const targetId = edge.target().id();
                
                console.log('🔧 Building edge:', sourceId, '→', targetId);
                adjList.get(sourceId).push(targetId);
                inDegree.set(targetId, inDegree.get(targetId) + 1);
            });
            
            console.log('📈 In-degrees:', Object.fromEntries(inDegree));
            
            // Kahn's algorithm for topological sorting
            const queue = [];
            const sortedOrder = [];
            
            // Find nodes with no incoming edges
            for (const [nodeId, degree] of inDegree) {
                if (degree === 0) {
                    console.log('🚀 Starting node (no incoming edges):', nodeId);
                    queue.push(nodeId);
                }
            }
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                sortedOrder.push(currentId);
                console.log('✔️ Processing node:', currentId);
                
                // Process neighbors
                const neighbors = adjList.get(currentId) || [];
                neighbors.forEach(neighborId => {
                    inDegree.set(neighborId, inDegree.get(neighborId) - 1);
                    console.log('📉 Reduced in-degree for', neighborId, 'to', inDegree.get(neighborId));
                    if (inDegree.get(neighborId) === 0) {
                        console.log('🚀 Adding to queue:', neighborId);
                        queue.push(neighborId);
                    }
                });
            }
            
            // Handle cycles - add remaining nodes
            selectedNodes.forEach(node => {
                if (!sortedOrder.includes(node.id())) {
                    console.log('⚠️ Adding remaining node (possible cycle):', node.id());
                    sortedOrder.push(node.id());
                }
            });
            
            // Convert back to node objects in sorted order
            const nodeMap = new Map(selectedNodes.map(node => [node.id(), node]));
            const sortedNodes = sortedOrder.map(id => nodeMap.get(id)).filter(Boolean);
            
            console.log('🎯 Final sorted order:', sortedOrder);
            console.log('✅ Arrow-based sorting complete:', relevantEdges.length, 'edges found, sorted', sortedNodes.length, 'nodes');
            return sortedNodes;
        }

        function extractDateFromId(nodeId) {
            // Try to extract timestamp from ID like "20250810-143052"
            const match = nodeId.match(/(\d{8}-\d{6})/);
            if (match) {
                const dateStr = match[1];
                const year = parseInt(dateStr.substr(0, 4));
                const month = parseInt(dateStr.substr(4, 2)) - 1; // Month is 0-indexed
                const day = parseInt(dateStr.substr(6, 2));
                const hour = parseInt(dateStr.substr(9, 2));
                const minute = parseInt(dateStr.substr(11, 2));
                const second = parseInt(dateStr.substr(13, 2));
                return new Date(year, month, day, hour, minute, second).getTime();
            }
            
            // Fallback for older IDs - return very old date
            return new Date(2020, 0, 1).getTime();
        }

        // ========================================
        // DATE-BASED AUTO-MARKING SYSTEM
        // ========================================
        
        // Parse date from @YYMMDD format (e.g., @250816)
        function parseDateFromContent(content) {
            const datePatterns = [];
            
            // Pattern 1: @YYMMDD (e.g., @250816)
            const yymmddPattern = /@(\d{6})/g;
            let match;
            while ((match = yymmddPattern.exec(content)) !== null) {
                const dateStr = match[1];
                const year = 2000 + parseInt(dateStr.substr(0, 2));
                const month = parseInt(dateStr.substr(2, 2)) - 1; // Month is 0-indexed
                const day = parseInt(dateStr.substr(4, 2));
                
                // Validate date
                if (month >= 0 && month <= 11 && day >= 1 && day <= 31) {
                    datePatterns.push({
                        type: 'date',
                        date: new Date(year, month, day),
                        match: match[0]
                    });
                }
            }
            
            // Pattern 2: @YYwWW (e.g., @25w33)
            const weekPattern = /@(\d{2})w(\d{1,2})/g;
            while ((match = weekPattern.exec(content)) !== null) {
                const year = 2000 + parseInt(match[1]);
                const week = parseInt(match[2]);
                
                // Calculate date from week number
                if (week >= 1 && week <= 53) {
                    const weekDate = getDateFromWeek(year, week);
                    datePatterns.push({
                        type: 'week',
                        date: weekDate,
                        week: week,
                        year: year,
                        match: match[0]
                    });
                }
            }
            
            return datePatterns;
        }
        
        // Get date from ISO week number
        function getDateFromWeek(year, week) {
            const januaryFirst = new Date(year, 0, 1);
            const daysToFirstMonday = (8 - januaryFirst.getDay()) % 7;
            const firstMonday = new Date(year, 0, 1 + daysToFirstMonday);
            const targetDate = new Date(firstMonday.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);
            return targetDate;
        }
        
        // Get ISO week number from date
        function getWeekNumber(date) {
            const target = new Date(date.valueOf());
            const dayNr = (date.getDay() + 6) % 7;
            target.setDate(target.getDate() - dayNr + 3);
            const firstThursday = target.valueOf();
            target.setMonth(0, 1);
            if (target.getDay() !== 4) {
                target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
            }
            return 1 + Math.ceil((firstThursday - target) / 604800000);
        }
        
        // Check if node has todo tag in tags array
        function hasTodoTag(node) {
            const tags = node.data('tags') || [];
            return tags.some(tag => tag.toLowerCase() === 'todo');
        }

        function hasDoneTag(node) {
            const tags = node.data('tags') || [];
            return tags.some(tag => tag.toLowerCase() === 'done');
        }

        // Automatically assign gray color to cards with #done tags
        function applyAutoDoneColoring(node) {
            if (hasDoneTag(node)) {
                // Set gray color (card-color-7) for done tasks
                node.data('cardColor', 'card-color-7');
                
                // Update cytoscape styling immediately
                const colorValue = getCardColorValue('card-color-7', getCurrentTheme());
                node.style('background-color', colorValue);
                
                console.log(`Auto-colored card ${node.id()} gray for #done tag`);
            }
        }
        
        // Calculate temporal relevance and get marking intensity
        function getTemporalMarking(datePatterns, hasTodo, hasDone, today = new Date()) {
            if (!datePatterns || datePatterns.length === 0) {
                return null;
            }
            
            const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const currentWeek = getWeekNumber(today);
            const currentYear = today.getFullYear();
            
            let strongestMarking = null;
            
            datePatterns.forEach(pattern => {
                let marking = null;
                
                if (pattern.type === 'date') {
                    const targetDate = new Date(pattern.date.getFullYear(), pattern.date.getMonth(), pattern.date.getDate());
                    const daysDiff = Math.floor((targetDate - todayStart) / (24 * 60 * 60 * 1000));
                    
                    if (daysDiff === 0) {
                        // Today - strongest marking
                        marking = { intensity: 1.0, color: 'today', reason: 'Today' };
                    } else if (daysDiff === 1 && hasTodo) {
                        // Tomorrow + #todo - strong marking
                        marking = { intensity: 0.9, color: 'tomorrow-todo', reason: 'Tomorrow + #todo' };
                    } else if (daysDiff >= 2 && daysDiff <= 14) {
                        // 2-14 days future - gradual fade
                        const intensity = 0.8 - ((daysDiff - 2) / 12) * 0.6; // 0.8 -> 0.2
                        marking = { intensity, color: 'future', reason: `${daysDiff} days ahead` };
                    } else if (daysDiff < 0 && hasDone) {
                        // Past + #done - light green marking
                        marking = { intensity: 0.7, color: 'past-done', reason: 'Past + #done' };
                    } else if (daysDiff < 0 && hasTodo) {
                        // Past + #todo - black marking (highest intensity for past)
                        marking = { intensity: 0.85, color: 'past-todo', reason: 'Past + #todo' };
                    }
                } else if (pattern.type === 'week') {
                    if (pattern.year === currentYear && pattern.week === currentWeek) {
                        // Current week - strong marking
                        marking = { intensity: 0.8, color: 'current-week', reason: 'Current week' };
                    } else if (pattern.year === currentYear && pattern.week === currentWeek + 1) {
                        // Next week - milder but with #todo boost
                        const intensity = hasTodo ? 0.7 : 0.5;
                        marking = { intensity, color: 'next-week', reason: 'Next week' + (hasTodo ? ' + #todo' : '') };
                    }
                }
                
                // Keep strongest marking
                if (marking && (!strongestMarking || marking.intensity > strongestMarking.intensity)) {
                    strongestMarking = marking;
                }
            });
            
            return strongestMarking;
        }
        
        // Get border style for temporal marking (Cytoscape format)
        function getTemporalBorderStyle(marking) {
            if (!marking) return null;
            
            const baseWidth = Math.max(1, Math.ceil(marking.intensity * 1.5) + 0.5); // 1-2px width based on intensity
            
            const colorMap = {
                'today': '#ff4500', // Red-orange for today
                'tomorrow-todo': '#ff8c00', // Orange for tomorrow+todo
                'future': '#1e90ff', // Blue for future dates
                'past-todo': '#000000', // Black for past+todo
                'past-done': '#90EE90', // Light green for past+done
                'current-week': '#32cd32', // Lime green for current week
                'next-week': '#9370db' // Medium slate blue for next week
            };
            
            const color = colorMap[marking.color] || '#808080';
            
            return {
                'border-width': baseWidth,
                'border-color': color
            };
        }
        
        // Apply temporal markings to all cards
        function applyTemporalMarkings() {
            const today = new Date();
            console.log('🕒 Applying temporal markings for date:', today.toDateString());
            
            let markedCount = 0;
            
            cy.nodes().forEach(node => {
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const tags = node.data('tags') || [];
                const tagsString = tags.join(' ');
                const fullContent = title + ' ' + text + ' ' + tagsString;

                console.log(`Checking card "${title}": "${fullContent}"`);

                // Parse dates and check for todo/done
                const datePatterns = parseDateFromContent(fullContent);
                const hasTodo = hasTodoTag(node);
                const hasDone = hasDoneTag(node);
                
                console.log(`  - Date patterns found:`, datePatterns);
                console.log(`  - Has #todo:`, hasTodo);
                console.log(`  - Has #done:`, hasDone);
                
                // Get temporal marking
                const marking = getTemporalMarking(datePatterns, hasTodo, hasDone, today);
                console.log(`  - Temporal marking:`, marking);
                
                if (marking) {
                    // Apply border styling via node data and class
                    const borderStyle = getTemporalBorderStyle(marking);
                    if (borderStyle) {
                        console.log(`  - Applying border style:`, borderStyle);
                        
                        // Store temporal styling in node data
                        node.data('temporalBorderWidth', borderStyle['border-width']);
                        node.data('temporalBorderColor', borderStyle['border-color']);
                        
                        // Add temporal marking class to trigger stylesheet
                        node.addClass('temporal-marked');
                        
                        markedCount++;
                        console.log(`🎯 Marked card ${node.id()}: ${marking.reason} (intensity: ${marking.intensity.toFixed(2)}, color: ${borderStyle['border-color']}, width: ${borderStyle['border-width']})`);
                    }
                } else {
                    // Remove temporal marking
                    node.removeClass('temporal-marked');
                    node.removeData('temporalBorderWidth');
                    node.removeData('temporalBorderColor');
                }
            });
            
            // Force Cytoscape to update styling
            cy.style().update();
            
            console.log(`✅ Temporal marking complete: ${markedCount} cards marked`);
            return markedCount;
        }
        
        // Debug function to check hidden_tags - call this in console
        function debugHiddenTags() {
            console.log('=== HIDDEN TAGS DEBUG ===');
            cy.nodes().forEach(node => {
                const hiddenTags = node.data('hidden_tags') || [];
                const isCopy = node.data('isCopy');
                const copyOf = node.data('copyOf');
                const copyTimestamp = node.data('copyTimestamp');
                
                if (hiddenTags.length > 0 || isCopy) {
                    console.log(`Card ${node.id()}:`);
                    console.log(`  Title: "${node.data('title')}"`);
                    console.log(`  Hidden tags:`, hiddenTags);
                    console.log(`  isCopy:`, isCopy);
                    console.log(`  copyOf:`, copyOf);
                    console.log(`  copyTimestamp:`, copyTimestamp);
                    console.log('---');
                }
            });
            console.log('=== END DEBUG ===');
        }
        
        // Test copy search - call this in console 
        function testCopySearch() {
            console.log('🧪 Testing copy search functionality...');
            
            // Create test card
            const testNode = cy.add({
                data: {
                    id: 'test-copy-search',
                    title: 'Test Original',
                    text: 'This is a test card',
                    tags: ['test'],
                    hidden_tags: [],
                    searchMatch: false
                },
                position: { x: 100, y: 100 }
            });
            testNode.grabify();
            
            // Select and copy it
            testNode.select();
            copySelectedCards();
            
            // Create copy via arrangement
            arrangeCopiedCardsInRow();
            
            console.log('✅ Test setup complete. Now try searching for "copy_" in the search box');
            console.log('💡 Also try: debugHiddenTags() to see all hidden tags');
        }
        
        // Test function for temporal markings - call this in console
        function testTemporalMarkings() {
            // Create test cards with different date scenarios
            const testData = [
                { id: 'test-today', title: 'Today Test', text: 'Meeting @250816', x: 100, y: 100 },
                { id: 'test-tomorrow', title: 'Tomorrow Test', text: 'Task @250817 #todo', x: 300, y: 100 },
                { id: 'test-future', title: 'Future Test', text: 'Event @250820', x: 500, y: 100 },
                { id: 'test-week', title: 'Week Test', text: 'Week meeting @25w33', x: 700, y: 100 },
                { id: 'test-past', title: 'Past Test', text: 'Old task @250815 #todo', x: 900, y: 100 }
            ];
            
            // Add test cards
            testData.forEach(card => {
                // Remove if exists
                const existing = cy.getElementById(card.id);
                if (existing.length > 0) {
                    existing.remove();
                }
                
                const node = cy.add({
                    data: {
                        id: card.id,
                        title: card.title,
                        text: card.text,
                        tags: [],
                        searchMatch: false
                    },
                    position: { x: card.x, y: card.y }
                });
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                node.grabify();
            });
            
            // Apply temporal markings
            setTimeout(() => {
                applyTemporalMarkings();
            }, 500);
            
            console.log('🧪 Test cards created! Check console for marking details.');
        }
        
        // Get earliest date from card content for sorting
        function getEarliestDateFromContent(node) {
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = node.data('tags') || [];
            const tagsString = tags.join(' ');
            const fullContent = title + ' ' + text + ' ' + tagsString;

            const datePatterns = parseDateFromContent(fullContent);
            
            if (!datePatterns || datePatterns.length === 0) {
                // No dates found - use card creation date as fallback
                return extractDateFromId(node.id());
            }
            
            // Find earliest date from content
            let earliestDate = null;
            datePatterns.forEach(pattern => {
                const dateTime = pattern.date.getTime();
                if (!earliestDate || dateTime < earliestDate) {
                    earliestDate = dateTime;
                }
            });
            
            return earliestDate || extractDateFromId(node.id());
        }
        
        // Get today score for sorting - higher score means more likely to be today's content
        function getTodayScore(node) {
            const title = node.data('title') || '';
            const text = node.data('text') || '';
            const tags = (node.data('tags') || []).join(' ');
            const fullContent = title + ' ' + text + ' ' + tags;
            
            const today = new Date();
            const todayYYMMDD = getTodayYYMMDD();
            const todayMonthDay = getTodayMonthDay();
            
            let score = 0;
            
            // Check for YYMMDD format (e.g., 250912)
            if (fullContent.includes(todayYYMMDD)) {
                score += 100;
            }
            
            // Check for full date format (e.g., "12 september" or "12/9")
            const todayDay = today.getDate();
            const todayMonth = today.getMonth() + 1;
            const monthNames = ['januari', 'februari', 'mars', 'april', 'maj', 'juni', 
                              'juli', 'augusti', 'september', 'oktober', 'november', 'december'];
            const todayMonthName = monthNames[today.getMonth()];
            
            // Check for "12 september" format
            const dayMonthPattern = new RegExp(`\\b${todayDay}\\s+${todayMonthName}`, 'i');
            if (dayMonthPattern.test(fullContent)) {
                score += 100;
            }
            
            // Check for "12/9" or "12-9" format
            const numericPattern = new RegExp(`\\b${todayDay}[/-]${todayMonth}\\b`);
            if (numericPattern.test(fullContent)) {
                score += 100;
            }
            
            // Check for @YYMMDD format used by the date system
            if (fullContent.includes(`@${todayYYMMDD}`)) {
                score += 100;
            }
            
            // Check if card was created today by examining the card ID
            const cardCreationDate = getCardCreationDate(node.id());
            if (cardCreationDate && isSameDay(cardCreationDate, today)) {
                score += 50; // Lower score than explicit date mentions, but still prioritized
            }
            
            return score;
        }
        
        // Extract creation date from card ID (format: YYYYMMDD-HHMMSS)
        function getCardCreationDate(cardId) {
            try {
                // Handle timestamp-based IDs like "20250929-142030"
                const timestampMatch = cardId.match(/^(\d{8})-(\d{6})$/);
                if (timestampMatch) {
                    const dateStr = timestampMatch[1]; // YYYYMMDD
                    const timeStr = timestampMatch[2]; // HHMMSS
                    
                    const year = parseInt(dateStr.substr(0, 4));
                    const month = parseInt(dateStr.substr(4, 2)) - 1; // Month is 0-indexed
                    const day = parseInt(dateStr.substr(6, 2));
                    const hour = parseInt(timeStr.substr(0, 2));
                    const minute = parseInt(timeStr.substr(2, 2));
                    const second = parseInt(timeStr.substr(4, 2));
                    
                    return new Date(year, month, day, hour, minute, second);
                }
                
                // Handle other card ID formats if needed
                return null;
            } catch (error) {
                return null;
            }
        }
        
        // Check if two dates are on the same day
        function isSameDay(date1, date2) {
            return date1.getFullYear() === date2.getFullYear() &&
                   date1.getMonth() === date2.getMonth() &&
                   date1.getDate() === date2.getDate();
        }
        
        // Helper function to get today in YYMMDD format
        function getTodayYYMMDD() {
            const today = new Date();
            const year = today.getFullYear().toString().slice(-2);
            const month = (today.getMonth() + 1).toString().padStart(2, '0');
            const day = today.getDate().toString().padStart(2, '0');
            return year + month + day;
        }
        
        // Helper function to get today as month-day
        function getTodayMonthDay() {
            const today = new Date();
            return `${today.getDate()}/${today.getMonth() + 1}`;
        }
        
        // ========================================
        // MOBILE SEARCH SUPPORT
        // ========================================
        
        // Function to select search results (mobile-friendly alternative to Enter key)
        function selectSearchResults() {
            const searchMatches = cy.$('.search-match');
            console.log('Mobile select button pressed, found matches:', searchMatches.length);
            
            if (searchMatches.length > 0) {
                // Convert search matches to selected cards
                searchMatches.select();
                console.log('Selected search matches via mobile button');
                
                // Clear search visuals but keep cards selected
                searchActive = false;
                cy.nodes().removeClass('search-match');
                cy.nodes().data('searchMatch', false);
                
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.classList.remove('visible');
                
                // Hide the select button
                const selectBtn = document.getElementById('searchSelectBtn');
                selectBtn.style.display = 'none';
                
                // Blur the search input so keyboard shortcuts work
                const searchInput = document.getElementById('searchInput');
                searchInput.blur();
                
                console.log(`✅ Selected ${searchMatches.length} search results via mobile button`);
            }
        }
        
        // ========================================
        // END MOBILE SEARCH SUPPORT  
        // ========================================
        // ========================================
        // END DATE-BASED AUTO-MARKING SYSTEM
        // ========================================
        // ========================================
        // END SORTING SYSTEM
        // ========================================
        
        // Alignment functions for selected cards
        function alignSelectedVertical() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Get the leftmost card's X position as reference (fixed reference point)
            let referenceX = selectedNodes[0].position().x;
            selectedNodes.forEach(node => {
                if (node.position().x < referenceX) {
                    referenceX = node.position().x;
                }
            });
            
            // Sort cards by current Y position to maintain relative order
            const sortedNodes = selectedNodes.sort((a, b) => a.position().y - b.position().y);
            
            // Start from the topmost card's position, adjusted for its height
            const firstCardHeight = getMeasuredTextHeight(sortedNodes[0]);
            let currentY = sortedNodes[0].position().y - (firstCardHeight / 2);
            
            // Position each card using measured height + 20% spacing (60px)
            cy.batch(() => {
                sortedNodes.forEach((node, index) => {
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Position this card at its center Y
                    const centerY = currentY + (cardHeight / 2);
                    node.animate({
                        position: { x: referenceX, y: centerY }
                    }, {
                        duration: 300,
                        easing: 'ease-out'
                    });
                    
                    // Calculate next Y position with 20% spacing (60px)
                    if (index < sortedNodes.length - 1) {
                        const spacing = 60; // 20% of 300px card width
                        currentY += cardHeight + spacing;
                    }
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards vertically with 60px spacing`);
        }
        
        function alignSelectedVerticalSimple() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Get the leftmost card's X position as reference
            let referenceX = selectedNodes[0].position().x;
            selectedNodes.forEach(node => {
                if (node.position().x < referenceX) {
                    referenceX = node.position().x;
                }
            });
            
            // Align all cards to the same X position, keep original Y positions
            selectedNodes.forEach(node => {
                node.animate({
                    position: { x: referenceX, y: node.position().y }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards vertically (simple)`);
        }
        
        function alignSelectedHorizontal() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Calculate the average Y position for better alignment
            let totalY = 0;
            selectedNodes.forEach(node => {
                totalY += node.position().y;
            });
            const averageY = totalY / selectedNodes.length;
            
            // Align all cards to the average Y position (centers them)
            selectedNodes.forEach(node => {
                node.animate({
                    position: { x: node.position().x, y: averageY }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Aligned ${selectedNodes.length} cards horizontally at center`);
        }
        
        function arrangeSelectedInGrid() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInGrid();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            console.log('About to save state before grid arrangement');
            saveState();
            console.log('State saved, proceeding with arrangement');
            
            // Calculate grid dimensions
            const nodeCount = selectedNodes.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Calculate grid starting position (top-left corner)
            const spacing = 180; // Closer distance between cards for compact grid
            const gridWidth = (cols - 1) * spacing;
            const gridHeight = (rows - 1) * spacing;
            const startX = screenCenterX - (gridWidth / 2);
            const startY = screenCenterY - (gridHeight / 2);
            
            // Arrange nodes in grid with center alignment
            selectedNodes.forEach((node, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                const newX = startX + (col * spacing);
                const newY = startY + (row * spacing);
                
                node.animate({
                    position: { x: newX, y: newY }
                }, {
                    duration: 400,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered ${rows}×${cols} grid`);
        }
        
        function arrangeSelectedInColumn() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInColumn();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            
            // If only one card selected, move it instead of arranging
            if (selectedNodes.length === 1) {
                moveSelectedCard();
                return;
            }
            
            if (selectedNodes.length < 2) return;
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodesToArrange;
            if (sortMode) {
                nodesToArrange = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodesToArrange = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // Calculate total height needed for all cards with spacing
            let totalRequiredHeight = 0;
            nodesToArrange.forEach((node, index) => {
                const cardHeight = getCardHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < nodesToArrange.length - 1) {
                    totalRequiredHeight += 60; // 20% spacing (60px)
                }
            });
            
            // Start positioning from arrangement center, working upwards
            let currentY = centerY - (totalRequiredHeight / 2);
            
            nodesToArrange.forEach((node, index) => {
                // Get this card's actual height
                const cardHeight = getCardHeight(node);
                
                // Position this card at its center
                const cardCenterY = currentY + (cardHeight / 2);
                node.animate({
                    position: { x: centerX, y: cardCenterY }
                }, {
                    duration: 400,
                    easing: 'ease-out'
                });
                
                // Move to next card position
                if (index < selectedNodes.length - 1) {
                    const padding = 60; // 20% spacing
                    currentY += cardHeight + padding;
                }
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered column`);
        }
        
        function arrangeSelectedInRow() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInRow();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            console.log('H command: About to save state for undo');
            saveState();
            console.log('H command: State saved, proceeding with arrangement');
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then left-to-right order
            let sortedNodes;
            if (sortMode) {
                sortedNodes = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first, fallback to left-to-right
                const arrowSorted = getArrowBasedOrder(selectedNodes.toArray());
                sortedNodes = arrowSorted.length === selectedNodes.length ? arrowSorted : selectedNodes.sort((a, b) => a.position().x - b.position().x);
            }
            
            // Calculate total width needed for all cards with spacing (use 20% spacing)
            let totalRequiredWidth = 0;
            sortedNodes.forEach((node, index) => {
                const cardWidth = getCardWidth(node);
                totalRequiredWidth += cardWidth;
                if (index < sortedNodes.length - 1) {
                    totalRequiredWidth += 60; // 20% of 300px = 60px spacing
                }
            });
            
            // Start positioning from arrangement center, working leftwards
            let currentX = centerX - (totalRequiredWidth / 2);
            
            cy.batch(() => {
                sortedNodes.forEach((node, index) => {
                    // Get this card's actual width and height
                    const cardWidth = getCardWidth(node);
                    const cardHeight = getCardHeight(node);
                    
                    // Position this card with top-aligned positioning
                    const cardCenterX = currentX + (cardWidth / 2);
                    const cardCenterY = centerY + (cardHeight / 2); // Top-align: center Y based on card's height
                    
                    node.animate({
                        position: { x: cardCenterX, y: cardCenterY }
                    }, {
                        duration: 400,
                        easing: 'ease-out'
                    });
                    
                    // Move to next card position with 20% spacing
                    currentX += cardWidth + 60;
                });
            });
            
            console.log(`Arranged ${selectedNodes.length} cards in centered row with 20% spacing`);
        }
        
        // Helper function to calculate card width (considers geometric shapes)
        function getCardWidth(node) {
            // Check if it's a geometric shape with custom width
            if (node.data('isAnnotation') && node.data('customWidth')) {
                return node.data('customWidth');
            }
            return 300; // Fixed width for all regular cards
        }
        
        // Helper function to calculate card height (considers geometric shapes)
        function getCardHeight(node) {
            // Check if it's a geometric shape with custom height
            if (node.data('isAnnotation') && node.data('customHeight')) {
                return node.data('customHeight');
            }
            return getMeasuredTextHeight(node); // Use text-based height for regular cards
        }
        
        
        // Create new cards from copied data and arrange them in column
        function createAndArrangeInColumn() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create new nodes from copied card data
            const newNodes = [];
            copiedCards.forEach(cardData => {
                const newNode = cy.add({
                    data: {
                        id: generateCardId(),
                        title: cardData.title,
                        text: cardData.text,
                        tags: cardData.tags,
                        hidden_tags: cardData.hidden_tags,
                        searchMatch: false,
                        // Copy all metadata
                        export_timestamp: cardData.export_timestamp,
                        export_session: cardData.export_session,
                        export_source: cardData.export_source,
                        source_file: cardData.source_file,
                        page_number: cardData.page_number,
                        matched_terms: cardData.matched_terms,
                        card_index: cardData.card_index,
                        isManualCard: cardData.isManualCard,
                        cardColor: cardData.cardColor,
                        // Copy metadata
                        copyOf: cardData.copyOf,
                        isCopy: cardData.isCopy,
                        copyTimestamp: cardData.copyTimestamp
                    },
                    position: { x: centerX, y: centerY }
                });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Calculate total height needed for all cards with spacing
            let totalRequiredHeight = 0;
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < newNodes.length - 1) {
                    totalRequiredHeight += 60; // 20% spacing
                }
            });
            
            // Start positioning from arrangement center, working upwards
            let currentY = centerY - (totalRequiredHeight / 2);
            
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                
                node.position({ x: centerX, y: cardCenterY });
                
                // Move to next position
                if (index < newNodes.length - 1) {
                    currentY += cardHeight + 60;
                }
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in column`);
        }
        
        // Create new cards from copied data and arrange them in row (H command)
        function createAndArrangeInRow() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create new nodes from copied card data
            const newNodes = [];
            copiedCards.forEach(cardData => {
                const newNode = cy.add({
                    data: {
                        id: generateCardId(),
                        title: cardData.title,
                        text: cardData.text,
                        tags: cardData.tags,
                        hidden_tags: cardData.hidden_tags,
                        searchMatch: false,
                        isManualCard: cardData.isManualCard,
                        cardColor: cardData.cardColor,
                        copyOf: cardData.copyOf,
                        isCopy: cardData.isCopy,
                        copyTimestamp: cardData.copyTimestamp
                    },
                    position: { x: centerX, y: centerY }
                });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in horizontal row with 60px spacing
            const cardWidth = 300;
            const spacing = 60; // 20% spacing
            let totalWidth = newNodes.length * cardWidth + (newNodes.length - 1) * spacing;
            let currentX = centerX - (totalWidth / 2);
            
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterX = currentX + (cardWidth / 2);
                const cardCenterY = centerY + (cardHeight / 2);
                
                node.position({ x: cardCenterX, y: cardCenterY });
                currentX += cardWidth + spacing;
            });
            
            // Clear copied cards and select new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in row`);
        }
        
        // Move single selected card to mouse cursor
        function moveSelectedCard() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length !== 1) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const targetX = arrangePos.x;
            const targetY = arrangePos.y;
            
            const node = selectedNodes[0];
            const cardHeight = getMeasuredTextHeight(node);
            // Position so card's top edge is at mouse cursor
            const cardCenterY = targetY + (cardHeight / 2);
            
            node.animate({
                position: { x: targetX, y: cardCenterY }
            }, {
                duration: 300,
                easing: 'ease-out'
            });
            
            console.log(`Moved card to cursor position (${Math.round(targetX)}, ${Math.round(targetY)})`);
        }
        
        // Stack: Neat stack, top and left aligned at mouse cursor
        function stackSelectedCards() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const baseX = arrangePos.x; // Start at mouse cursor X
            const baseY = arrangePos.y; // Start at mouse cursor Y (top edge)
            
            // Sort cards by current position for consistent stacking
            const sortedNodes = selectedNodes.sort((a, b) => a.position().y - b.position().y);
            
            // Stack them with small offset for neat pile effect
            const stackOffsetX = 3; // 3px right offset per card
            const stackOffsetY = 5; // 5px down offset per card
            
            sortedNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const stackX = baseX + (index * stackOffsetX);
                // Position so first card's top edge is at mouse cursor Y
                const stackY = baseY + (index * stackOffsetY) + (cardHeight / 2);
                
                node.animate({
                    position: { x: stackX, y: stackY }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Stack: Created neat pile of ${selectedNodes.length} cards at cursor`);
        }
        
        function updateSelectionInfo() {
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectedNodes.length === 0) {
                selectionInfo.classList.remove('visible');
                return;
            }
            
            const count = selectedNodes.length;
            const pinnedCount = selectedNodes.filter('.pinned').length;
            const unpinnedCount = count - pinnedCount;
            
            let text = `${count} kort markerade`;
            if (pinnedCount > 0 && unpinnedCount > 0) {
                text += ` (${pinnedCount} pinnade, ${unpinnedCount} opinnde)`;
            } else if (pinnedCount > 0) {
                text += ` (alla pinnade)`;
            } else {
                text += ` (alla opinnde)`;
            }
            
            text += '<br><small>';
            if (count >= 2) {
                text += '1=kolumn, 2=rad, 3=rutnät, V=fördela↕, Shift+V=linje↕, H=linje↔';
            } else {
                text += 'P=pin, U=unpin, Delete=ta bort, Esc=avmarkera';
            }
            text += '</small>';
            
            selectionInfo.innerHTML = text;
            selectionInfo.classList.add('visible');
        }
        
        // Layout functions
        function applyLayout() {
            const layoutSelect = document.getElementById('layoutSelect');
            const selectedLayout = layoutSelect.value;
            
            let layoutOptions;
            
            switch(selectedLayout) {
                case 'cose':
                    layoutOptions = {
                        name: 'cose',
                        idealEdgeLength: 150,
                        nodeOverlap: 100,
                        refresh: 20,
                        fit: false,
                        padding: 50,
                        randomize: false,
                        componentSpacing: 100,
                        nodeRepulsion: 400000,
                        edgeElasticity: 100,
                        nestingFactor: 5,
                        gravity: 80,
                        numIter: 1000,
                        animate: true
                    };
                    break;
                case 'grid':
                    // Use custom smart grid layout instead of Cytoscape's grid
                    applySmartGridLayout();
                    return;
                default: // preset
                    // Don't run layout for manual positioning
                    return;
            }
            
            const layout = cy.layout(layoutOptions);
            layout.run();
        }
        
        // Smart column layout - all cards in single column with top alignment
        function arrangeAllInColumn() {
            const allNodes = cy.nodes();
            if (allNodes.length === 0) return;
            
            // Calculate center X position
            let totalX = 0;
            allNodes.forEach(node => {
                totalX += node.position().x;
            });
            const centerX = totalX / allNodes.length;
            
            // Calculate total height needed and start from center
            let totalRequiredHeight = 0;
            allNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < allNodes.length - 1) {
                    totalRequiredHeight += 30; // spacing between cards
                }
            });
            
            // Start positioning from center, working upwards
            let currentY = -(totalRequiredHeight / 2);
            
            allNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                
                node.animate({
                    position: { x: centerX, y: cardCenterY }
                }, {
                    duration: 500,
                    easing: 'ease-out'
                });
                
                // Move to next card position
                if (index < allNodes.length - 1) {
                    currentY += cardHeight + 30;
                }
            });
            
            // Show feedback
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `Kolumn-layout applicerat: ${allNodes.length} kort i en kolumn`;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // Smart grid layout using same spacing as arrangements
        function applySmartGridLayout() {
            const allNodes = cy.nodes();
            if (allNodes.length === 0) return;
            
            // Calculate grid dimensions
            const nodeCount = allNodes.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Calculate center point of all nodes
            let totalX = 0, totalY = 0;
            allNodes.forEach(node => {
                const pos = node.position();
                totalX += pos.x;
                totalY += pos.y;
            });
            const centerX = totalX / allNodes.length;
            const centerY = totalY / allNodes.length;
            
            // Measure card dimensions for smart spacing (same as arrangements)
            const ruler = document.getElementById('text-ruler');
            let maxCardWidth = 280; // Default
            let maxCardHeight = 120; // Default
            
            allNodes.forEach(node => {
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const tags = node.data('tags') || [];
                
                // Measure text height
                const combinedText = title + '\n\n' + text + '\n\n' + tags.map(tag => `#${tag}`).join(' ');
                ruler.textContent = combinedText;
                const measuredHeight = Math.max(140, ruler.offsetHeight + 40);
                maxCardHeight = Math.max(maxCardHeight, measuredHeight);
                
                // Calculate width based on content
                const baseWidth = 180;
                const extraWidth = Math.min(120, (title + text).length * 0.9);
                const cardWidth = baseWidth + extraWidth;
                maxCardWidth = Math.max(maxCardWidth, cardWidth);
            });
            
            // Add smart spacing
            const horizontalSpacing = maxCardWidth + 40;
            const verticalSpacing = maxCardHeight + 30;
            
            // Calculate grid starting position (centered)
            const gridWidth = (cols - 1) * horizontalSpacing;
            const gridHeight = (rows - 1) * verticalSpacing;
            const startX = centerX - gridWidth / 2;
            const startY = centerY - gridHeight / 2;
            
            // Position nodes in grid with top-aligned rows
            const nodeArray = allNodes.toArray();
            
            // Group nodes by row and calculate each row's top position
            for (let row = 0; row < rows; row++) {
                const rowNodes = [];
                const rowStartIndex = row * cols;
                const rowEndIndex = Math.min((row + 1) * cols, nodeArray.length);
                
                // Get nodes for this row
                for (let i = rowStartIndex; i < rowEndIndex; i++) {
                    rowNodes.push(nodeArray[i]);
                }
                
                // Find tallest card in this row to determine row height
                let maxRowHeight = 0;
                rowNodes.forEach(node => {
                    const cardHeight = getMeasuredTextHeight(node);
                    maxRowHeight = Math.max(maxRowHeight, cardHeight);
                });
                
                // Position each card in this row (top-aligned)
                rowNodes.forEach((node, colIndex) => {
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    const newX = startX + colIndex * horizontalSpacing;
                    const rowBaseY = startY + row * verticalSpacing;
                    // Align to top of row, then center the card within its space
                    const newY = rowBaseY;
                    
                    node.animate({
                        position: { x: newX, y: newY }
                    }, {
                        duration: 500,
                        easing: 'ease-out'
                    });
                });
            }
            
            // Show feedback
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.textContent = `Grid-layout applicerat: ${cols}×${rows} rutnät med ${allNodes.length} kort`;
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // G+V: Grid Vertical - column-focused arrangement with max gap between cards (bottom-edge to top-edge)
        function arrangeSelectedGridVerticalColumns() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridVerticalColumns();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState();
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // G+V: Column-focused arrangement with max gap between bottom-edge to top-edge
            const nodeCount = nodeArray.length;
            const maxCols = 6; // Max 6 columns
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const cardsPerCol = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 350; // Gap between columns
            const maxVerticalGap = 80; // Max gap from bottom-edge of upper card to top-edge of lower card
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Top-aligned columns - all start from same Y position (like G+H but vertical)
            const topLineY = screenCenterY; // All columns start from same top line
            
            // Arrange column by column (instead of row by row)
            for (let col = 0; col < cols; col++) {
                const colStartIndex = col * cardsPerCol;
                const colEndIndex = Math.min(colStartIndex + cardsPerCol, nodeCount);
                const cardsInThisCol = colEndIndex - colStartIndex;
                
                if (cardsInThisCol === 0) continue;
                
                const colX = startX + col * horizontalSpacing;
                
                // Start each column from the same top line
                let currentTopY = topLineY;
                
                // Place cards in this column with gap between bottom and top edges
                for (let cardIndex = 0; cardIndex < cardsInThisCol; cardIndex++) {
                    const nodeIndex = colStartIndex + cardIndex;
                    const node = nodeArray[nodeIndex];
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Card center is at currentTopY + half height
                    const cardCenterY = currentTopY + (cardHeight / 2);
                    
                    console.log(`🎯 G+V placing node ${nodeIndex} (${node.id()}) in col ${col}, position ${cardIndex}, top-aligned, gap: ${maxVerticalGap}px`);
                    
                    node.animate({
                        position: { x: colX, y: cardCenterY }
                    }, {
                        duration: 400,
                        easing: 'ease-out'
                    });
                    
                    // Move to next position: current card bottom + gap
                    currentTopY += cardHeight + maxVerticalGap;
                }
            }
            
            console.log(`G+V: Top-alignade kolumner - ${cols} kolumner, 80px vertikalt, 350px horisontellt`);
        }
        
        // G+H: Grid where rows are top-aligned and packed tightly (no row overlap)
        function arrangeSelectedGridHorizontalPacked() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridHorizontalPacked();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo before arranging
            saveState();
            
            // Use mouse position or fallback to screen center
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            const nodeCount = selectedNodes.length;
            const maxCols = 6;
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const rows = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 360; // 60px gap between cards (360 - 300 = 60)
            const rowPadding = 95; // Adjusted to get actual 60px visual spacing
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // First pass: calculate the height of each row
            const rowHeights = [];
            for (let row = 0; row < rows; row++) {
                let maxRowHeight = 0;
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        maxRowHeight = Math.max(maxRowHeight, cardHeight);
                    }
                }
                rowHeights.push(maxRowHeight);
            }
            
            // Calculate total height and start position - top of grid at mouse cursor
            const totalHeight = rowHeights.reduce((sum, height) => sum + height, 0) + (rows - 1) * rowPadding;
            let currentY = screenCenterY; // Top of grid at mouse cursor
            
            // Second pass: position cards row by row with tight packing
            for (let row = 0; row < rows; row++) {
                const rowHeight = rowHeights[row];
                
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const newX = startX + col * horizontalSpacing;
                        
                        // Position card at top of its row space
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2); // Top-aligned within row
                        
                        node.animate({
                            position: { x: newX, y: cardCenterY }
                        }, {
                            duration: 400,
                            easing: 'ease-out'
                        });
                    }
                }
                
                // Move to next row position
                currentY += rowHeight + rowPadding;
            }
            
            console.log(`G+H: Grid med packade rader - toppen vid muspekare - ${rows} rader × ${cols} kolumner för ${selectedNodes.length} kort`);
        }
        
        // G+T: Grid where all rows are top-aligned (all cards in same row at same height)
        // G+T (Grid Tight): Max 6 cards wide, 5% horizontal spacing, 40px overlap between cards vertically
        function arrangeSelectedGridTopAligned() {
            // Check if we should arrange copied cards instead
            if (copiedCards.length > 0) {
                arrangeCopiedCardsGridTopAligned();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            saveState(); // Save for undo
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            const nodeCount = selectedNodes.length;
            const maxCols = 6; // Max 6 cards wide
            const cols = Math.min(maxCols, nodeCount);
            const rows = Math.ceil(nodeCount / cols);
            
            const cardWidth = 300;
            const horizontalSpacing = cardWidth * 0.05; // 5% of card width = 15px
            const overlapSpacing = 120; // 120px between card tops (3x more to show titles)
            
            // Calculate grid size
            const gridWidth = (cols - 1) * (cardWidth + horizontalSpacing);
            const startX = screenCenterX - gridWidth / 2;
            
            // For top row alignment
            const topRowY = screenCenterY - 100; // Start a bit above center
            
            // Sort nodes - check arrows first, then custom sorting, then original order
            const wasSorted = !!sortMode;
            let nodeArray;
            if (sortMode) {
                nodeArray = sortNodes(selectedNodes.toArray());
                console.log('Applied sorting:', sortMode);
                sortMode = null;
                // Hide status message
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) statusDiv.classList.remove('visible');
            } else {
                // Try arrow-based sorting first
                nodeArray = getArrowBasedOrder(selectedNodes.toArray());
            }
            
            // Row-by-row placement to respect arrow sorting order
            for (let row = 0; row < rows; row++) {
                let currentY = topRowY + row * overlapSpacing;
                
                // Go through each column in this row
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < nodeArray.length) {
                        const node = nodeArray[nodeIndex];
                        const colX = startX + col * (cardWidth + horizontalSpacing);
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2);
                        
                        console.log(`🎯 G+T placing node ${nodeIndex} (${node.id()}) at col ${col}, row ${row}`);
                        
                        node.animate({
                            position: { x: colX, y: cardCenterY }
                        }, {
                            duration: 400,
                            easing: 'ease-out'
                        });
                    }
                }
            }
            
            // Z-LAYERING: Disabled for now - remove/re-add breaks original creation timestamps
            // TODO: Find Cytoscape method that changes render order without breaking node identity
            
            console.log(`G+T: Tight grid with 120px overlap - max ${maxCols} wide, ${rows} deep for ${selectedNodes.length} cards`);
        }
        
        // Change tracking for autosave
        let hasChanges = false;
        let autosaveInterval = null;
        
        // Mark that changes have been made
        function markChanged() {
            hasChanges = true;
        }
        
        // Save board to localStorage or file
        function saveBoard(filename = null, isAutosave = false) {
            const now = new Date();
            const boardData = {
                cards: cy.nodes().map(node => ({
                    id: node.id(),
                    title: node.data('title') || '',
                    text: node.data('text') || '',
                    tags: node.data('tags') || [],
                    hidden_tags: node.data('hidden_tags') || [],
                    position: node.position(),
                    pinned: node.hasClass('pinned') || false,
                    isManualCard: node.data('isManualCard') || false,
                    cardColor: node.data('cardColor') || null,
                    // Preserve all metadata for advanced analysis
                    export_timestamp: node.data('export_timestamp') || null,
                    export_session: node.data('export_session') || null,
                    export_source: node.data('export_source') || null,
                    source_file: node.data('source_file') || null,
                    page_number: node.data('page_number') || null,
                    matched_terms: node.data('matched_terms') || null,
                    card_index: node.data('card_index') || null,
                    // Annotation-specific data
                    isAnnotation: node.data('isAnnotation') || false,
                    annotationType: node.data('annotationType') || null,
                    customWidth: node.data('customWidth') || null,
                    customHeight: node.data('customHeight') || null,
                    customZIndex: node.data('customZIndex') || null,
                    // Save annotation color from visual style
                    annotationColor: node.data('isAnnotation') ? node.style('background-color') : null,
                    // Save shape data for geometric figures
                    shape: node.data('shape') || null,
                    // Save custom font size for geometric shapes
                    customFontSize: node.data('customFontSize') || null,
                    // Save copy metadata for copy tracking
                    copyOf: node.data('copyOf') || null,
                    isCopy: node.data('isCopy') || false,
                    copyTimestamp: node.data('copyTimestamp') || null,
                    // IMAGE DATA - New addition for v2.0 backwards compatibility
                    type: node.data('type') || null, // 'image' for image nodes
                    imageData: node.data('imageData') || null, // Base64 image data
                    annotation: node.data('annotation') || null, // Image annotation text
                    searchableText: node.data('searchableText') || null, // Lowercased searchable text
                    originalFileName: node.data('originalFileName') || null // Original filename
                })),
                edges: cy.edges().map(edge => ({
                    id: edge.id(),
                    source: edge.source().id(),
                    target: edge.target().id(),
                    // Preserve all edge data
                    isAnnotation: edge.data('isAnnotation') || false,
                    annotationType: edge.data('annotationType') || null,
                    customColor: edge.data('customColor') || null,
                    // Save all visual styling
                    style: {
                        'line-color': edge.style('line-color'),
                        'target-arrow-color': edge.style('target-arrow-color'),
                        'target-arrow-shape': edge.style('target-arrow-shape'),
                        'source-arrow-color': edge.style('source-arrow-color'),
                        'source-arrow-shape': edge.style('source-arrow-shape'),
                        'width': edge.style('width'),
                        'curve-style': edge.style('curve-style'),
                        'control-point-step-size': edge.style('control-point-step-size'),
                        'opacity': edge.style('opacity')
                    }
                })),
                viewport: {
                    zoom: cy.zoom(),
                    pan: cy.pan()
                },
                // Save global arrow visibility state
                arrowsHidden: window.arrowsHidden || false,
                lastModified: now.getTime(), // Unix timestamp for comparison
                timestamp: now.toISOString(), // Human readable
                version: '2.0' // Updated for image support
            };
            
            if (filename) {
                // Save to file
                const blob = new Blob([JSON.stringify(boardData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                // Save to localStorage
                localStorage.setItem('spatial-notes-board', JSON.stringify(boardData));
            }
            
            // Reset change tracking
            hasChanges = false;
            
            // Show saved message
            const searchInfo = document.getElementById('searchInfo');
            if (isAutosave) {
                searchInfo.textContent = 'Auto-sparad ✓';
            } else {
                searchInfo.textContent = 'Sparad ✓';
            }
            searchInfo.classList.add('visible');
            setTimeout(() => {
                searchInfo.classList.remove('visible');
            }, 2000);
        }
        
        // Save with timestamp filename
        function saveWithTimestamp() {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('.')[0];
            const filename = `board-name_${timestamp}.json`;
            saveBoard(filename);
        }
        
        // Save as dialog
        function saveAs() {
            const filename = prompt('Filnamn (utan .json):', 'my-board');
            if (filename) {
                saveBoard(filename.endsWith('.json') ? filename : filename + '.json');
            }
        }
        
        // Autosave function
        function performAutosave() {
            if (hasChanges) {
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('.')[0];
                const filename = `board-name_autosave_${timestamp}.json`;
                saveBoard(filename, true);
            }
        }
        
        // Start autosave timer
        function startAutosave() {
            if (autosaveInterval) {
                clearInterval(autosaveInterval);
            }
            // Every 20 minutes (1200000 ms)
            autosaveInterval = setInterval(performAutosave, 20 * 60 * 1000);
        }
        
        
        // Load board data (internal function without UI alerts)
        function loadBoardFromData(boardData) {
            try {
                // Safety check: Ensure Cytoscape is fully initialized
                if (!cy || !cy.nodes || !cy.add || typeof cy.add !== 'function') {
                    throw new Error('Cytoscape är inte redo än. Vänta ett ögonblick och försök igen.');
                }
                
                // Clear existing nodes
                cy.nodes().remove();
                
                // Add saved cards
                boardData.cards.forEach(cardData => {
                    const newNode = cy.add({
                        data: {
                            id: cardData.id,
                            title: cardData.title,
                            text: cardData.text,
                            tags: cardData.tags || [],
                            hidden_tags: cardData.hidden_tags || [],
                            searchMatch: false,
                            isManualCard: cardData.isManualCard || false,
                            cardColor: cardData.cardColor || null,
                            // Preserve metadata if present
                            export_timestamp: cardData.export_timestamp || null,
                            export_session: cardData.export_session || null,
                            export_source: cardData.export_source || null,
                            source_file: cardData.source_file || null,
                            page_number: cardData.page_number || null,
                            matched_terms: cardData.matched_terms || null,
                            card_index: cardData.card_index || null,
                            // Annotation-specific data
                            isAnnotation: cardData.isAnnotation || false,
                            annotationType: cardData.annotationType || null,
                            customWidth: cardData.customWidth || null,
                            customHeight: cardData.customHeight || null,
                            customZIndex: cardData.customZIndex || null,
                            // Store annotation color for restoration
                            annotationColor: cardData.annotationColor || null,
                            // Store shape data for geometric figures
                            shape: cardData.shape || null,
                            // Store custom font size for geometric shapes
                            customFontSize: cardData.customFontSize || null,
                            // Restore copy metadata for copy tracking
                            copyOf: cardData.copyOf || null,
                            isCopy: cardData.isCopy || false,
                            copyTimestamp: cardData.copyTimestamp || null,
                            // IMAGE DATA - Backwards compatible restoration
                            type: cardData.type || null, // 'image' for image nodes
                            imageData: cardData.imageData || null, // Base64 image data
                            annotation: cardData.annotation || null, // Image annotation text
                            searchableText: cardData.searchableText || null, // Lowercased searchable text
                            originalFileName: cardData.originalFileName || null // Original filename
                        },
                        position: cardData.position
                    });
                    
                    // Restore pinned state
                    if (cardData.pinned) {
                        newNode.addClass('pinned');
                        newNode.data('pinned', true);
                        newNode.ungrabify(); // Prevent dragging pinned cards
                    } else {
                        newNode.grabify(); // Make sure non-pinned cards are draggable
                    }

                    // Restore annotation shape class and text label
                    if (cardData.isAnnotation && cardData.annotationType === 'shape') {
                        newNode.addClass('annotation-shape');
                        
                        // Make sure text shows as label for annotations
                        if (cardData.text) {
                            newNode.style('label', cardData.text);
                            console.log('✅ Restored annotation text:', cardData.text, 'for node:', cardData.id);
                        }
                    }
                    
                    // Restore custom size, layer and color for annotation nodes
                    if (cardData.isAnnotation && (cardData.customWidth || cardData.customHeight || cardData.customZIndex !== null || cardData.annotationColor)) {
                        const width = cardData.customWidth || 120;
                        const height = cardData.customHeight || 120;
                        const zIndex = cardData.customZIndex !== null ? cardData.customZIndex : -1;
                        
                        // Convert internal z-index to Cytoscape z-index
                        let cyZIndex = 1; // default
                        if (zIndex === -1) cyZIndex = 0; // Background
                        if (zIndex === 0) cyZIndex = 1;  // Normal
                        if (zIndex === 1) cyZIndex = 2;  // Foreground
                        
                        const styleUpdate = {
                            'width': width + 'px',
                            'height': height + 'px',
                            'z-index': cyZIndex
                        };
                        
                        // Restore annotation color if saved
                        if (cardData.annotationColor && cardData.annotationColor !== 'rgb(255,255,255)') {
                            styleUpdate['background-color'] = cardData.annotationColor;
                        }
                        
                        // Restore custom font size if saved
                        if (cardData.customFontSize) {
                            styleUpdate['font-size'] = cardData.customFontSize + 'px';
                        }
                        
                        newNode.style(styleUpdate);
                        console.log('✅ Restored annotation styling for', newNode.id(), 'color:', cardData.annotationColor, 'shape:', cardData.shape);
                    }
                    
                    // Restore card color
                    if (cardData.cardColor) {
                        newNode.style('background-color', getCardColorValue(cardData.cardColor, getCurrentTheme()));
                    }
                    
                    // IMAGE NODE RESTORATION - Special handling for image nodes
                    if (cardData.type === 'image' && cardData.imageData) {
                        console.log('🖼️ Restoring image node:', cardData.originalFileName);
                        
                        // Apply image-specific styling (height will be calculated by Cytoscape style function)
                        newNode.style({
                            'background-image': cardData.imageData,
                            'background-fit': 'cover',
                            'width': '300px' // Same as regular cards
                        });
                        
                        // Update label to show annotation indicator if present
                        // Don't show filename in title, keep title empty for clean image display
                        newNode.data('title', '');
                        
                        const filename = cardData.originalFileName || 'Image';
                        const hasAnnotation = (cardData.annotation || '').length > 0;
                        console.log(`✅ Restored image: ${filename} (${hasAnnotation ? 'with annotation' : 'no annotation'})`);
                    }
                    
                    newNode.grabify();
                });
                
                // Restore edges/arrows if they exist
                if (boardData.edges && Array.isArray(boardData.edges)) {
                    boardData.edges.forEach(edgeData => {
                        const newEdge = cy.add({
                            data: {
                                id: edgeData.id,
                                source: edgeData.source,
                                target: edgeData.target,
                                isAnnotation: edgeData.isAnnotation || false,
                                annotationType: edgeData.annotationType || null,
                                customColor: edgeData.customColor || null
                            }
                        });
                        
                        // Apply annotation classes for styling
                        if (edgeData.isAnnotation) {
                            newEdge.addClass('annotation-connection');
                        }
                        
                        // Restore all visual styling
                        if (edgeData.style) {
                            newEdge.style(edgeData.style);
                            // Ensure arrow-scale is applied (for older saved edges)
                            if (!edgeData.style['arrow-scale']) {
                                newEdge.style('arrow-scale', 1.8);
                            }
                            // Ensure curve-style is applied (for older saved edges)
                            if (!edgeData.style['curve-style']) {
                                newEdge.style('curve-style', 'bezier');
                            }
                            console.log('✅ Restored edge styling for', edgeData.id, 'arrow shape:', edgeData.style['target-arrow-shape']);
                        }
                    });
                    console.log('✅ Restored', boardData.edges.length, 'edges/arrows');
                }
                
                // Card IDs are now timestamp-based, no counter needed
                
                // Restore viewport (zoom and pan) if saved
                if (boardData.viewport) {
                    cy.zoom(boardData.viewport.zoom);
                    cy.pan(boardData.viewport.pan);
                }
                
                // Restore global arrow visibility state
                if (boardData.arrowsHidden !== undefined) {
                    window.arrowsHidden = boardData.arrowsHidden;
                    if (window.arrowsHidden) {
                        // Apply hidden state to all edges
                        cy.edges().style('opacity', 0);
                    }
                }
                
                // Removed annoying "Laddade X kort!" alert - user can see the cards loaded
                
                // Apply temporal markings after data is loaded
                setTimeout(() => {
                    applyTemporalMarkings();
                }, 200);
                
            } catch (error) {
                console.error('Error loading board data:', error);
                throw error;
            }
        }
        
        // Load board from file
        function loadBoard() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const boardData = JSON.parse(e.target.result);
                            loadBoardFromData(boardData);
                            console.log(`File loaded: ${boardData.cards.length} cards and ${(boardData.edges || []).length} edges`);
                        } catch (error) {
                            alert('Fel vid laddning av fil: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        // Check for newer files on startup
        function checkForNewerFiles() {
            // This is a placeholder - browser can't scan local files for security reasons
            // User will need to manually check their folder or we could implement a file timestamp cache
            console.log('Note: Manual file checking needed - browser cannot scan local folder');
        }
        
        // Startup conflict detection (simplified for browser limitations)
        function checkStartupConflicts() {
            const savedData = localStorage.getItem('spatial-notes-board');
            if (savedData) {
                try {
                    const boardData = JSON.parse(savedData);
                    if (boardData.lastModified) {
                        const lastModified = new Date(boardData.lastModified);
                        const hoursSinceModified = (Date.now() - boardData.lastModified) / (1000 * 60 * 60);
                        
                        if (hoursSinceModified < 24) { // Show warning if modified within 24 hours
                            const timeAgo = hoursSinceModified < 1 ? 
                                `${Math.round(hoursSinceModified * 60)} minuter sedan` : 
                                `${Math.round(hoursSinceModified)} timmar sedan`;
                            
                            console.log(`Varning: LocalStorage har data sparad ${timeAgo}. Kom ihåg att ladda senaste version från fil om du arbetat på annan dator.`);
                            
                            // Show subtle reminder in status
                            const searchInfo = document.getElementById('searchInfo');
                            searchInfo.textContent = `💡 LocalStorage från ${timeAgo}`;
                            searchInfo.classList.add('visible');
                            setTimeout(() => {
                                searchInfo.classList.remove('visible');
                            }, 5000);
                        }
                    }
                } catch (error) {
                    console.error('Error checking startup conflicts:', error);
                }
            }
        }
        
        // Save board as standalone HTML file
        function saveAsHTMLFile() {
            const currentCards = cy.nodes().map(node => ({
                id: node.id(),
                title: node.data('title') || '',
                text: node.data('text') || '',
                tags: node.data('tags') || [],
                position: node.position(),
                pinned: node.hasClass('pinned') || false
            }));
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = prompt('Namn på HTML-fil:', `spatial-notes-${timestamp}`) || `spatial-notes-${timestamp}`;
            
            // Check if running locally (file://) - fetch won't work due to CORS
            if (window.location.protocol === 'file:') {
                alert('HTML-export fungerar inte när filen körs lokalt (file://) pga CORS-säkerhet.\n\nFör att använda HTML-export:\n1. Kör filen på en webbserver\n2. Eller använd "💾 Spara" istället (sparar till localStorage)');
                return;
            }
            
            // Read current HTML as template
            fetch(window.location.href)
                .then(response => response.text())
                .then(currentHTML => {
                    // Replace the initialCards array with current cards
                    const cardArrayRegex = /const initialCards = \[[\s\S]*?\];/;
                    const newCardsArray = `const initialCards = ${JSON.stringify(currentCards, null, 12)};`;
                    
                    let newHTML = currentHTML.replace(cardArrayRegex, newCardsArray);
                    
                    // Update title
                    newHTML = newHTML.replace(/<title>.*?<\/title>/, `<title>Spatial Notes - ${filename}</title>`);
                    
                    // Add metadata comment
                    const metadataComment = `<!-- Saved from Spatial Notes on ${new Date().toLocaleString('sv-SE')} with ${currentCards.length} cards -->`;
                    newHTML = newHTML.replace('</head>', `    ${metadataComment}\n</head>`);
                    
                    // Create and download file
                    const blob = new Blob([newHTML], { type: 'text/html;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename.endsWith('.html') ? filename : filename + '.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show confirmation
                    const searchInfo = document.getElementById('searchInfo');
                    searchInfo.textContent = `HTML-fil sparad: ${a.download} (${currentCards.length} kort)`;
                    searchInfo.classList.add('visible');
                    setTimeout(() => {
                        searchInfo.classList.remove('visible');
                    }, 3000);
                })
                .catch(error => {
                    console.error('Error creating HTML file:', error);
                    alert('Fel vid skapande av HTML-fil: ' + error.message);
                });
        }
        
        // Export board to JSON file (WORKS LOCALLY - No CORS issues!)
        function exportToJSON() {
            try {
                const exportData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        exportApp: 'Spatial Notes',
                        version: '2.0', // Updated for image support
                        totalCards: cy.nodes().length,
                        totalEdges: cy.edges().length,
                        totalImages: cy.nodes('[type="image"]').length
                    },
                    viewport: {
                        zoom: cy.zoom(),
                        pan: cy.pan()
                    },
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        hidden_tags: node.data('hidden_tags') || [],
                        position: {
                            x: Math.round(node.position().x),
                            y: Math.round(node.position().y)
                        },
                        pinned: node.hasClass('pinned') || false,
                        isManualCard: node.data('isManualCard') || false,
                        cardColor: node.data('cardColor') || null,
                        // Preserve all metadata for advanced analysis
                        export_timestamp: node.data('export_timestamp') || null,
                        export_session: node.data('export_session') || null,
                        export_source: node.data('export_source') || null,
                        source_file: node.data('source_file') || null,
                        page_number: node.data('page_number') || null,
                        matched_terms: node.data('matched_terms') || null,
                        card_index: node.data('card_index') || null,
                        // Annotation-specific data (geometric shapes)
                        isAnnotation: node.data('isAnnotation') || false,
                        annotationType: node.data('annotationType') || null,
                        customWidth: node.data('customWidth') || null,
                        customHeight: node.data('customHeight') || null,
                        customZIndex: node.data('customZIndex') || null,
                        customFontSize: node.data('customFontSize') || null,
                        // Save annotation color from visual style
                        annotationColor: node.data('isAnnotation') ? node.style('background-color') : null,
                        // Save shape data for geometric figures
                        shape: node.data('shape') || null,
                        // IMAGE DATA - Essential for exporting images
                        type: node.data('type') || null, // 'image' for image nodes
                        imageData: node.data('imageData') || null, // Base64 image data
                        annotation: node.data('annotation') || null, // Image annotation text
                        searchableText: node.data('searchableText') || null, // Searchable text
                        originalFileName: node.data('originalFileName') || null // Original filename
                    })),
                    edges: cy.edges().map(edge => ({
                        id: edge.id(),
                        source: edge.source().id(),
                        target: edge.target().id(),
                        // Preserve all edge data
                        isAnnotation: edge.data('isAnnotation') || false,
                        annotationType: edge.data('annotationType') || null,
                        customColor: edge.data('customColor') || null,
                        // Save all visual styling
                        style: {
                            'line-color': edge.style('line-color'),
                            'target-arrow-color': edge.style('target-arrow-color'),
                            'target-arrow-shape': edge.style('target-arrow-shape'),
                            'source-arrow-color': edge.style('source-arrow-color'),
                            'source-arrow-shape': edge.style('source-arrow-shape'),
                            'width': edge.style('width'),
                            'curve-style': edge.style('curve-style'),
                            'control-point-step-size': edge.style('control-point-step-size'),
                            'opacity': edge.style('opacity')
                        }
                    })),
                    // Save global arrow visibility state
                    arrowsHidden: window.arrowsHidden || false
                };
                
                // Generate filename with timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = prompt('Namn på JSON-fil:', `spatial-notes-${timestamp}.json`) || `spatial-notes-${timestamp}.json`;
                
                if (!filename) return; // User cancelled
                
                // Ensure .json extension
                const finalFilename = filename.endsWith('.json') ? filename : filename + '.json';
                
                // Create and download JSON file
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show confirmation
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = `📋 JSON-fil exporterad: ${finalFilename} (${exportData.cards.length} kort, ${exportData.edges.length} pilar)`;
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
                
                console.log(`JSON export completed: ${finalFilename} with ${exportData.cards.length} cards and ${exportData.edges.length} edges`);
                
            } catch (error) {
                console.error('Error exporting JSON:', error);
                alert('Fel vid JSON-export: ' + error.message);
            }
        }
        
        // Import board from JSON file (WORKS LOCALLY!)
        function importFromJSON() {
            // Create hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json,application/json';
            fileInput.style.display = 'none';
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Add a small delay to ensure Cytoscape is fully ready
                    setTimeout(() => {
                        try {
                            const importData = JSON.parse(e.target.result);
                            
                            // Validate JSON structure
                            if (!importData.cards || !Array.isArray(importData.cards)) {
                                throw new Error('Ogiltig JSON-fil: Saknar kort-data');
                            }
                            
                            // Safety check: Ensure Cytoscape is fully initialized
                            if (!cy || !cy.add || typeof cy.add !== 'function') {
                                alert('⚠️ Systemet laddas fortfarande. Vänta 2-3 sekunder och försök igen.');
                                return;
                            }
                        
                        // Always add to existing cards (no replace option)
                        
                        // Add imported cards
                        let importedCount = 0;
                        
                        // Generate import date in YYMMDD format
                        const now = new Date();
                        const importDate = now.getFullYear().toString().substr(-2) + 
                                          String(now.getMonth() + 1).padStart(2, '0') + 
                                          String(now.getDate()).padStart(2, '0');
                        
                        // Create ID mapping for edges
                        const idMapping = new Map();
                        
                        console.log(`🚀 Starting optimized import of ${importData.cards.length} cards...`);
                        
                        // Use batch mode for optimal performance
                        cy.batch(() => {
                            importData.cards.forEach(cardData => {
                            // Save original ID for origin tag
                            const originalId = cardData.id;
                            
                            // Always generate new unique ID for all imported cards
                            const timestamp = Date.now();
                            const random = Math.random().toString(36).substr(2, 9);
                            const newId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}-${random}`;
                            
                            cardData.id = newId;
                            
                            // Store ID mapping for edge updates
                            idMapping.set(originalId, newId);
                            
                            // Create hidden tags for import tracking
                            const hiddenTags = cardData.hidden_tags || [];
                            hiddenTags.push(`origin_${originalId}`);
                            hiddenTags.push(`import_${importDate}`);
                            
                            const newNode = cy.add({
                                data: {
                                    id: cardData.id,
                                    title: cardData.title || '',
                                    text: cardData.text || '',
                                    tags: cardData.tags || [],
                                    hidden_tags: hiddenTags,
                                    searchMatch: false,
                                    isManualCard: cardData.isManualCard || false,
                                    cardColor: cardData.cardColor || null,
                                    // Restore metadata
                                    export_timestamp: cardData.export_timestamp || null,
                                    export_session: cardData.export_session || null,
                                    export_source: cardData.export_source || null,
                                    source_file: cardData.source_file || null,
                                    page_number: cardData.page_number || null,
                                    matched_terms: cardData.matched_terms || null,
                                    card_index: cardData.card_index || null,
                                    // Annotation-specific data
                                    isAnnotation: cardData.isAnnotation || false,
                                    annotationType: cardData.annotationType || null,
                                    customWidth: cardData.customWidth || null,
                                    customHeight: cardData.customHeight || null,
                                    customZIndex: cardData.customZIndex || null,
                                    customFontSize: cardData.customFontSize || null,
                                    // Store annotation color for restoration
                                    annotationColor: cardData.annotationColor || null,
                                    // Store shape data for geometric figures
                                    shape: cardData.shape || null,
                                    // IMAGE DATA - Import compatibility for v2.0
                                    type: cardData.type || null,
                                    imageData: cardData.imageData || null,
                                    annotation: cardData.annotation || null,
                                    searchableText: cardData.searchableText || null,
                                    originalFileName: cardData.originalFileName || null
                                },
                                position: cardData.position || { x: Math.random() * 800 + 100, y: Math.random() * 600 + 100 }
                            });
                            
                            // Restore pinned state
                            if (cardData.pinned) {
                                newNode.addClass('pinned');
                                newNode.data('pinned', true);
                                newNode.ungrabify(); // Prevent dragging pinned cards
                            } else {
                                newNode.grabify(); // Make sure non-pinned cards are draggable
                            }

                            // Restore annotation shape class and text label
                            if (cardData.isAnnotation && cardData.annotationType === 'shape') {
                                newNode.addClass('annotation-shape');
                                
                                // Make sure text shows as label for annotations
                                if (cardData.text) {
                                    newNode.style('label', cardData.text);
                                }
                            }
                            
                            // Restore custom size, layer, color and font size for annotation nodes
                            if (cardData.isAnnotation && (cardData.customWidth || cardData.customHeight || cardData.customZIndex !== null || cardData.annotationColor || cardData.customFontSize)) {
                                const width = cardData.customWidth || 120;
                                const height = cardData.customHeight || 120;
                                const zIndex = cardData.customZIndex !== null ? cardData.customZIndex : -1;
                                
                                // Convert internal z-index to Cytoscape z-index
                                let cyZIndex = 1; // default
                                if (zIndex === -1) cyZIndex = 0; // Background
                                if (zIndex === 0) cyZIndex = 1;  // Normal
                                if (zIndex === 1) cyZIndex = 2;  // Foreground
                                
                                const styleUpdate = {
                                    'width': width + 'px',
                                    'height': height + 'px',
                                    'z-index': cyZIndex
                                };
                                
                                // Restore annotation color if saved
                                if (cardData.annotationColor && cardData.annotationColor !== 'rgb(255,255,255)') {
                                    styleUpdate['background-color'] = cardData.annotationColor;
                                }
                                
                                // Restore custom font size if saved
                                if (cardData.customFontSize) {
                                    styleUpdate['font-size'] = cardData.customFontSize + 'px';
                                }
                                
                                newNode.style(styleUpdate);
                            }
                            
                            // Restore card color
                            if (cardData.cardColor) {
                                newNode.style('background-color', getCardColorValue(cardData.cardColor, getCurrentTheme()));
                            }
                            
                            // IMAGE NODE RESTORATION - Import compatibility
                            if (cardData.type === 'image' && cardData.imageData) {
                                console.log('🖼️ Importing image node:', cardData.originalFileName);
                                
                                // Apply image-specific styling
                                newNode.style({
                                    'background-image': cardData.imageData,
                                    'background-fit': 'cover',
                                    'width': '300px'
                                });
                                
                                // Update title to show annotation indicator if present
                                // Don't show filename in title, keep title empty for clean image display
                                newNode.data('title', '');
                                
                                const filename = cardData.originalFileName || 'Imported Image';
                                const hasAnnotation = (cardData.annotation || '').length > 0;
                                console.log(`✅ Imported image: ${filename} (${hasAnnotation ? 'with annotation' : 'no annotation'})`);
                            }
                            
                            newNode.grabify();
                            importedCount++;
                        });
                        }); // End batch operation for cards
                        
                        console.log(`✅ Batch card import completed: ${importedCount} cards processed`);
                        
                        // Import edges/arrows if they exist  
                        let importedEdges = 0;
                        if (importData.edges && Array.isArray(importData.edges)) {
                            console.log(`🔗 Starting batch import of ${importData.edges.length} edges...`);
                            cy.batch(() => {
                                importData.edges.forEach(edgeData => {
                                // Map old IDs to new IDs
                                const newSourceId = idMapping.get(edgeData.source);
                                const newTargetId = idMapping.get(edgeData.target);
                                
                                // Only create edge if both source and target exist
                                if (newSourceId && newTargetId) {
                                    // Generate new edge ID
                                    const timestamp = Date.now();
                                    const random = Math.random().toString(36).substr(2, 9);
                                    const newEdgeId = `edge-${timestamp}-${random}`;
                                    
                                    const newEdge = cy.add({
                                        data: {
                                            id: newEdgeId,
                                            source: newSourceId,
                                            target: newTargetId,
                                            isAnnotation: edgeData.isAnnotation || false,
                                            annotationType: edgeData.annotationType || null,
                                            customColor: edgeData.customColor || null
                                        }
                                    });
                                
                                    // Apply annotation classes for styling
                                    if (edgeData.isAnnotation) {
                                        newEdge.addClass('annotation-connection');
                                    }
                                    
                                    // Restore all visual styling
                                    if (edgeData.style) {
                                        newEdge.style(edgeData.style);
                                    }
                                    
                                    importedEdges++;
                                } else {
                                    console.warn('Skipping edge - source or target not found:', edgeData.source, '->', edgeData.target);
                                }
                            });
                            }); // End batch operation for edges
                            console.log(`✅ Batch edge import completed: ${importedEdges} edges processed`);
                        }
                        
                        // Restore global arrow visibility state
                        if (importData.arrowsHidden !== undefined) {
                            window.arrowsHidden = importData.arrowsHidden;
                            if (window.arrowsHidden) {
                                // Apply hidden state to all edges
                                cy.edges().style('opacity', 0);
                            }
                        }
                        
                        // Card IDs are now timestamp-based, no counter needed
                        
                        // Restore viewport if available
                        if (importData.viewport) {
                            setTimeout(() => {
                                cy.zoom(importData.viewport.zoom);
                                cy.pan(importData.viewport.pan);
                            }, 100);
                        }
                        
                        // Show success message
                        let message = `📁 JSON-import lyckades: ${importedCount} kort`;
                        if (importedEdges > 0) {
                            message += `, ${importedEdges} pilar`;
                        }
                        message += ` importerade (alla fick nya ID:n + gömda taggar)`;
                        if (importData.metadata) {
                            message += `\nExportdatum: ${new Date(importData.metadata.exportDate).toLocaleString('sv-SE')}`;
                        }
                        
                        const searchInfo = document.getElementById('searchInfo');
                        searchInfo.textContent = message;
                        searchInfo.classList.add('visible');
                        setTimeout(() => {
                            searchInfo.classList.remove('visible');
                        }, 4000);
                        
                        console.log(`JSON import completed: ${importedCount} cards and ${importedEdges} edges imported`, importData.metadata);
                        
                        } catch (error) {
                            console.error('Error importing JSON:', error);
                            alert('Fel vid JSON-import: ' + error.message + '\n\nKontrollera att filen är en giltig Spatial Notes JSON-export.');
                        }
                    }, 100); // End of setTimeout
                };
                
                reader.readAsText(file);
            });
            
            // Trigger file picker
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
        }
        
        // Import cards from PDF-Extractor localStorage
        function importFromExtractor() {
            try {
                // Debug: Show all localStorage keys
                console.log('All localStorage keys:', Object.keys(localStorage));
                
                // Try different possible keys that PDF-extractor might use
                // PDF-Extractor uses the same localStorage key as spatial notes
                const extractorData = localStorage.getItem('spatial-notes-board');
                console.log('Checking for PDF-Extractor data in spatial-notes-board key');
                
                if (!extractorData) {
                    // Show debug info
                    const allKeys = Object.keys(localStorage);
                    alert(`Ingen data från PDF-Extractor hittades!\n\nDebug info:\nLocalStorage nycklar: ${allKeys.join(', ')}\n\nKör PDF-extractor först och exportera kort till Spatial Notes.`);
                    return;
                }
                
                const importedCards = JSON.parse(extractorData);
                
                if (!Array.isArray(importedCards) || importedCards.length === 0) {
                    alert('PDF-Extractor data är tom eller ogiltig.');
                    return;
                }
                
                // Check if we have existing cards in spatial notes
                const hasExistingCards = cy.nodes().length > 0;
                const existingIds = new Set(cy.nodes().map(n => n.id()));
                
                // Filter out cards that already exist in spatial notes
                const newCards = importedCards.filter(card => !existingIds.has(card.id));
                
                if (newCards.length === 0) {
                    alert('Inga nya kort att importera från PDF-Extractor. Alla kort finns redan.');
                    return;
                }
                
                let replaceExisting = false;
                
                if (hasExistingCards) {
                    replaceExisting = confirm(
                        `PDF-Extractor har ${newCards.length} NYA kort att importera.\n` +
                        `Du har ${cy.nodes().length} befintliga kort.\n\n` +
                        `Klicka OK för att ERSÄTTA alla kort\n` +
                        `Klicka Avbryt för att LÄGGA TILL endast de nya korten`
                    );
                }
                
                // Use only new cards if not replacing
                if (!replaceExisting) {
                    importedCards = newCards;
                }
                
                // Clear existing cards if replacing
                if (replaceExisting) {
                    cy.nodes().remove();
                }
                
                // Add imported cards with smart positioning
                let importedCount = 0;
                let duplicateCount = 0;
                
                importedCards.forEach((cardData, index) => {
                    // Check for duplicate IDs if not replacing
                    if (!replaceExisting && cy.getElementById(cardData.id).length > 0) {
                        // Generate new unique ID for duplicate
                        cardData.id = cardData.id + '_imported_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                        duplicateCount++;
                    }
                    
                    // Smart positioning: arrange in grid if no position provided
                    let position = cardData.position;
                    if (!position || (position.x === 0 && position.y === 0)) {
                        const cols = Math.ceil(Math.sqrt(importedCards.length));
                        const col = index % cols;
                        const row = Math.floor(index / cols);
                        position = {
                            x: 200 + col * 320,
                            y: 200 + row * 200
                        };
                    }
                    
                    const newNode = cy.add({
                        data: {
                            id: cardData.id,
                            title: cardData.title || '',
                            text: cardData.text || '',
                            tags: cardData.tags || [],
                            hidden_tags: cardData.hidden_tags || [],
                            searchMatch: false,
                            // Preserve PDF-extractor metadata
                            export_timestamp: cardData.export_timestamp || null,
                            export_session: cardData.export_session || null,
                            export_source: cardData.export_source || 'pdf_extractor',
                            source_file: cardData.source_file || null,
                            page_number: cardData.page_number || null,
                            matched_terms: cardData.matched_terms || null,
                            card_index: cardData.card_index || null
                        },
                        position: position
                    });
                    
                    newNode.grabify();
                    importedCount++;
                });
                
                // Card IDs are now timestamp-based, no counter needed
                
                // Clear the PDF-extractor data so it doesn't import again
                // localStorage.removeItem('pdf-extractor-export'); // Don't clear, let user decide
                
                // Show success message
                let message = `📥 PDF-Extractor import lyckades: ${importedCount} kort importerade`;
                if (duplicateCount > 0) {
                    message += ` (${duplicateCount} dubbletter fick nya ID:n)`;
                }
                
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = message;
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 4000);
                
                console.log(`PDF-Extractor import completed: ${importedCount} cards imported`);
                
            } catch (error) {
                console.error('Error importing from PDF-Extractor:', error);
                alert('Fel vid import från PDF-Extractor: ' + error.message);
            }
        }

        // Map Zotero highlight colors to spatial-notes card colors
        function mapZoteroColorToCard(bgColorStyle) {
            // Extract hex color from style like "background-color: #ffd40080"
            const match = bgColorStyle.match(/#([0-9a-fA-F]{6})/);
            if (!match) return null;

            const hexColor = match[1].toLowerCase();

            // Map Zotero colors to spatial-notes card-color-X
            const colorMap = {
                'ffd400': 'card-color-4', // Gul
                'ff6666': 'card-color-3', // Röd
                '5fb236': 'card-color-1', // Grön
                '2ea8e5': 'card-color-6', // Blå/Cyan
                'a28ae5': 'card-color-5', // Lila
                'e56eee': 'card-color-5', // Magenta → Lila
                'f19837': 'card-color-2', // Orange
                'aaaaaa': 'card-color-7'  // Grå
            };

            return colorMap[hexColor] || null;
        }

        // Import notes from Zotero HTML export
        function importFromZoteroHTML(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const htmlContent = e.target.result;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');

                    // Find all highlight paragraphs
                    const highlightParagraphs = doc.querySelectorAll('p');

                    let importedCount = 0;
                    const timestamp = Date.now();
                    const session = `zotero_${timestamp}`;

                    highlightParagraphs.forEach((p, index) => {
                        // Find the highlight span with background color
                        const highlightSpan = p.querySelector('span.highlight span[style*="background-color"]');
                        if (!highlightSpan) return;

                        // Extract the quote text
                        const quoteText = highlightSpan.textContent.trim();
                        if (!quoteText) return;

                        // Extract color
                        const bgStyle = highlightSpan.getAttribute('style');
                        const cardColor = mapZoteroColorToCard(bgStyle);

                        // Extract citation if available
                        const citationSpan = p.querySelector('span.citation');
                        let citation = '';
                        if (citationSpan) {
                            citation = citationSpan.textContent.trim();
                        }

                        // Extract link/URL if available
                        const linkElement = p.querySelector('a');
                        let zoteroLink = '';
                        if (linkElement && linkElement.href) {
                            zoteroLink = linkElement.href;
                        }

                        // Create hidden tags for tracking
                        const hidden_tags = [
                            `zotero_import_${timestamp}`,
                            `source_${file.name.replace('.html', '')}`
                        ];

                        if (citation) {
                            hidden_tags.push(`citation_${citation.replace(/[^a-zA-Z0-9]/g, '_')}`);
                        }

                        // Add link as metadata (if exists)
                        if (zoteroLink) {
                            hidden_tags.push(`url_${zoteroLink}`);
                        }

                        // Grid positioning
                        const cols = Math.ceil(Math.sqrt(highlightParagraphs.length));
                        const col = index % cols;
                        const row = Math.floor(index / cols);
                        const position = {
                            x: 200 + col * 320,
                            y: 200 + row * 200
                        };

                        // Create card with full metadata
                        // Generate unique ID with index to avoid duplicates in batch import
                        const baseId = generateCardId();
                        const cardId = `${baseId}-z${index}`;

                        // Combine quote with citation for display
                        let cardText = quoteText;
                        if (citation) {
                            cardText = `${quoteText}\n\n${citation}`;
                        }

                        const nodeData = {
                            id: cardId,
                            title: '',
                            text: cardText,
                            tags: [],
                            hidden_tags: hidden_tags,
                            searchMatch: false,
                            // Import metadata (osynlig)
                            export_timestamp: new Date().toISOString(),
                            export_session: session,
                            export_source: 'zotero',
                            source_file: file.name,
                            page_number: null,
                            matched_terms: citation || null,
                            zotero_url: zoteroLink || null,  // Store Zotero link as metadata
                            card_index: index,
                            // Kort-status
                            isManualCard: false,
                            cardColor: cardColor,
                            // Kopia-tracking (ej tillämpligt vid import)
                            copyOf: null,
                            isCopy: false,
                            copyTimestamp: null
                        };

                        const newNode = cy.add({
                            group: 'nodes',
                            data: nodeData,
                            position: position
                        });

                        // Apply color styling if we have a color
                        if (cardColor) {
                            newNode.style('background-color', getCardColorValue(cardColor, getCurrentTheme()));
                        }

                        newNode.grabify();
                        importedCount++;
                    });

                    // Show success message
                    const searchInfo = document.getElementById('searchInfo');
                    if (searchInfo) {
                        searchInfo.textContent = `📚 Zotero import: ${importedCount} kort importerade från ${file.name}`;
                        searchInfo.classList.add('visible');
                        setTimeout(() => {
                            searchInfo.classList.remove('visible');
                        }, 4000);
                    }

                    console.log(`Zotero import completed: ${importedCount} cards imported from ${file.name}`);

                } catch (error) {
                    console.error('Error importing from Zotero:', error);
                    alert('Fel vid import från Zotero HTML: ' + error.message);
                }
            };

            reader.readAsText(file);
        }

        // Clear board completely
        function clusterSelectedCards() {
            // If we have copied cards, create and arrange them. Otherwise, arrange selected nodes.
            if (copiedCards.length > 0) {
                arrangeCopiedCardsInCluster();
                return;
            }
            
            const selectedNodes = cy.$('node:selected, node[searchMatch="true"]');
            if (selectedNodes.length < 2) return;
            
            // Save state for undo
            saveState();
            
            // Get center position (mouse or screen center)
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Small cluster radius
            const radius = 50;
            
            // Arrange in tight circle
            selectedNodes.forEach((node, index) => {
                const angle = (index / selectedNodes.length) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                node.animate({
                    position: { x: x, y: y }
                }, {
                    duration: 300,
                    easing: 'ease-out'
                });
            });
            
            console.log(`Q: Klustrade ${selectedNodes.length} kort`);
        }

        function executeCommand(command) {
            const selectedNodes = cy.$('node:selected');
            
            switch(command) {
                case 'H':
                    arrangeSelectedInRow();
                    break;
                case 'G+V':
                    arrangeSelectedGridVerticalColumns();
                    break;
                case 'G+H':
                    arrangeSelectedGridHorizontalPacked();
                    break;
                case 'G+T':
                    arrangeSelectedGridTopAligned();
                    break;
                case 'Q':
                    clusterSelectedCards();
                    break;
                case 'C':
                    copySelectedCards();
                    break;
                case 'T':
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        const fakeEvent = {
                            clientX: window.innerWidth / 2,
                            clientY: window.innerHeight / 2
                        };
                        showColorPicker(fakeEvent, selectedNodes);
                    }
                    break;
                case 'V':
                    arrangeSelectedInColumn();
                    break;
                case 'Stack':
                case 'QQ':
                case 'Alt+S':
                    stackSelectedCards();
                    break;
                case 'Pin':
                    selectedNodes.forEach(node => {
                        pinCard(node);
                    });
                    break;
                case 'Unpin':
                    selectedNodes.forEach(node => {
                        unpinCard(node);
                    });
                    break;
                case 'Delete':
                    deleteSelectedCards();
                    break;
                case 'Ctrl+Z':
                    // Trigger undo
                    if (undoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        redoStack.push(currentState);
                        
                        const previousState = undoStack.pop();
                        restoreState(previousState);
                    }
                    break;
                case 'Ctrl+Y':
                    // Trigger redo
                    if (redoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        undoStack.push(currentState);
                        
                        const nextState = redoStack.pop();
                        restoreState(nextState);
                    }
                    break;
                case 'Ctrl+A':
                    cy.nodes().not('.pinned').select();
                    break;
                case 'Ctrl+S':
                    saveBoard();
                    break;
            }
        }

        function debugDumpPositions() {
            console.log('\n=== KORT POSITIONER DEBUG ===');
            cy.nodes().forEach(node => {
                const pos = node.position();
                const title = node.data('title') || 'Untitled';
                console.log(`${node.id()}: x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)} - "${title}"`);
            });
            console.log('=== SLUT DEBUG ===\n');
            
            const searchInfo = document.getElementById('searchInfo');
            if (searchInfo) {
                searchInfo.textContent = 'Kort-positioner dumpade till console (F12)';
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
            }
        }

        function toggleDarkTheme() {
            const body = document.body;
            const themeBtn = document.getElementById('themeBtn');

            let currentTheme = 'light';
            if (body.classList.contains('dark-theme')) {
                currentTheme = 'dark';
            } else if (body.classList.contains('sepia-theme')) {
                currentTheme = 'sepia';
            } else if (body.classList.contains('eink-theme')) {
                currentTheme = 'eink';
            }

            // Cycle through themes: light -> dark -> sepia -> eink -> light
            if (currentTheme === 'light') {
                body.classList.remove('eink-theme', 'sepia-theme');
                body.classList.add('dark-theme');
                themeBtn.innerHTML = '📜 Sepia';
                localStorage.setItem('theme', 'dark');
                applyCardTheme('dark');
            } else if (currentTheme === 'dark') {
                body.classList.remove('dark-theme', 'eink-theme');
                body.classList.add('sepia-theme');
                themeBtn.innerHTML = '📄 E-ink';
                localStorage.setItem('theme', 'sepia');
                applyCardTheme('sepia');
            } else if (currentTheme === 'sepia') {
                body.classList.remove('dark-theme', 'sepia-theme');
                body.classList.add('eink-theme');
                themeBtn.innerHTML = '☀️ Ljust';
                localStorage.setItem('theme', 'eink');
                applyCardTheme('eink');
            } else {
                body.classList.remove('dark-theme', 'sepia-theme', 'eink-theme');
                themeBtn.innerHTML = '🌙 Mörkt';
                localStorage.setItem('theme', 'light');
                applyCardTheme('light');
            }
        }
        
        // Get card color value based on theme
        function getCardColorValue(colorId, theme) {
            const colors = {
                light: {
                    1: '#d4f2d4', // Grön
                    2: '#ffe4b3', // Orange
                    3: '#ffc1cc', // Röd
                    4: '#fff7b3', // Gul
                    5: '#f3e5f5', // Lila
                    6: '#c7e7ff', // Blå
                    7: '#e0e0e0', // Grå
                    8: '#ffffff'  // Vit
                },
                dark: {
                    1: '#3d5a3d', // Mörk Grön
                    2: '#5a4d3a', // Mörk Orange
                    3: '#5a3c3a', // Mörk Röd
                    4: '#5a5a3a', // Mörk Gul
                    5: '#4a3d5a', // Mörk Lila
                    6: '#2e4a6f', // Mörk Blå
                    7: '#555555', // Mörk Grå
                    8: '#8a8a8a'  // Ljusgrå (vit blir för ljus i dark theme)
                },
                sepia: {
                    1: '#ded6c7', // Sepia Grön
                    2: '#e6d6c2', // Sepia Orange
                    3: '#ead6c7', // Sepia Röd
                    4: '#ebe2d6', // Sepia Gul
                    5: '#e2d6c7', // Sepia Lila
                    6: '#d6c7b3', // Sepia Blå
                    7: '#c0b8a8', // Sepia Grå
                    8: '#f5f2e8'  // Sepia Vit
                }
            };
            
            // Extract number from colorId (card-color-1 -> 1)
            const colorNumber = colorId.toString().replace('card-color-', '');
            
            return colors[theme] && colors[theme][colorNumber] ? colors[theme][colorNumber] : null;
        }

        function applyCardTheme(theme) {
            if (cy) {
                if (theme === 'dark') {
                    // Dark theme styling
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    // Color priority: if card has color, use it regardless of theme
                                    return getCardColorValue(cardColor, 'dark');
                                }
                                return '#2a2a2a';
                            },
                            'color': '#f0f0f0',
                            'border-color': '#555'
                        })
                        .selector('node:selected').style({
                            'border-color': '#66b3ff',  // Bright blue for visibility
                            'border-width': 5,
                            'box-shadow': '0 0 25px rgba(102, 179, 255, 0.8)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#4a3c00',  // Dark yellow background
                            'border-color': '#ffcc00',     // Bright yellow border
                            'border-width': 3,
                            'box-shadow': '0 0 15px rgba(255, 204, 0, 0.6)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#4caf50',  // Bright green
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(76, 175, 80, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                } else if (theme === 'sepia') {
                    // Sepia theme styling
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    return getCardColorValue(cardColor, 'sepia');
                                }
                                return '#f0e6d2';
                            },
                            'color': '#5d4e37',
                            'border-color': '#c8a882'
                        })
                        .selector('node:selected').style({
                            'border-color': '#8b7556',  // Dark brown for sepia
                            'border-width': 4,
                            'box-shadow': '0 0 20px rgba(139, 117, 86, 0.7)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#f4e8d0',  // Light sepia highlight
                            'border-color': '#d2691e',     // Chocolate border
                            'border-width': 2,
                            'box-shadow': '0 0 10px rgba(210, 105, 30, 0.5)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#8fbc8f',  // Dark sea green for sepia
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(143, 188, 143, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                } else if (theme === 'eink') {
                    // E-ink theme styling - no shadows, sharp contrast
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    // Keep card colors - user said it's OK
                                    return getCardColorValue(cardColor, 'light');
                                }
                                return '#ffffff';
                            },
                            'color': '#000000',
                            'border-color': '#000000',
                            'border-width': 2
                        })
                        .selector('node:selected').style({
                            'border-color': '#000000',
                            'border-width': 4,
                            'box-shadow': 'none'  // No shadows for e-ink
                        })
                        .selector('node.search-match').style({
                            'background-color': '#f0f0f0',
                            'border-color': '#000000',
                            'border-width': 3,
                            'box-shadow': 'none'  // No shadows for e-ink
                        })
                        .selector('node.pinned').style({
                            'border-color': '#000000',
                            'border-width': 4,
                            'box-shadow': 'none'  // No shadows for e-ink
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 4;
                            },
                            'border-color': '#000000'  // All black for e-ink
                        })
                        .update();
                } else {
                    // Light theme styling (default)
                    cy.style()
                        .selector('node').style({
                            'background-color': function(node) {
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    return getCardColorValue(cardColor, 'light');
                                }
                                return '#ffffff';
                            },
                            'color': '#333333',
                            'border-color': '#ddd'
                        })
                        .selector('node:selected').style({
                            'border-color': '#1565c0',
                            'border-width': 4,
                            'box-shadow': '0 0 20px rgba(21, 101, 192, 0.7)'
                        })
                        .selector('node.search-match').style({
                            'background-color': '#fff9c4',
                            'border-color': '#f57f17',
                            'border-width': 2,
                            'box-shadow': '0 0 10px rgba(245, 127, 23, 0.4)'
                        })
                        .selector('node.pinned').style({
                            'border-color': '#2e7d32',
                            'border-width': 4,
                            'box-shadow': '0 0 15px rgba(46, 125, 50, 0.6)'
                        })
                        .selector('node.temporal-marked').style({
                            'border-width': function(node) {
                                return node.data('temporalBorderWidth') || 6;
                            },
                            'border-color': function(node) {
                                return node.data('temporalBorderColor') || '#ff4500';
                            }
                        })
                        .update();
                }
            }
        }
        
        // Load saved theme on page load
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme') || localStorage.getItem('darkTheme'); // Backward compatibility
            const themeBtn = document.getElementById('themeBtn');

            // Handle backward compatibility
            let theme = 'light';
            if (savedTheme === 'dark' || savedTheme === 'true') {
                theme = 'dark';
            } else if (savedTheme === 'sepia') {
                theme = 'sepia';
            } else if (savedTheme === 'eink') {
                theme = 'eink';
            }

            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
                if (themeBtn) {
                    themeBtn.innerHTML = '📜 Sepia';
                }
                setTimeout(() => applyCardTheme('dark'), 100);
            } else if (theme === 'sepia') {
                document.body.classList.add('sepia-theme');
                if (themeBtn) {
                    themeBtn.innerHTML = '📄 E-ink';
                }
                setTimeout(() => applyCardTheme('sepia'), 100);
            } else if (theme === 'eink') {
                document.body.classList.add('eink-theme');
                if (themeBtn) {
                    themeBtn.innerHTML = '☀️ Ljust';
                }
                setTimeout(() => applyCardTheme('eink'), 100);
            } else {
                if (themeBtn) {
                    themeBtn.innerHTML = '🌙 Mörkt';
                }
                setTimeout(() => applyCardTheme('light'), 100);
            }
        }

        function clearBoard() {
            if (confirm('Är du säker på att du vill rensa hela brädan och localStorage?\n\nDetta kommer att:\n• Ta bort alla kort från brädan\n• Rensa sparad data i localStorage\n• Återställa till tom bräda\n\nDenna åtgärd kan inte ångras!')) {
                // Clear memoization cache
                heightCache.clear();
                // Clear all nodes from the board
                cy.nodes().remove();
                
                // Clear localStorage
                localStorage.removeItem('spatial-notes-board');
                
                // Card IDs are now timestamp-based, no counter to reset
                
                // Show confirmation
                const searchInfo = document.getElementById('searchInfo');
                searchInfo.textContent = 'Bräda och localStorage rensade! ✅';
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
                
                console.log('Board and localStorage cleared completely');
            }
        }
        
        // Toggle metadata view for development and analysis
        let showMetadata = false;
        function toggleMetadataView() {
            showMetadata = !showMetadata;
            const btn = document.getElementById('metadataBtn');
            
            if (showMetadata) {
                btn.textContent = '🔍 Dölj Metadata';
                btn.style.backgroundColor = '#ff9800';
                
                // Show metadata in console and as overlays
                console.log('=== SPATIAL NOTES METADATA ===');
                cy.nodes().forEach(node => {
                    const metadata = {
                        id: node.id(),
                        export_timestamp: node.data('export_timestamp'),
                        export_session: node.data('export_session'),
                        export_source: node.data('export_source'),
                        source_file: node.data('source_file'),
                        page_number: node.data('page_number'),
                        matched_terms: node.data('matched_terms'),
                        card_index: node.data('card_index')
                    };
                    console.log(`${node.id()}:`, metadata);
                });
                
                // Add metadata styling
                cy.style().selector('node').style({
                    'border-color': function(node) {
                        const session = node.data('export_session');
                        if (!session) return '#ddd';
                        // Color-code by export session
                        const hash = session.split('').reduce((a, b) => {
                            a = ((a << 5) - a) + b.charCodeAt(0);
                            return a & a;
                        }, 0);
                        const color = `hsl(${Math.abs(hash) % 360}, 70%, 60%)`;
                        return color;
                    },
                    'border-width': 3
                }).update();
                
                // Show stats
                const stats = analyzeMetadata();
                alert(`Metadata aktiverad!\n\n${stats}\n\nKolla konsolen för detaljer.`);
                
            } else {
                btn.textContent = '🔍 Metadata';
                btn.style.backgroundColor = '#007acc';
                
                // Reset styling
                cy.style().selector('node').style({
                    'border-color': '#ddd',
                    'border-width': 2
                }).update();
                
                console.log('Metadata view disabled');
            }
        }
        
        function analyzeMetadata() {
            const nodes = cy.nodes();
            const sessions = new Set();
            const sources = new Set();
            let pdfCards = 0;
            let manualCards = 0;
            
            nodes.forEach(node => {
                const session = node.data('export_session');
                const source = node.data('export_source');
                
                if (session) sessions.add(session);
                if (source) sources.add(source);
                
                if (source === 'pdf_extractor') pdfCards++;
                else manualCards++;
            });
            
            return `Totalt: ${nodes.length} kort\n` +
                   `PDF-kort: ${pdfCards}\n` +
                   `Manuella kort: ${manualCards}\n` +
                   `Export-sessioner: ${sessions.size}\n` +
                   `Källor: ${sources.size}`;
        }
        
        // ====================================================================================================
        // 📱 SIMPLIFIED TOOLBAR FUNCTIONS
        // ====================================================================================================
        
        let isSimplifiedToolbar = localStorage.getItem('spatial-notes-simplified-toolbar') === 'true';
        
        function toggleSimplifiedToolbar() {
            isSimplifiedToolbar = !isSimplifiedToolbar;
            localStorage.setItem('spatial-notes-simplified-toolbar', isSimplifiedToolbar);
            updateToolbarDisplay();

            // Update toggle button appearance
            const toggleBtn = document.getElementById('toolbarToggleBtn');
            if (toggleBtn) {
                if (isSimplifiedToolbar) {
                    toggleBtn.innerHTML = '⚙️ Full Toolbar';
                    toggleBtn.title = 'Visa full toolbar (Shift+T)';
                } else {
                    toggleBtn.innerHTML = '☰ Toolbar';
                    toggleBtn.title = 'Växla mellan förenklad och full toolbar (Shift+T)';
                }
            }

            const statusMessage = isSimplifiedToolbar ?
                'Förenklad toolbar aktiverad' :
                'Full toolbar aktiverad';

            // Show status message using existing searchInfo element
            const searchInfo = document.getElementById('searchInfo');
            if (searchInfo) {
                searchInfo.textContent = statusMessage;
                searchInfo.classList.add('visible');
                setTimeout(() => {
                    searchInfo.classList.remove('visible');
                }, 3000);
            }
        }
        
        function updateToolbarDisplay() {
            const toolbar = document.querySelector('.toolbar');
            const allElements = toolbar.children;

            // Update toggle button appearance
            const toggleBtn = document.getElementById('toolbarToggleBtn');
            if (toggleBtn) {
                if (isSimplifiedToolbar) {
                    toggleBtn.innerHTML = '⚙️ Full Toolbar';
                    toggleBtn.title = 'Visa full toolbar (Shift+T)';
                } else {
                    toggleBtn.innerHTML = '☰ Toolbar';
                    toggleBtn.title = 'Växla mellan förenklad och full toolbar (Shift+T)';
                }
            }

            if (isSimplifiedToolbar) {
                // Hide all elements
                Array.from(allElements).forEach(el => {
                    if (!el.classList.contains('simplified-keep')) {
                        el.style.display = 'none';
                    }
                });

                // Show simplified elements
                showSimplifiedToolbar();
            } else {
                // Show all elements
                Array.from(allElements).forEach(el => {
                    el.style.display = '';
                });

                // Hide simplified elements
                hideSimplifiedToolbar();
            }
        }
        
        function showSimplifiedToolbar() {
            let simplifiedToolbar = document.getElementById('simplifiedToolbar');
            if (!simplifiedToolbar) {
                createSimplifiedToolbar();
            } else {
                simplifiedToolbar.style.display = 'flex';
            }
        }
        
        function hideSimplifiedToolbar() {
            const simplifiedToolbar = document.getElementById('simplifiedToolbar');
            if (simplifiedToolbar) {
                simplifiedToolbar.style.display = 'none';
            }
        }
        
        function createSimplifiedToolbar() {
            const toolbar = document.querySelector('.toolbar');
            
            const simplifiedDiv = document.createElement('div');
            simplifiedDiv.id = 'simplifiedToolbar';
            simplifiedDiv.className = 'simplified-keep';
            simplifiedDiv.style.cssText = `
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
            `;
            
            // Multi-import button
            const importBtn = document.createElement('button');
            importBtn.innerHTML = '📋';
            importBtn.className = 'toolbar-btn';
            importBtn.title = 'Multi-import (M)';
            importBtn.style.cssText = 'padding: 8px 12px;';
            importBtn.onclick = showMultiCardPasteDialog;

            // Drive images picker button
            const driveImagesBtn = document.createElement('button');
            driveImagesBtn.innerHTML = '📁';
            driveImagesBtn.className = 'toolbar-btn';
            driveImagesBtn.title = 'Välj flera bilder från Drive';
            driveImagesBtn.style.cssText = 'padding: 8px 12px;';
            driveImagesBtn.onclick = openDriveImagePicker;

            // Smart search button
            const searchBtn = document.createElement('button');
            searchBtn.innerHTML = '🔍';
            searchBtn.className = 'toolbar-btn';
            searchBtn.title = 'Smart sökning med automatisk sortering';
            searchBtn.style.cssText = 'padding: 8px 12px;';
            searchBtn.onclick = showSmartSearchDialog;
            
            // Sort button
            const sortBtn = document.createElement('button');
            sortBtn.innerHTML = '📊';
            sortBtn.className = 'toolbar-btn';
            sortBtn.title = 'Sortera kort';
            sortBtn.style.cssText = 'padding: 8px 12px;';
            sortBtn.onclick = (event) => showSortMenu(event);

            // Toggle to full toolbar button
            const expandBtn = document.createElement('button');
            expandBtn.innerHTML = '⚙️ Meny';
            expandBtn.className = 'toolbar-btn';
            expandBtn.title = 'Visa hela menyn (Shift+T)';
            expandBtn.style.cssText = 'padding: 8px 12px; margin-left: auto;';  // Push to right
            expandBtn.onclick = toggleSimplifiedToolbar;

            simplifiedDiv.appendChild(importBtn);
            simplifiedDiv.appendChild(driveImagesBtn);
            simplifiedDiv.appendChild(searchBtn);
            simplifiedDiv.appendChild(sortBtn);
            simplifiedDiv.appendChild(expandBtn);

            toolbar.appendChild(simplifiedDiv);
        }
        
        // Open Google Drive Picker to select multiple images
        async function openDriveImagePicker() {
            // Ensure user is signed in
            if (!isSignedIn || !accessToken) {
                updateSyncStatus('Sign in to use Drive Picker', 'info');
                // Trigger sign-in
                tokenClient.requestAccessToken();
                return;
            }

            // Ensure Picker API is loaded
            if (!pickerApiLoaded) {
                alert('Google Picker is loading... Try again in a moment.');
                return;
            }

            console.log('🖼️ Opening Google Drive Picker for images...');

            // Create and configure the Picker
            const picker = new google.picker.PickerBuilder()
                .setOAuthToken(accessToken)
                .setDeveloperKey(GOOGLE_API_KEY)
                .setAppId(GOOGLE_CLIENT_ID.split('-')[0]) // Extract app ID from client ID
                .addView(
                    new google.picker.DocsView(google.picker.ViewId.DOCS_IMAGES)
                        .setIncludeFolders(true)
                        .setSelectFolderEnabled(false)
                )
                .addView(new google.picker.DocsView(google.picker.ViewId.FOLDERS).setSelectFolderEnabled(false))
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
                .setCallback(pickerCallback)
                .setTitle('Välj bilder från Drive')
                .build();

            picker.setVisible(true);
        }

        // Handle Picker selection callback
        async function pickerCallback(data) {
            if (data.action === google.picker.Action.PICKED) {
                console.log('✅ User selected files:', data.docs);

                const selectedFiles = data.docs;
                updateSyncStatus(`Importerar ${selectedFiles.length} bilder...`, 'loading');

                let imported = 0;
                let failed = 0;

                for (const file of selectedFiles) {
                    try {
                        // Download image from Drive
                        const response = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        });

                        if (!response.ok) {
                            console.error(`Failed to download ${file.name}:`, response.statusText);
                            failed++;
                            continue;
                        }

                        const blob = await response.blob();

                        // Convert to image data and create card
                        const imageData = await processImage(blob);
                        createImageNode(imageData, file.name);

                        imported++;
                        console.log(`✅ Imported ${file.name}`);

                    } catch (error) {
                        console.error(`Error importing ${file.name}:`, error);
                        failed++;
                    }
                }

                // Show result
                const message = failed > 0
                    ? `✅ Importerade ${imported} bilder (${failed} misslyckades)`
                    : `✅ Importerade ${imported} bilder från Drive`;

                updateSyncStatus(message, 'success');
                setTimeout(() => updateSyncStatus('', ''), 3000);

                // Save board after import
                saveBoard();
            } else if (data.action === google.picker.Action.CANCEL) {
                console.log('User cancelled picker');
            }
        }

        function showSmartSearchDialog() {
            // Create overlay for search input
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 400px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">🔍 Smart sökning</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Sök efter:</label>
                    <input type="text" id="smartSearchInput" placeholder='Exempel: "todo" OR "viktigt"'
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="margin-bottom: 20px; font-size: 12px; color: #666;">
                    <strong>Automatisk sortering:</strong><br>
                    1. Vecko-todos (äldsta först)<br>
                    2. Färgordning: Röd → Orange → Vit → Gul → Lila → Blå → Grön → Grå
                </div>
                <div style="text-align: right;">
                    <button id="cancelSmartSearch" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="executeSmartSearch" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">🔍 Sök & Sortera</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on input
            const searchInput = document.getElementById('smartSearchInput');
            searchInput.focus();
            
            // Handle search
            document.getElementById('executeSmartSearch').onclick = function() {
                const query = searchInput.value.trim();
                if (query) {
                    // Perform the search with smart sorting
                    performSearch(query);
                    
                    // Show success message
                    const searchInfo = document.getElementById('searchInfo');
                    if (searchInfo) {
                        searchInfo.textContent += ' (smart sorterat)';
                    }
                }
                document.body.removeChild(overlay);
            };
            
            // Handle cancel
            document.getElementById('cancelSmartSearch').onclick = function() {
                document.body.removeChild(overlay);
            };
            
            // Handle Enter key
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('executeSmartSearch').click();
                } else if (e.key === 'Escape') {
                    document.getElementById('cancelSmartSearch').click();
                }
            });
            
            // Close on overlay click
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        
        // ====================================================================================================
        // 📅 WEEK NUMBERING FUNCTIONS
        // ====================================================================================================
        
        function getISOWeek(date) {
            const tempDate = new Date(date.getTime());
            const dayNum = (date.getDay() + 6) % 7; // Make Monday = 0
            tempDate.setDate(tempDate.getDate() - dayNum + 3); // Thursday of this week
            const firstThursday = tempDate.valueOf();
            tempDate.setMonth(0, 1); // January 1
            if (tempDate.getDay() !== 4) {
                tempDate.setMonth(0, 1 + ((4 - tempDate.getDay()) + 7) % 7);
            }
            return 1 + Math.ceil((firstThursday - tempDate) / 604800000); // 604800000 = 7 * 24 * 3600 * 1000
        }
        
        function getCurrentWeekData() {
            const now = new Date();
            const currentYear = now.getFullYear();
            const shortYear = currentYear.toString().slice(-2); // "25" for 2025
            const currentWeek = getISOWeek(now);
            
            // Calculate next weeks, handle year transition
            const nextWeek = currentWeek + 1;
            const weekAfter = currentWeek + 2;
            
            // Handle year transition (approximately - ISO weeks can be tricky at year boundaries)
            let nextWeekYear = shortYear;
            let weekAfterYear = shortYear;
            
            if (nextWeek > 52) {
                nextWeekYear = (parseInt(shortYear) + 1).toString().padStart(2, '0');
                if (weekAfter > 52) {
                    weekAfterYear = nextWeekYear;
                }
            }
            
            return {
                thisWeek: `${shortYear}v${currentWeek}`,
                nextWeek: nextWeek > 52 ? `${nextWeekYear}v${nextWeek - 52}` : `${shortYear}v${nextWeek}`,
                weekAfter: weekAfter > 52 ? `${weekAfterYear}v${weekAfter - 52}` : `${shortYear}v${weekAfter}`
            };
        }
        
        // ====================================================================================================
        
        // Add new card
        function addNewCard() {
            // Clear any existing edit dialogs first
            clearAllEditDialogs();
            
            // Create overlay for multiline text input
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Nytt kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="newCardText" placeholder="Skriv text här... (radbrytningar bevaras)"
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;"></textarea>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Färg (valfritt):</label>
                    <div id="newCardColorPicker" style="display: flex; gap: 8px; align-items: center;">
                        <div class="color-dot" data-color="" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #f5f5f5; border: 2px solid #ddd; cursor: pointer; position: relative;"
                             title="Ingen färg">
                            <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                  font-size: 16px; color: #666;">⭘</span>
                        </div>
                        <div class="color-dot" data-color="1" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #d4f2d4; border: 2px solid transparent; cursor: pointer;" title="Grön"></div>
                        <div class="color-dot" data-color="2" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffe4b3; border: 2px solid transparent; cursor: pointer;" title="Orange"></div>
                        <div class="color-dot" data-color="3" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffc1cc; border: 2px solid transparent; cursor: pointer;" title="Röd"></div>
                        <div class="color-dot" data-color="4" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #fff7b3; border: 2px solid transparent; cursor: pointer;" title="Gul"></div>
                        <div class="color-dot" data-color="5" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #f3e5f5; border: 2px solid transparent; cursor: pointer;" title="Lila"></div>
                        <div class="color-dot" data-color="6" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #c7e7ff; border: 2px solid transparent; cursor: pointer;" title="Blå"></div>
                        <div class="color-dot" data-color="7" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #e0e0e0; border: 2px solid transparent; cursor: pointer;" title="Grå"></div>
                        <div class="color-dot" data-color="8" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffffff; border: 2px solid transparent; cursor: pointer;" title="Vit"></div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="newCardTags" placeholder="tech, psychology, design..."
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">📅 Snabbveckor:</label>
                    <div id="weekButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <!-- Week buttons will be populated by JavaScript -->
                    </div>
                </div>
                <div style="text-align: right;">
                    <button id="cancelCard" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveCard" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara kort</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea
            const textarea = document.getElementById('newCardText');
            textarea.focus();
            
            // Handle color picker selection
            let selectedColor = '';
            const colorDots = document.querySelectorAll('#newCardColorPicker .color-dot');
            colorDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    // Remove selection from all dots
                    colorDots.forEach(d => d.style.border = d.dataset.color ? '2px solid transparent' : '2px solid #ddd');
                    
                    // Select this dot
                    this.style.border = '2px solid #007acc';
                    selectedColor = this.dataset.color;
                });
            });
            
            // Populate week buttons
            const weekData = getCurrentWeekData();
            const weekButtonsContainer = document.getElementById('weekButtons');
            const weekButtons = [
                { text: weekData.thisWeek, label: 'denna vecka', title: 'Denna vecka' },
                { text: weekData.nextWeek, label: 'nästa vecka', title: 'Nästa vecka' },
                { text: weekData.weekAfter, label: 'nästnästa vecka', title: 'Veckan efter nästa' }
            ];
            
            weekButtons.forEach(btn => {
                const weekBtn = document.createElement('button');
                weekBtn.type = 'button';
                weekBtn.innerHTML = `<strong>${btn.text}</strong><br><small>${btn.label}</small>`;
                weekBtn.title = btn.title;
                weekBtn.style.cssText = `
                    background: #f8f9fa;
                    border: 1px solid #dee2e6;
                    border-radius: 6px;
                    padding: 8px 12px;
                    cursor: pointer;
                    font-size: 12px;
                    line-height: 1.2;
                    transition: all 0.2s ease;
                    text-align: center;
                    min-width: 70px;
                `;
                
                weekBtn.addEventListener('mouseenter', function() {
                    this.style.background = '#e9ecef';
                    this.style.borderColor = '#007acc';
                });
                
                weekBtn.addEventListener('mouseleave', function() {
                    this.style.background = '#f8f9fa';
                    this.style.borderColor = '#dee2e6';
                });
                
                weekBtn.addEventListener('click', function() {
                    const tagsInput = document.getElementById('newCardTags');
                    const currentTags = tagsInput.value.trim();
                    const weekTag = btn.text;
                    
                    if (currentTags) {
                        // Add to existing tags
                        if (!currentTags.includes(weekTag)) {
                            tagsInput.value = currentTags + ', ' + weekTag;
                        }
                    } else {
                        // First tag
                        tagsInput.value = weekTag;
                    }
                    
                    // Visual feedback
                    this.style.background = '#d4edda';
                    this.style.borderColor = '#28a745';
                    setTimeout(() => {
                        this.style.background = '#f8f9fa';
                        this.style.borderColor = '#dee2e6';
                    }, 500);
                });
                
                weekButtonsContainer.appendChild(weekBtn);
            });
            
            // Handle save
            document.getElementById('saveCard').onclick = function() {
                const text = textarea.value.trim();
                if (!text) {
                    alert('Text krävs för att skapa kort');
                    return;
                }
                
                const tagsInput = document.getElementById('newCardTags').value || '';
                const tags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                const newId = generateCardId();
                
                // Position card based on device type
                let x, y;
                const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window);
                
                if (isMobile) {
                    // Mobile: center of screen
                    const extent = cy.extent();
                    x = (extent.x1 + extent.x2) / 2;
                    y = (extent.y1 + extent.y2) / 2;
                } else {
                    // Desktop: at mouse position (or fallback to center)
                    const arrangePos = getArrangementPosition();
                    x = arrangePos.x;
                    y = arrangePos.y;
                }
                
                const newNode = cy.add({
                    data: {
                        id: newId,
                        title: null, // Explicitly null to avoid any title processing
                        text: text, // Keep line breaks as-is
                        tags: tags,
                        searchMatch: false,
                        isManualCard: true // Flag to identify manually created cards
                    },
                    position: { x: x, y: y }
                });
                
                // Apply selected color if any
                if (selectedColor) {
                    newNode.data('cardColor', `card-color-${selectedColor}`);
                }
                
                newNode.grabify();
                
                // Force refresh of node styling
                cy.style().update();
                
                document.body.removeChild(overlay);
            };
            
            // Handle cancel
            document.getElementById('cancelCard').onclick = function() {
                document.body.removeChild(overlay);
            };
            
            // Handle Enter to save (Ctrl+Enter or Shift+Enter for new lines)
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    document.getElementById('saveCard').click();
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Regular Enter and Shift+Enter allow normal newline behavior
            });
        }
        
        // Zoom out to center (mobile function)
        function zoomOutToCenter() {
            cy.fit(null, 50); // Fit all nodes with 50px padding
            cy.center(); // Center the view
        }
        
        // Helper function to create node from card data (handles both regular and image nodes)
        function createNodeFromCardData(cardData, newId, position) {
            const nodeData = {
                id: newId,
                title: cardData.title,
                text: cardData.text,
                tags: cardData.tags,
                hidden_tags: cardData.hidden_tags || [],
                searchMatch: false,
                // Copy metadata
                export_timestamp: cardData.export_timestamp,
                export_session: cardData.export_session,
                export_source: cardData.export_source,
                source_file: cardData.source_file,
                page_number: cardData.page_number,
                matched_terms: cardData.matched_terms,
                card_index: cardData.card_index,
                // Copy metadata
                copyOf: cardData.copyOf,
                isCopy: cardData.isCopy,
                copyTimestamp: cardData.copyTimestamp,
                // IMAGE DATA - Essential for image nodes
                type: cardData.type,
                imageData: cardData.imageData,
                imageWidth: cardData.imageWidth,        // Store original dimensions
                imageHeight: cardData.imageHeight,      // Store original dimensions
                calculatedHeight: cardData.calculatedHeight, // Store pre-calculated height
                annotation: cardData.annotation,
                searchableText: cardData.searchableText,
                originalFileName: cardData.originalFileName
            };

            const newNode = cy.add({
                data: nodeData,
                position: position
            });

            // Apply image-specific styling if it's an image node
            if (cardData.type === 'image' && cardData.imageData) {
                newNode.style({
                    'background-image': cardData.imageData,
                    'background-fit': 'cover',
                    'width': '300px'
                });
                console.log(`📷 Created image copy: ${cardData.originalFileName}`);
            }

            // Apply auto-gray coloring for #done tags
            applyAutoDoneColoring(newNode);

            return newNode;
        }

        // Copy selected cards
        function copySelectedCards() {
            const selectedNodes = cy.nodes(':selected');
            if (selectedNodes.length === 0) {
                alert('Inga kort markerade för kopiering');
                return;
            }
            
            // Save state for undo before copying (copies will be created when arranged)
            saveState();
            
            // Generate timestamp for copy tagging
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/[-T:]/g, '').slice(0, 13); // YYYYMMDD_HHmm format
            
            copiedCards = [];
            
            selectedNodes.forEach((node, index) => {
                const originalData = {
                    title: node.data('title') || '',
                    text: node.data('text') || '',
                    tags: [...(node.data('tags') || [])], // Clone array
                    hidden_tags: [...(node.data('hidden_tags') || [])], // Clone hidden tags array
                    // Copy all metadata too
                    export_timestamp: node.data('export_timestamp'),
                    export_session: node.data('export_session'),
                    export_source: node.data('export_source'),
                    source_file: node.data('source_file'),
                    page_number: node.data('page_number'),
                    matched_terms: node.data('matched_terms'),
                    card_index: node.data('card_index'),
                    // IMAGE NODE DATA - Essential for copying images
                    type: node.data('type'), // 'image' for image nodes
                    imageData: node.data('imageData'), // Base64 image data
                    annotation: node.data('annotation'), // Image annotation text
                    searchableText: node.data('searchableText'), // Searchable text
                    originalFileName: node.data('originalFileName') // Original filename
                };
                
                // Add copy metadata to hidden tags (searchable but not visible)
                const copyTag = `copy_${timestamp}_${index + 1}`;
                originalData.hidden_tags.push(copyTag);
                originalData.copyOf = node.id();
                originalData.isCopy = true;
                originalData.copyTimestamp = now.toISOString();
                
                copiedCards.push(originalData);
            });
            
            console.log(`Copied ${copiedCards.length} cards with timestamp ${timestamp}`);
        }
        
        // Arrange copied cards in row at mouse position
        function arrangeCopiedCardsInRow() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Now arrange them in a row (H-logic: 20% spacing = 60px)
            const spacing = 60; // 20% spacing as per spec
            let totalRequiredWidth = 0;
            newNodes.forEach((node, index) => {
                const cardWidth = getCardWidth(node);
                totalRequiredWidth += cardWidth;
                if (index < newNodes.length - 1) {
                    totalRequiredWidth += spacing;
                }
            });
            
            let currentX = centerX - (totalRequiredWidth / 2);
            newNodes.forEach(node => {
                const cardWidth = getCardWidth(node);
                const cardHeight = getMeasuredTextHeight(node);
                
                // Position with top-aligned positioning (same as original)
                const cardCenterX = currentX + (cardWidth / 2);
                const cardCenterY = centerY + (cardHeight / 2); // Top-align: center Y based on card's height
                
                node.position({ x: cardCenterX, y: cardCenterY });
                currentX += cardWidth + spacing;
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in row`);
        }
        
        // Arrange copied cards in column at mouse position
        function arrangeCopiedCardsInColumn() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Now arrange them in a column (V-logic: 20% spacing = 60px)
            const spacing = 60; // 20% spacing as per spec
            let totalRequiredHeight = 0;
            newNodes.forEach((node, index) => {
                const cardHeight = getMeasuredTextHeight(node);
                totalRequiredHeight += cardHeight;
                if (index < newNodes.length - 1) {
                    totalRequiredHeight += spacing;
                }
            });
            
            let currentY = centerY - (totalRequiredHeight / 2);
            newNodes.forEach(node => {
                const cardHeight = getMeasuredTextHeight(node);
                const cardCenterY = currentY + (cardHeight / 2);
                node.position({ x: centerX, y: cardCenterY });
                currentY += cardHeight + spacing;
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in column`);
        }
        
        // Arrange copied cards in grid at mouse position
        function arrangeCopiedCardsInGrid() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Calculate grid dimensions
            const nodeCount = copiedCards.length;
            const cols = Math.ceil(Math.sqrt(nodeCount));
            const rows = Math.ceil(nodeCount / cols);
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in grid
            const cardWidth = 300;
            const cardHeight = 200;
            const horizontalSpacing = 350;
            const verticalSpacing = 250;
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const gridHeight = (rows - 1) * verticalSpacing;
            
            const startX = screenCenterX - (gridWidth / 2);
            const startY = screenCenterY - (gridHeight / 2);
            
            newNodes.forEach((node, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                const x = startX + (col * horizontalSpacing);
                const y = startY + (row * verticalSpacing);
                
                node.position({ x: x, y: y });
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`Created and arranged ${newNodes.length} copied cards in ${rows}×${cols} grid`);
        }
        
        // G+V: Copy cards in vertical columns layout
        function arrangeCopiedCardsGridVerticalColumns() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // G+V: Column-focused arrangement with max gap between bottom-edge to top-edge (same logic as original)
            const nodeCount = newNodes.length;
            const maxCols = 6; // Max 6 columns
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const cardsPerCol = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 350; // Gap between columns
            const maxVerticalGap = 80; // Max gap from bottom-edge of upper card to top-edge of lower card
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // Top-aligned columns - all start from same Y position (like G+H but vertical)
            const topLineY = screenCenterY; // All columns start from same top line
            
            // Arrange column by column (instead of row by row)
            for (let col = 0; col < cols; col++) {
                const colStartIndex = col * cardsPerCol;
                const colEndIndex = Math.min(colStartIndex + cardsPerCol, nodeCount);
                const cardsInThisCol = colEndIndex - colStartIndex;
                
                if (cardsInThisCol === 0) continue;
                
                const colX = startX + col * horizontalSpacing;
                
                // Start each column from the same top line
                let currentTopY = topLineY;
                
                // Place cards in this column with gap between bottom and top edges
                for (let cardIndex = 0; cardIndex < cardsInThisCol; cardIndex++) {
                    const nodeIndex = colStartIndex + cardIndex;
                    const node = newNodes[nodeIndex];
                    const cardHeight = getMeasuredTextHeight(node);
                    
                    // Card center is at currentTopY + half height
                    const cardCenterY = currentTopY + (cardHeight / 2);
                    
                    node.position({ x: colX, y: cardCenterY });
                    
                    // Move to next position: current card bottom + gap
                    currentTopY += cardHeight + maxVerticalGap;
                }
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+V: Created ${newNodes.length} copied cards in ${cols} top-aligned columns, 80px vertikalt, 350px horisontellt`);
        }
        
        // G+H: Copy cards in horizontal packed layout
        function arrangeCopiedCardsGridHorizontalPacked() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in horizontal packed rows (exact same logic as original)
            const nodeCount = newNodes.length;
            const maxCols = 6;
            const cols = Math.min(maxCols, Math.ceil(Math.sqrt(nodeCount)));
            const rows = Math.ceil(nodeCount / cols);
            
            const horizontalSpacing = 360; // 60px gap between cards (360 - 300 = 60)
            const rowPadding = 95; // Adjusted to get actual 60px visual spacing
            
            const gridWidth = (cols - 1) * horizontalSpacing;
            const startX = screenCenterX - gridWidth / 2;
            
            // First pass: calculate the height of each row
            const rowHeights = [];
            for (let row = 0; row < rows; row++) {
                let maxRowHeight = 0;
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        maxRowHeight = Math.max(maxRowHeight, cardHeight);
                    }
                }
                rowHeights.push(maxRowHeight);
            }
            
            // Calculate total height and start position
            const totalHeight = rowHeights.reduce((sum, height) => sum + height, 0) + (rows - 1) * rowPadding;
            let currentY = screenCenterY; // Top of grid at mouse cursor (same as move G+H)
            
            // Second pass: position cards row by row with tight packing
            for (let row = 0; row < rows; row++) {
                const rowHeight = rowHeights[row];
                
                for (let col = 0; col < cols; col++) {
                    const nodeIndex = row * cols + col;
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const newX = startX + col * horizontalSpacing;
                        
                        // Position card at top of its row space
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2); // Top-aligned within row
                        
                        node.position({ x: newX, y: cardCenterY });
                    }
                }
                
                currentY += rowHeight + rowPadding; // Move to next row
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+H: Created ${newNodes.length} copied cards in ${rows} packed rows`);
        }
        
        // Form dialog for structured card creation
        function showFormDialog(x, y) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create form dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 400px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">Skapa nytt kort</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Titel (valfritt):</label>
                    <input type="text" id="formTitle" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Text:</label>
                    <textarea id="formText" rows="4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Tags (kommaseparerade):</label>
                    <input type="text" id="formTags" placeholder="tech, ai, design" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Färg (valfritt):</label>
                    <div id="formColorPicker" style="display: flex; gap: 8px; align-items: center;">
                        <div class="form-color-dot" data-color="" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer; background: white; position: relative;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #999;">×</div>
                        </div>
                        <div class="form-color-dot card-color-1" data-color="card-color-1" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-2" data-color="card-color-2" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-3" data-color="card-color-3" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-4" data-color="card-color-4" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                        <div class="form-color-dot card-color-5" data-color="card-color-5" style="width: 24px; height: 24px; border: 2px solid #333; border-radius: 50%; cursor: pointer;"></div>
                    </div>
                </div>
                <div style="text-align: right;">
                    <button id="formCancel" style="margin-right: 10px; padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Avbryt</button>
                    <button id="formSave" style="padding: 8px 16px; border: none; background: #007AFF; color: white; border-radius: 4px; cursor: pointer;">Skapa kort</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus first field
            document.getElementById('formTitle').focus();
            
            // Event handlers
            document.getElementById('formCancel').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('formSave').onclick = () => {
                createCardFromForm(x, y, selectedColor);
                document.body.removeChild(overlay);
            };
            
            // Color picker event handlers
            let selectedColor = '';
            document.querySelectorAll('.form-color-dot').forEach(dot => {
                dot.onclick = () => {
                    // Remove selection from all dots
                    document.querySelectorAll('.form-color-dot').forEach(d => {
                        d.style.boxShadow = '';
                        d.style.transform = '';
                    });
                    // Select this dot
                    dot.style.boxShadow = '0 0 0 3px #007AFF';
                    dot.style.transform = 'scale(1.1)';
                    selectedColor = dot.dataset.color;
                };
            });
            
            // Store selected color on overlay for access in createCardFromForm
            overlay.selectedColor = () => selectedColor;
            
            // ESC to cancel - must capture on document for focus issues
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
        }
        
        // Create card from form data
        function createCardFromForm(x, y, selectedColor = '') {
            const title = document.getElementById('formTitle').value.trim();
            const text = document.getElementById('formText').value.trim();
            const tagsInput = document.getElementById('formTags').value.trim();
            
            if (!text) return; // Need at least some text
            
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            const newId = generateCardId();
            const nodeData = {
                id: newId,
                title: title,
                text: text,
                tags: tags,
                searchMatch: false
            };
            
            // Add color if selected
            if (selectedColor) {
                nodeData.cardColor = selectedColor;
            }
            
            const newNode = cy.add({
                data: nodeData,
                position: { x: x, y: y }
            });
            
            // Apply color styling if selected
            if (selectedColor) {
                newNode.style('background-color', getCardColorValue(selectedColor, getCurrentTheme()));
            }
            
            newNode.grabify();
            console.log(`Created card via form: ${title || 'Untitled'} ${selectedColor ? 'with color ' + selectedColor : ''}`);
            
            // Apply temporal markings to newly created card
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
        }
        
        // Code syntax dialog for quick card creation
        function showCodeDialog(x, y) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create code dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 500px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #333;">Snabbformat</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    #Titel<br>Innehåll här (Shift+Enter för ny rad)<br>#tag1 #tag2
                    <br><strong>Enter</strong>=Spara, <strong>Esc</strong>=Avbryt
                </p>
                <textarea id="codeInput" placeholder="#Titel här
Skriv ditt innehåll här...
#tag1 #tag2" 
                    style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
                           font-family: 'SF Mono', Consolas, monospace; font-size: 14px; resize: vertical;"></textarea>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            const textarea = document.getElementById('codeInput');
            textarea.focus();
            
            // Keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    createCardFromCode(x, y, textarea.value);
                    document.body.removeChild(overlay);
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Shift+Enter allows normal newline (no preventDefault)
            });
            
            // Click outside to cancel
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        // Parse code syntax and create card
        function createCardFromCode(x, y, input) {
            if (!input.trim()) return;
            
            const lines = input.trim().split('\n');
            let title = '';
            let text = '';
            let tags = [];
            
            let inContent = false;
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith('#') && !inContent) {
                    // First # line is title, rest are tags
                    if (!title) {
                        title = line.substring(1).trim();
                        inContent = true;
                    } else {
                        // Tags line - extract all #tag words
                        const tagMatches = line.match(/#\w+/g);
                        if (tagMatches) {
                            tags.push(...tagMatches.map(t => t.substring(1)));
                        }
                    }
                } else if (line.startsWith('#') && inContent) {
                    // Tags in content
                    const tagMatches = line.match(/#\w+/g);
                    if (tagMatches) {
                        tags.push(...tagMatches.map(t => t.substring(1)));
                    }
                } else {
                    // Content line
                    if (text) text += '\n';
                    text += line;
                    inContent = true;
                }
            }
            
            // If no title found, use first line of text
            if (!title && text) {
                const firstLine = text.split('\n')[0];
                if (firstLine.length < 50) {
                    title = firstLine;
                    text = text.substring(firstLine.length).trim();
                }
            }
            
            if (!text && !title) return; // Need something
            
            const newId = generateCardId();
            const newNode = cy.add({
                data: {
                    id: newId,
                    title: title,
                    text: text || title, // Use title as text if no content
                    tags: [...new Set(tags)], // Remove duplicates
                    searchMatch: false
                },
                position: { x: x, y: y }
            });
            
            newNode.grabify();
            console.log(`Created card via code syntax: ${title || 'Untitled'}`);
            
            // Apply temporal markings to newly created card
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
        }
        
        // G+T: Copy cards in top-aligned grid
        function arrangeCopiedCardsGridTopAligned() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const screenCenterX = arrangePos.x;
            const screenCenterY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                // Use createNodeFromCardData to preserve ALL data including images
                const newNode = createNodeFromCardData(cardData, newId, { x: screenCenterX, y: screenCenterY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in G+T layout (max 6 cols, 120px overlap, column-major ordering)
            const nodeCount = newNodes.length;
            const maxCols = 6; // Max 6 cards wide (same as original)
            const cols = Math.min(maxCols, nodeCount);
            const rows = Math.ceil(nodeCount / cols);
            
            const cardWidth = 300;
            const horizontalSpacing = cardWidth * 0.05; // 5% of card width = 15px
            const overlapSpacing = 120; // 120px between card tops (3x more to show titles)
            
            // Calculate grid size
            const gridWidth = (cols - 1) * (cardWidth + horizontalSpacing);
            const startX = screenCenterX - gridWidth / 2;
            
            // For top row alignment
            const topRowY = screenCenterY - 100; // Start a bit above center
            
            // Position cards column by column for proper overlapping (same as original)
            for (let col = 0; col < cols; col++) {
                const colX = startX + col * (cardWidth + horizontalSpacing);
                let currentY = topRowY;
                
                // Go through each row in this column
                for (let row = 0; row < rows; row++) {
                    const nodeIndex = row * cols + col; // Same ordering as original G+T
                    if (nodeIndex < newNodes.length) {
                        const node = newNodes[nodeIndex];
                        const cardHeight = getMeasuredTextHeight(node);
                        const cardCenterY = currentY + (cardHeight / 2);
                        
                        node.position({ x: colX, y: cardCenterY });
                        currentY += overlapSpacing; // Move down for next card in this column
                    }
                }
            }
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            console.log(`G+T: Created ${newNodes.length} copied cards in top-aligned ${rows}×${cols} grid`);
        }
        
        // Arrange copied cards in cluster at mouse position
        function arrangeCopiedCardsInCluster() {
            if (copiedCards.length === 0) return;
            
            const arrangePos = getArrangementPosition();
            const centerX = arrangePos.x;
            const centerY = arrangePos.y;
            
            // Create the copied cards with unique IDs
            const now = new Date();
            const baseId = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            
            const newNodes = [];
            copiedCards.forEach((cardData, index) => {
                const newId = `${baseId}-copy-${index + 1}`;
                
                const newNode = createNodeFromCardData(cardData, newId, { x: centerX, y: centerY });
                
                newNode.grabify();
                newNodes.push(newNode);
            });
            
            // Arrange in cluster (tight circle)
            const radius = 50; // Small cluster radius like original clusterSelectedCards
            
            newNodes.forEach((node, index) => {
                const angle = (index / newNodes.length) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                node.position({ x: x, y: y });
            });
            
            // Clear copied cards and select the new ones
            copiedCards = [];
            cy.nodes().unselect();
            newNodes.forEach(node => node.select());
            
            // Apply temporal markings to newly created cards
            setTimeout(() => {
                applyTemporalMarkings();
            }, 100);
            
            console.log(`Q: Created and clustered ${newNodes.length} copied cards`);
        }
        
        // Quick note dialog for Alt+N
        function showQuickNoteDialog() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Create quick note dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 500px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #333;">Snabb Anteckning</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    Första raden = Titel<br>
                    Resten = Innehåll (Shift+Enter för ny rad)<br>
                    #taggar hittas automatiskt överallt<br>
                    <strong>Enter</strong>=Spara, <strong>Esc</strong>=Avbryt
                </p>
                <textarea id="quickNoteInput" placeholder="Min titel här
Här skriver jag mitt innehåll...
Kan ha #taggar överallt.
#extra #taggar #här" 
                    style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; 
                           font-family: 'SF Mono', Consolas, monospace; font-size: 14px; resize: vertical;"></textarea>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            const textarea = document.getElementById('quickNoteInput');
            textarea.focus();
            
            // Keyboard shortcuts - same as code dialog
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    createCardFromQuickNote(textarea.value);
                    document.body.removeChild(overlay);
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(overlay);
                }
                // Shift+Enter allows normal newline
            });
            
            // Click outside to cancel
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
            
            // ESC handling for focus issues
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
        }
        
        // Parse quick note and create card
        function createCardFromQuickNote(input) {
            if (!input.trim()) return;
            
            const lines = input.trim().split('\n');
            if (lines.length === 0) return;
            
            // First line is always title
            const title = lines[0].trim();
            
            // Rest is content (skip first line)
            let contentLines = lines.slice(1);
            
            // Check if last line contains only tags (and has at least one #tag)
            let extraTags = [];
            if (contentLines.length > 0) {
                const lastLine = contentLines[contentLines.length - 1].trim();
                const hasOnlyTags = /^(#\w+\s*)+$/.test(lastLine); // Only #tags and whitespace
                
                if (hasOnlyTags && lastLine.includes('#')) {
                    // Extract tags from last line and remove it from content
                    const tagMatches = lastLine.match(/#\w+/g);
                    if (tagMatches) {
                        extraTags = tagMatches.map(t => t.substring(1));
                    }
                    contentLines = contentLines.slice(0, -1); // Remove last line from content
                }
            }
            
            // Join remaining content lines
            const text = contentLines.join('\n').trim();
            
            // Find all #tags in title and content
            let allTags = [...extraTags];
            const allText = (title + ' ' + text);
            const tagMatches = allText.match(/#\w+/g);
            if (tagMatches) {
                allTags.push(...tagMatches.map(t => t.substring(1)));
            }
            
            // Remove duplicates and filter out empty tags
            const uniqueTags = [...new Set(allTags)].filter(tag => tag.length > 0);
            
            // Use screen center as position (no mouse position for keyboard shortcut)
            const viewport = cy.extent();
            const centerX = (viewport.x1 + viewport.x2) / 2;
            const centerY = (viewport.y1 + viewport.y2) / 2;
            
            const newId = generateCardId();
            const newNode = cy.add({
                data: {
                    id: newId,
                    title: title,
                    text: text || title, // Use title as text if no content
                    tags: uniqueTags,
                    searchMatch: false
                },
                position: { x: centerX, y: centerY }
            });
            
            newNode.grabify();
            console.log(`Created quick note: "${title}" with ${uniqueTags.length} tags`);
        }
        
        // Edit card - unified for all card types (including images)
        function editCard(node) {
            // Clear any existing edit dialogs first
            clearAllEditDialogs();
            
            // Handle image nodes differently - use annotation field for text
            const isImageNode = node.data('type') === 'image';
            const currentText = isImageNode ? (node.data('annotation') || '') : (node.data('text') || '');
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing (unified UI without title)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Färg (valfritt):</label>
                    <div id="editCardColorPicker" style="display: flex; gap: 8px; align-items: center;">
                        <div class="color-dot" data-color="" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #f5f5f5; border: 2px solid #ddd; cursor: pointer; position: relative;"
                             title="Ingen färg">
                            <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                  font-size: 16px; color: #666;">⭘</span>
                        </div>
                        <div class="color-dot" data-color="1" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #d4f2d4; border: 2px solid transparent; cursor: pointer;" title="Grön"></div>
                        <div class="color-dot" data-color="2" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffe4b3; border: 2px solid transparent; cursor: pointer;" title="Orange"></div>
                        <div class="color-dot" data-color="3" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffc1cc; border: 2px solid transparent; cursor: pointer;" title="Röd"></div>
                        <div class="color-dot" data-color="4" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #fff7b3; border: 2px solid transparent; cursor: pointer;" title="Gul"></div>
                        <div class="color-dot" data-color="5" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #f3e5f5; border: 2px solid transparent; cursor: pointer;" title="Lila"></div>
                        <div class="color-dot" data-color="6" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #c7e7ff; border: 2px solid transparent; cursor: pointer;" title="Blå"></div>
                        <div class="color-dot" data-color="7" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #e0e0e0; border: 2px solid transparent; cursor: pointer;" title="Grå"></div>
                        <div class="color-dot" data-color="8" style="width: 24px; height: 24px; border-radius: 50%; 
                             background: #ffffff; border: 2px solid transparent; cursor: pointer;" title="Vit"></div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">📅 Snabbveckor:</label>
                    <div id="editWeekButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <!-- Week buttons will be populated by JavaScript -->
                    </div>
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara ändringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle color picker selection and show current color
            let selectedColor = '';
            const currentCardColor = node.data('cardColor') || '';
            const currentColorNumber = currentCardColor.replace('card-color-', '') || '';
            
            const colorDots = document.querySelectorAll('#editCardColorPicker .color-dot');
            colorDots.forEach(dot => {
                // Show current color as selected
                if (dot.dataset.color === currentColorNumber) {
                    dot.style.border = '2px solid #007acc';
                    selectedColor = currentColorNumber;
                } else if (!currentColorNumber && dot.dataset.color === '') {
                    dot.style.border = '2px solid #007acc';
                    selectedColor = '';
                }
                
                dot.addEventListener('click', function() {
                    // Remove selection from all dots
                    colorDots.forEach(d => d.style.border = d.dataset.color ? '2px solid transparent' : '2px solid #ddd');
                    
                    // Select this dot
                    this.style.border = '2px solid #007acc';
                    selectedColor = this.dataset.color;
                });
            });
            
            // Populate week buttons
            const weekData = getCurrentWeekData();
            const weekButtonsContainer = document.getElementById('editWeekButtons');
            const weekButtons = [
                { text: weekData.thisWeek, label: 'denna vecka', title: 'Denna vecka' },
                { text: weekData.nextWeek, label: 'nästa vecka', title: 'Nästa vecka' },
                { text: weekData.weekAfter, label: 'nästnästa vecka', title: 'Veckan efter nästa' }
            ];
            
            weekButtons.forEach(btn => {
                const weekBtn = document.createElement('button');
                weekBtn.type = 'button';
                weekBtn.innerHTML = `<strong>${btn.text}</strong><br><small>${btn.label}</small>`;
                weekBtn.title = btn.title;
                weekBtn.style.cssText = `
                    background: #f8f9fa;
                    border: 1px solid #dee2e6;
                    border-radius: 6px;
                    padding: 8px 12px;
                    cursor: pointer;
                    font-size: 12px;
                    line-height: 1.2;
                    transition: all 0.2s ease;
                    text-align: center;
                    min-width: 70px;
                `;
                
                weekBtn.addEventListener('mouseenter', function() {
                    this.style.background = '#e9ecef';
                    this.style.borderColor = '#007acc';
                });
                
                weekBtn.addEventListener('mouseleave', function() {
                    this.style.background = '#f8f9fa';
                    this.style.borderColor = '#dee2e6';
                });
                
                weekBtn.addEventListener('click', function() {
                    const tagsInput = document.getElementById('editCardTags');
                    const currentTags = tagsInput.value.trim();
                    const weekTag = btn.text;
                    
                    if (currentTags) {
                        // Add to existing tags
                        if (!currentTags.includes(weekTag)) {
                            tagsInput.value = currentTags + ', ' + weekTag;
                        }
                    } else {
                        // First tag
                        tagsInput.value = weekTag;
                    }
                    
                    // Visual feedback
                    this.style.background = '#d4edda';
                    this.style.borderColor = '#28a745';
                    setTimeout(() => {
                        this.style.background = '#f8f9fa';
                        this.style.borderColor = '#dee2e6';
                    }, 500);
                });
                
                weekButtonsContainer.appendChild(weekBtn);
            });
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newText = textarea.value.trim();
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Allow saving with just tags (no text required)
                if (!newText && newTags.length === 0) {
                    alert('Antingen text eller minst en tagg krävs');
                    return;
                }
                
                if (isImageNode) {
                    // For image nodes, save to annotation field and update searchable text
                    node.data('annotation', newText);
                    node.data('searchableText', newText.toLowerCase());
                    
                    // Update title to show annotation indicator
                    // Don't show filename in title, keep title empty for clean image display
                    node.data('title', '');
                } else {
                    // For regular nodes, save to text field
                    node.data('text', newText);
                }
                
                node.data('tags', newTags);
                
                // Apply selected color if any
                if (selectedColor) {
                    node.data('cardColor', `card-color-${selectedColor}`);
                } else if (selectedColor === '') {
                    // Remove color if "no color" was selected
                    node.data('cardColor', null);
                }
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);

                // Force refresh of node styling
                cy.style().update();

                refreshSearchAndFilter();

                // Save immediately to prevent data loss from autosave/Drive sync
                saveBoard();

                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    document.getElementById('saveEdit').click();
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // DEPRECATED - Edit manually created cards with textarea popup
        // Now using unified editCard() function instead
        function editManualCard_DEPRECATED(node) {
            const currentText = node.data('text') || '';
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara ändringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newText = textarea.value.trim();
                if (!newText) {
                    alert('Text krävs');
                    return;
                }
                
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Update node data
                node.data('text', newText);
                node.data('tags', newTags);
                
                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);
                
                // Re-run search if active
                const searchInput = document.getElementById('searchInput');
                if (searchInput.value.trim()) {
                    performSearch(searchInput.value);
                }

                // Re-run tag filter if active
                const tagFilterInput = document.getElementById('tagFilterInput');
                if (tagFilterInput.value.trim()) {
                    performTagFilter(tagFilterInput.value);
                }

                // Save immediately to prevent data loss from autosave/Drive sync
                saveBoard();

                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    document.getElementById('saveEdit').click();
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // DEPRECATED - Edit imported cards with old prompt system  
        // Now using unified editCard() function instead
        function editImportedCard_DEPRECATED(node) {
            const currentTitle = node.data('title') || '';
            const currentText = node.data('text') || '';
            const currentTags = node.data('tags') || [];
            
            // Create overlay for editing (same as addNewCard and editManualCard)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 500px; width: 90%; max-height: 80vh;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin-top: 0; color: #333; font-size: 18px;">Redigera kort</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Titel (valfritt):</label>
                    <input type="text" id="editCardTitle" value="${currentTitle}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px; margin-bottom: 10px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Text:</label>
                    <textarea id="editCardText" 
                        style="width: 100%; height: 200px; font-family: inherit; font-size: 14px; 
                               border: 1px solid #ccc; border-radius: 4px; padding: 8px;
                               box-sizing: border-box; resize: vertical;">${currentText}</textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #555;">Tags (valfritt):</label>
                    <input type="text" id="editCardTags" value="${currentTags.join(', ')}"
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
                               box-sizing: border-box; font-size: 14px;">
                </div>
                <div style="text-align: right;">
                    <button id="cancelEdit" style="background: #666; color: white; border: none; 
                                                 padding: 10px 20px; border-radius: 4px; margin-right: 10px;
                                                 cursor: pointer; font-size: 14px;">Avbryt</button>
                    <button id="saveEdit" style="background: #007acc; color: white; border: none; 
                                                padding: 10px 20px; border-radius: 4px; cursor: pointer;
                                                font-size: 14px;">Spara ändringar</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Tips:</strong> Enter = ny rad, Ctrl+Enter = spara, Esc = avbryt
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus on textarea and select all text
            const textarea = document.getElementById('editCardText');
            textarea.focus();
            textarea.select();
            
            // Handle save
            document.getElementById('saveEdit').onclick = function() {
                const newTitle = document.getElementById('editCardTitle').value.trim();
                const newText = textarea.value.trim();
                if (!newText) {
                    alert('Text krävs');
                    return;
                }
                
                const tagsInput = document.getElementById('editCardTags').value || '';
                const newTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Update node data
                node.data('title', newTitle);
                node.data('text', newText);
                node.data('tags', newTags);

                // Apply auto-gray coloring for #done tags
                applyAutoDoneColoring(node);

                refreshSearchAndFilter();

                // Save immediately to prevent data loss from autosave/Drive sync
                saveBoard();

                cleanup();
            };
            
            // Handle cancel
            document.getElementById('cancelEdit').onclick = function() {
                cleanup();
            };
            
            // Handle keyboard shortcuts with proper cleanup
            function cleanup() {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                document.removeEventListener('keydown', handleEscape);
                // Clear any existing edit dialogs to prevent conflicts
                const existingDialogs = document.querySelectorAll('[id^="editCard"], [id^="newCard"]');
                existingDialogs.forEach(dialog => {
                    if (dialog.parentNode && dialog.parentNode !== document.body) {
                        dialog.parentNode.remove();
                    }
                });
            }
            
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    cleanup();
                }
            }
            
            textarea.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    document.getElementById('saveEdit').click();
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            document.addEventListener('keydown', handleEscape);
        }
        
        // Helper function to refresh search and filter
        function refreshSearchAndFilter() {
            // Re-run search if active
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value.trim()) {
                performSearch(searchInput.value);
            }
            
            // Re-run tag filter if active
            const tagFilterInput = document.getElementById('tagFilterInput');
            if (tagFilterInput.value.trim()) {
                performTagFilter(tagFilterInput.value);
            }
        }
        
        // Global function to clean up any stray edit dialogs
        function clearAllEditDialogs() {
            // Remove overlays by style attributes
            const overlays = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10000"]');
            overlays.forEach(overlay => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            });
            
            // Remove any elements with edit-related IDs
            const editElements = document.querySelectorAll('#editCardText, #editCardTags, #editCardTitle, #newCardText, #newCardTags, #saveEdit, #cancelEdit, #saveCard, #cancelCard');
            editElements.forEach(element => {
                // Find the overlay parent (should be 2-3 levels up)
                let parent = element.parentNode;
                while (parent && parent !== document.body) {
                    if (parent.style.position === 'fixed' && parent.style.zIndex === '10000') {
                        if (parent.parentNode) {
                            parent.parentNode.removeChild(parent);
                        }
                        break;
                    }
                    parent = parent.parentNode;
                }
            });
            
            // Remove all event listeners by cloning and replacing document
            // This is a bit aggressive but ensures no zombie listeners
            console.log('Cleared all edit dialogs and potential zombie listeners');
        }
        
        // Google Drive API Configuration
        const GOOGLE_CLIENT_ID = '971005822021-8ebrpd92n1upsedg7s5fn80mnmvhou5d.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyBOti4mM-6x9WDnZIjIeyEU01T1-DQ-dY4'; // Public API key for Picker
        const GOOGLE_SCOPE = 'https://www.googleapis.com/auth/drive.file';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';

        let isGoogleApiLoaded = false;
        let isSignedIn = false;
        let pickerApiLoaded = false;
        let accessToken = null;
        let tokenClient = null;
        
        // Project management  
        let currentProject = localStorage.getItem('spatial-notes-project-name') || 'Nytt projekt';
        let availableProjects = [];
        let projectsLoaded = false;
        
        // Token management with enhanced persistence
        let tokenExpiry = null;
        let rememberMeEnabled = false;
        
        // Check user's remember preference
        function checkRememberPreference() {
            const remembered = localStorage.getItem('auth_remember_preference');
            return remembered === 'true';
        }
        
        // Save tokens with enhanced persistence options
        function saveTokens(forceRemember = false) {
            if (accessToken) {
                const storage = (rememberMeEnabled || forceRemember) ? localStorage : sessionStorage;
                const prefix = (rememberMeEnabled || forceRemember) ? 'google_' : 'session_google_';
                
                storage.setItem(prefix + 'access_token', accessToken);
                storage.setItem(prefix + 'token_expiry', tokenExpiry?.toString() || '');
                storage.setItem(prefix + 'current_project', currentProject);
                
                if (rememberMeEnabled || forceRemember) {
                    localStorage.setItem('auth_remember_preference', 'true');
                    console.log('Tokens saved to localStorage (30-day persistence)');
                } else {
                    localStorage.setItem('auth_remember_preference', 'false');
                    console.log('Tokens saved to sessionStorage (session only)');
                }
            }
        }
        
        // Load tokens from storage (localStorage or sessionStorage)
        function loadSavedTokens() {
            // Check user preference for remember me
            const rememberPreference = checkRememberPreference();
            
            // Try localStorage first (30-day persistence)
            let savedToken = localStorage.getItem('google_access_token');
            let savedExpiry = localStorage.getItem('google_token_expiry');
            let savedProject = localStorage.getItem('google_current_project');
            let source = 'localStorage (30-day)';
            
            // If no localStorage tokens, try sessionStorage
            if (!savedToken) {
                savedToken = sessionStorage.getItem('session_google_access_token');
                savedExpiry = sessionStorage.getItem('session_google_token_expiry');
                savedProject = sessionStorage.getItem('session_google_current_project');
                source = 'sessionStorage (session)';
            }
            
            if (savedToken && savedExpiry) {
                const expiryTime = parseInt(savedExpiry);
                const now = Date.now();
                
                // Check if token is still valid (with 5 minute buffer)
                if (expiryTime && now < (expiryTime - 5 * 60 * 1000)) {
                    accessToken = savedToken;
                    tokenExpiry = expiryTime;
                    isSignedIn = true;
                    rememberMeEnabled = rememberPreference;
                    
                    if (savedProject) {
                        currentProject = savedProject;
                    }
                    
                    console.log(`Restored valid tokens from ${source}`);
                    return true;
                } else {
                    console.log(`Saved tokens expired, clearing ${source}`);
                    clearSavedTokens();
                }
            }
            
            return false;
        }
        
        // Clear saved tokens from both storage types
        function clearSavedTokens() {
            // Clear localStorage tokens
            localStorage.removeItem('google_access_token');
            localStorage.removeItem('google_token_expiry');
            localStorage.removeItem('google_current_project');
            
            // Clear sessionStorage tokens
            sessionStorage.removeItem('session_google_access_token');
            sessionStorage.removeItem('session_google_token_expiry');
            sessionStorage.removeItem('session_google_current_project');
            
            // Reset auth state
            accessToken = null;
            tokenExpiry = null;
            isSignedIn = false;
            rememberMeEnabled = false;
            
            console.log('Cleared saved tokens from both storage types');
        }
        
        // Check if token needs refresh
        function isTokenExpiringSoon() {
            if (!tokenExpiry) return true;
            const now = Date.now();
            const timeToExpiry = tokenExpiry - now;
            // Refresh if less than 10 minutes left
            return timeToExpiry < (10 * 60 * 1000);
        }
        
        // Show remember me dialog before first login
        function showRememberMeDialog() {
            return new Promise((resolve) => {
                // Check if user has already made a choice
                const existingPreference = localStorage.getItem('auth_remember_preference');
                if (existingPreference !== null) {
                    rememberMeEnabled = existingPreference === 'true';
                    resolve(rememberMeEnabled);
                    return;
                }
                
                // Create remember me dialog
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.7); z-index: 10000;
                    display: flex; justify-content: center; align-items: center;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 30px; border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3); max-width: 400px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #007acc; text-align: center;">
                        🔐 Google Drive Inloggning
                    </h3>
                    <p style="margin: 0 0 20px 0; line-height: 1.5; color: #333;">
                        Vill du att vi ska komma ihåg din inloggning på den här enheten?
                    </p>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin: 0 0 10px 0; font-weight: bold; color: #007acc;">📱 Kom ihåg i 30 dagar:</p>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>Funkar på alla dina enheter (iPad, Android, dator)</li>
                            <li>Automatisk synkronisering</li>
                            <li>Mindre inloggningar</li>
                        </ul>
                        
                        <p style="margin: 15px 0 5px 0; font-weight: bold; color: #666;">🔒 Bara denna session:</p>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>Loggas ut när du stänger browsern</li>
                            <li>Mer säkert på delade enheter</li>
                        </ul>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="rememberYes" style="
                            padding: 12px 24px; background: #007acc; color: white; 
                            border: none; border-radius: 6px; cursor: pointer;
                            font-size: 16px; font-weight: bold;
                        ">🔓 Kom ihåg i 30 dagar</button>
                        <button id="rememberNo" style="
                            padding: 12px 24px; background: #666; color: white; 
                            border: none; border-radius: 6px; cursor: pointer;
                            font-size: 16px;
                        ">🔒 Bara denna session</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Handle button clicks
                dialog.querySelector('#rememberYes').onclick = () => {
                    rememberMeEnabled = true;
                    localStorage.setItem('auth_remember_preference', 'true');
                    document.body.removeChild(overlay);
                    resolve(true);
                };
                
                dialog.querySelector('#rememberNo').onclick = () => {
                    rememberMeEnabled = false;
                    localStorage.setItem('auth_remember_preference', 'false');
                    document.body.removeChild(overlay);
                    resolve(false);
                };
            });
        }
        
        // Refresh token if needed before API calls
        async function ensureValidToken() {
            if (!isSignedIn || !accessToken) {
                throw new Error('Not signed in to Google Drive');
            }
            
            if (isTokenExpiringSoon()) {
                console.log('Token expiring soon, requesting new token...');
                
                return new Promise((resolve, reject) => {
                    // Request new token
                    tokenClient.requestAccessToken({
                        prompt: '',
                        callback: (response) => {
                            if (response.access_token) {
                                accessToken = response.access_token;
                                tokenExpiry = Date.now() + (response.expires_in ? response.expires_in * 1000 : 3600000);
                                saveTokens();
                                console.log('Token refreshed successfully');
                                resolve();
                            } else {
                                console.error('Failed to refresh token:', response.error);
                                clearSavedTokens();
                                updateAuthStatus();
                                reject(new Error('Token refresh failed'));
                            }
                        }
                    });
                });
            }
            
            return Promise.resolve();
        }
        
        // ====================================================================================================
        // 📂 PROJECT SELECTOR FUNCTIONS
        // ====================================================================================================
        
        // Update project name in UI
        function updateProjectNameUI() {
            const projectNameElement = document.getElementById('projectName');
            if (projectNameElement) {
                projectNameElement.textContent = currentProject;
                localStorage.setItem('spatial-notes-project-name', currentProject);
            }
        }
        
        // Toggle project dropdown
        function toggleProjectDropdown() {
            const dropdown = document.getElementById('projectDropdown');
            if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeProjectDropdownOnClickOutside);
            } else {
                dropdown.classList.add('show');
                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeProjectDropdownOnClickOutside);
                }, 10);
            }
        }
        
        // Close dropdown when clicking outside
        function closeProjectDropdownOnClickOutside(event) {
            const dropdown = document.getElementById('projectDropdown');
            const button = document.getElementById('projectButton');

            if (!dropdown.contains(event.target) && !button.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeProjectDropdownOnClickOutside);
            }
        }

        // Close menu dropdowns
        function closeMenuDropdowns() {
            const menuDropdowns = document.querySelectorAll('.menu-dropdown');
            menuDropdowns.forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }

        // Rename current project
        function renameProject() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            const newName = prompt(`Byt namn på projekt "${currentProject}" till:`, currentProject);
            if (newName && newName.trim() && newName.trim() !== currentProject) {
                const oldName = currentProject;
                currentProject = newName.trim();
                updateProjectNameUI();
                
                // Show success message
                updateSyncStatus(`✏️ Projektnamn ändrat: "${oldName}" → "${currentProject}"`, 'success');
                
                // If signed in to Google Drive, this will be saved on next save
                if (isSignedIn && accessToken) {
                    // Automatically save to update the project name in Google Drive
                    setTimeout(() => saveBoard(), 500);
                }
            }
        }
        
        // Create new project
        function createNewProject() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            const projectName = prompt('Ange namn för det nya projektet:', '');
            if (projectName && projectName.trim()) {
                // Save current project if it has content
                const hasContent = cy.nodes().length > 0;
                if (hasContent && isSignedIn && accessToken) {
                    saveBoard(); // Save current project first
                }
                
                // Clear current board
                cy.nodes().remove();
                cy.edges().remove();
                
                // Set new project name
                currentProject = projectName.trim();
                updateProjectNameUI();
                
                updateSyncStatus(`➕ Nytt projekt skapat: "${currentProject}"`, 'success');
            }
        }
        
        // Show project list (simplified version)
        function showProjectList() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            if (!isSignedIn || !accessToken) {
                // Show local projects only
                alert('Logga in på Google Drive för att se alla sparade projekt.\n\nFör närvarande arbetar du lokalt med projekt: "' + currentProject + '"');
                return;
            }
            
            // Use existing project manager
            showProjectManager();
        }
        
        // Manage projects (same as existing function)
        function manageProjects() {
            const dropdown = document.getElementById('projectDropdown');
            dropdown.classList.remove('show');
            
            if (!isSignedIn || !accessToken) {
                alert('Logga in på Google Drive för att hantera projekt.\n\nFör närvarande arbetar du lokalt med projekt: "' + currentProject + '"');
                return;
            }
            
            showProjectManager();
        }
        
        // Initialize project name on page load
        function initializeProjectName() {
            updateProjectNameUI();
        }
        
        // ====================================================================================================
        // 💾 SMART SAVE SYSTEM - Enhanced save with Google Drive integration
        // ====================================================================================================
        
        // Smart save function - handles Google Drive integration
        async function smartSave() {
            try {
                // Always save to localStorage first (instant backup)
                saveBoard();
                updateSyncStatus('Sparad lokalt ✓', 'success');
                
                // Check if user is signed in to Google Drive
                if (isSignedIn && accessToken) {
                    // User is signed in - save to Google Drive with structured filename
                    await saveToGoogleDriveWithStructure();
                } else {
                    // User not signed in - offer to sign in
                    showGoogleDriveSignInPrompt();
                }
            } catch (error) {
                console.error('Smart save error:', error);
                updateSyncStatus('Sparning misslyckades', 'error');
            }
        }
        
        // Save to Google Drive with proper folder structure and naming
        async function saveToGoogleDriveWithStructure() {
            try {
                await ensureValidToken();
                
                // Create structured filename: projektnamn_YYYY-MM-DD_HH-MM.json
                const now = new Date();
                const dateStr = now.getFullYear() + '-' + 
                               String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(now.getDate()).padStart(2, '0');
                const timeStr = String(now.getHours()).padStart(2, '0') + '-' + 
                               String(now.getMinutes()).padStart(2, '0');
                
                // Clean project name for filename (remove invalid chars)
                const cleanProjectName = currentProject
                    .replace(/[<>:"/\\|?*]/g, '-')  // Replace invalid chars with dashes
                    .replace(/\s+/g, '_')           // Replace spaces with underscores
                    .substring(0, 50);              // Limit length
                
                const filename = `${cleanProjectName}_${dateStr}_${timeStr}.json`;
                
                updateSyncStatus(`Sparar till Google Drive: ${filename}`, 'loading');
                
                // Get board data
                const boardData = {
                    project_name: currentProject,
                    saved_date: now.toISOString(),
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        hidden_tags: node.data('hidden_tags') || [],
                        position: node.position(),
                        pinned: node.hasClass('pinned') || false,
                        isManualCard: node.data('isManualCard') || false,
                        cardColor: node.data('cardColor') || null,
                        // Image data
                        isImageCard: node.data('isImageCard') || false,
                        imageData: node.data('imageData') || null,
                        imageWidth: node.data('imageWidth') || null,
                        imageHeight: node.data('imageHeight') || null,
                        displayWidth: node.data('displayWidth') || null,
                        displayHeight: node.data('displayHeight') || null,
                        calculatedHeight: node.data('calculatedHeight') || null,
                        originalFileName: node.data('originalFileName') || null,
                        imageNotes: node.data('imageNotes') || '',
                        // Annotation data - CRITICAL for shapes/text annotations
                        isAnnotation: node.data('isAnnotation') || false,
                        annotationType: node.data('annotationType') || null,
                        shape: node.data('shape') || null,
                        textSize: node.data('textSize') || null,
                        label: node.data('label') || null,
                        customWidth: node.data('customWidth') || null,
                        customHeight: node.data('customHeight') || null,
                        backgroundColor: node.style('background-color'),
                        fontSize: node.style('font-size'),
                        width: node.style('width'),
                        height: node.style('height'),
                        // All other metadata
                        export_timestamp: node.data('export_timestamp') || null,
                        export_session: node.data('export_session') || null,
                        export_source: node.data('export_source') || null,
                        source_file: node.data('source_file') || null,
                        page_number: node.data('page_number') || null,
                        matched_terms: node.data('matched_terms') || null,
                        card_index: node.data('card_index') || null
                    })),
                    edges: cy.edges().map(edge => ({
                        source: edge.source().id(),
                        target: edge.target().id(),
                        // Save edge styling
                        lineColor: edge.style('line-color'),
                        targetArrowColor: edge.style('target-arrow-color'),
                        targetArrowShape: edge.style('target-arrow-shape'),
                        width: edge.style('width'),
                        arrowScale: edge.style('arrow-scale'),
                        curveStyle: edge.style('curve-style'),
                        // Save edge metadata
                        isAnnotation: edge.data('isAnnotation') || false,
                        annotationType: edge.data('annotationType') || null,
                        connectionType: edge.data('connectionType') || null
                    })),
                    metadata: {
                        total_cards: cy.nodes().length,
                        total_edges: cy.edges().length,
                        version: '2.1',
                        saved_from: 'spatial-notes-smart-save'
                    }
                };
                
                // Find or create 'Spatial Notes' folder
                const folderId = await findOrCreateSpatialNotesFolder();
                
                // Save file to the folder
                const fileBlob = new Blob([JSON.stringify(boardData, null, 2)], { type: 'application/json' });
                
                // Check if file already exists with same name (for versioning)
                const existingFiles = await findFilesInFolder(folderId, filename);
                
                let saveResponse;
                if (existingFiles.length > 0) {
                    // Update existing file
                    const fileId = existingFiles[0].id;
                    saveResponse = await updateFileInGoogleDrive(fileId, fileBlob);
                } else {
                    // Create new file
                    saveResponse = await createFileInGoogleDrive(filename, fileBlob, folderId);
                }
                
                if (saveResponse.ok) {
                    const fileInfo = await saveResponse.json();
                    updateSyncStatus(`✅ Sparad i Google Drive: "${filename}"`, 'success');
                    console.log(`Successfully saved project "${currentProject}" to Google Drive as ${filename}`);
                } else {
                    throw new Error('Failed to save to Google Drive: ' + saveResponse.statusText);
                }
                
            } catch (error) {
                console.error('Error saving to Google Drive with structure:', error);
                updateSyncStatus('Google Drive-sparning misslyckades', 'error');
                // Local save is still done, so user doesn't lose data
            }
        }
        
        // Show prompt to sign in to Google Drive
        function showGoogleDriveSignInPrompt() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10001;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 30px; border-radius: 10px; 
                box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px; width: 90%;
                text-align: center; font-family: inherit;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #333;">💾 Spara online?</h3>
                <p style="margin: 15px 0; color: #666; line-height: 1.5;">
                    Ditt projekt "<strong>${currentProject}</strong>" är sparat lokalt.<br><br>
                    Vill du logga in på Google Drive för att spara online och synka mellan dina enheter?
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button id="signInYes" style="
                        padding: 12px 20px; background: #007acc; color: white; 
                        border: none; border-radius: 6px; cursor: pointer; font-size: 16px;
                    ">🔗 Ja, logga in</button>
                    <button id="signInNo" style="
                        padding: 12px 20px; background: #666; color: white; 
                        border: none; border-radius: 6px; cursor: pointer; font-size: 16px;
                    ">📱 Nej, bara lokalt</button>
                </div>
                <p style="margin: 15px 0 5px 0; font-size: 12px; color: #999;">
                    Du kan alltid logga in senare via menyn.
                </p>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Handle buttons
            document.getElementById('signInYes').onclick = () => {
                document.body.removeChild(overlay);
                // Start Google sign-in process
                toggleGoogleDriveAuth();
            };
            
            document.getElementById('signInNo').onclick = () => {
                document.body.removeChild(overlay);
                updateSyncStatus('Sparad lokalt (endast denna enhet)', 'info');
            };
            
            // Close on Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Find or create 'Spatial Notes' folder in Google Drive
        async function findOrCreateSpatialNotesFolder() {
            try {
                // Search for existing 'Spatial Notes' folder
                const searchParams = new URLSearchParams({
                    q: "name='Spatial Notes' and mimeType='application/vnd.google-apps.folder'",
                    fields: 'files(id, name)'
                });
                
                const searchResponse = await fetch(`https://www.googleapis.com/drive/v3/files?${searchParams}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const searchResult = await searchResponse.json();
                
                if (searchResult.files && searchResult.files.length > 0) {
                    // Folder exists, return its ID
                    return searchResult.files[0].id;
                } else {
                    // Create new folder
                    const createResponse = await fetch('https://www.googleapis.com/drive/v3/files', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: 'Spatial Notes',
                            mimeType: 'application/vnd.google-apps.folder'
                        })
                    });
                    
                    const createResult = await createResponse.json();
                    console.log('Created Spatial Notes folder:', createResult.id);
                    return createResult.id;
                }
                
            } catch (error) {
                console.error('Error finding/creating Spatial Notes folder:', error);
                // Return null to save to root folder as fallback
                return null;
            }
        }
        
        // Find files in a specific folder
        async function findFilesInFolder(folderId, filename) {
            try {
                const query = folderId 
                    ? `name='${filename}' and '${folderId}' in parents`
                    : `name='${filename}'`;
                
                const searchParams = new URLSearchParams({
                    q: query,
                    fields: 'files(id, name, modifiedTime)'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${searchParams}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                return result.files || [];
                
            } catch (error) {
                console.error('Error finding files in folder:', error);
                return [];
            }
        }
        
        // Create file in Google Drive
        async function createFileInGoogleDrive(filename, fileBlob, parentFolderId = null) {
            const metadata = {
                name: filename
            };
            
            if (parentFolderId) {
                metadata.parents = [parentFolderId];
            }
            
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
            form.append('file', fileBlob);
            
            return fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                },
                body: form
            });
        }
        
        // Update existing file in Google Drive
        async function updateFileInGoogleDrive(fileId, fileBlob) {
            return fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: fileBlob
            });
        }
        
        // Initialize Google API
        async function initializeGoogleAPI() {
            try {
                // Wait for Google Identity Services to be available
                if (typeof google === 'undefined' || !google.accounts) {
                    console.log('Google Identity Services not yet loaded, retrying in 2 seconds...');
                    setTimeout(() => initializeGoogleAPI(), 2000);
                    return;
                }
                
                console.log('Initializing Google Identity Services...');
                
                // Try to load saved tokens first
                const hasValidTokens = loadSavedTokens();
                if (hasValidTokens) {
                    console.log('✅ Auto-signed in with saved tokens');
                    updateAuthStatus();
                    
                    // Load available projects and current project
                    setTimeout(async () => {
                        await loadAvailableProjects();
                        if (currentProject) {
                            await loadFromGoogleDrive();
                        }
                    }, 1000);
                }
                
                // Initialize Google Identity Services token client
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: GOOGLE_SCOPE,
                    callback: (response) => {
                        if (response.access_token) {
                            accessToken = response.access_token;
                            isSignedIn = true;
                            
                            // Calculate token expiry (Google tokens typically last 1 hour)
                            tokenExpiry = Date.now() + (response.expires_in ? response.expires_in * 1000 : 3600000);
                            
                            // Save tokens for persistence
                            saveTokens();
                            
                            console.log('Successfully signed in to Google Drive');
                            console.log('Token expires at:', new Date(tokenExpiry).toLocaleString());
                            updateAuthStatus();
                            
                            // Load available projects and then current project
                            setTimeout(async () => {
                                await loadAvailableProjects();
                                await loadFromGoogleDrive();
                            }, 500);
                        } else if (response.error) {
                            console.error('Authentication error:', response.error);
                            updateSyncStatus('Authentication failed', 'error');
                        }
                    },
                });
                
                isGoogleApiLoaded = true;
                console.log('Google Identity Services initialized successfully');

                // Load Google Picker API
                if (typeof gapi !== 'undefined') {
                    gapi.load('picker', {
                        'callback': function() {
                            pickerApiLoaded = true;
                            console.log('✅ Google Picker API loaded');
                        },
                        'onerror': function() {
                            console.error('❌ Failed to load Google Picker API');
                        }
                    });
                } else {
                    console.log('⏳ Waiting for gapi to load Picker...');
                    setTimeout(() => {
                        if (typeof gapi !== 'undefined') {
                            gapi.load('picker', () => {
                                pickerApiLoaded = true;
                                console.log('✅ Google Picker API loaded (delayed)');
                            });
                        }
                    }, 2000);
                }

                // Try to restore saved tokens
                if (loadSavedTokens()) {
                    console.log(`Restored session from saved tokens, project: ${currentProject}`);
                    updateAuthStatus();
                    
                    // Load projects and current project
                    setTimeout(async () => {
                        await loadAvailableProjects();
                        console.log(`Loading saved project: ${currentProject}`);
                        await loadFromGoogleDrive();
                    }, 500);
                } else {
                    updateAuthStatus();
                }
                
            } catch (error) {
                console.error('Error initializing Google Identity Services:', error);
                
                // Check if we're running locally
                if (window.location.protocol === 'file:') {
                    console.log('Google Drive sync requires HTTPS. Deploy to GitHub Pages to test.');
                    updateSyncStatus('Google Drive needs HTTPS', 'info');
                    
                    // Disable the Google Drive button for local development
                    const driveBtn = document.getElementById('googleDriveBtn');
                    if (driveBtn) {
                        driveBtn.disabled = true;
                        driveBtn.innerHTML = '<span>⚠️</span><span>Needs HTTPS</span>';
                    }
                } else {
                    console.log('Google Identity Services will retry in 5 seconds...');
                    updateSyncStatus('Google API loading...', 'info');
                    
                    // Retry initialization after 5 seconds
                    setTimeout(() => initializeGoogleAPI(), 5000);
                }
            }
        }
        
        // Update authentication status
        function updateAuthStatus() {
            if (!isGoogleApiLoaded) return;
            
            const driveBtn = document.getElementById('googleDriveBtn');
            const driveButtonText = document.getElementById('driveButtonText');
            
            // Check if elements exist before updating
            if (!driveBtn) {
                console.log('Google Drive button not found in DOM');
                return;
            }
            
            if (isSignedIn && accessToken) {
                if (driveButtonText) driveButtonText.textContent = `${currentProject}`;
                driveBtn.innerHTML = `✅ Google Drive (Inloggad)`;
                updateSyncStatus(`Synced: ${currentProject}`, 'success');
                
                // Start auto-sync
                startAutoSync();
            } else {
                if (driveButtonText) driveButtonText.textContent = 'Google Drive';
                driveBtn.innerHTML = `🔗 Google Drive (Ej inloggad)`;
                updateSyncStatus('', '');
                
                // Stop auto-sync when signed out
                stopAutoSync();
            }
        }
        
        // Toggle Google Drive authentication with Remember Me option
        async function toggleGoogleDriveAuth() {
            if (!isGoogleApiLoaded || !tokenClient) {
                updateSyncStatus('Google API not loaded yet...', 'loading');
                return;
            }
            
            try {
                if (isSignedIn && accessToken) {
                    // Sign out
                    if (confirm('Logga ut från Google Drive?\n\nDetta kommer att:\n• Stoppa automatisk synkronisering\n• Du behöver logga in igen för Drive-funktioner\n• Lokalt sparade kort påverkas inte')) {
                        google.accounts.oauth2.revoke(accessToken, () => {
                            console.log('Access token revoked');
                        });
                        
                        // Clear all tokens and saved data
                        clearSavedTokens();
                        
                        updateSyncStatus('Signed out from Google Drive', 'info');
                        updateAuthStatus();
                    }
                } else {
                    // Show remember me dialog first
                    updateSyncStatus('Förbereder inloggning...', 'loading');
                    
                    // Show remember me dialog and wait for user choice
                    const rememberChoice = await showRememberMeDialog();
                    console.log('User chose remember me:', rememberChoice);
                    
                    // Sign in - request access token  
                    updateSyncStatus('Signing in to Google Drive...', 'loading');
                    tokenClient.requestAccessToken({prompt: 'consent'});
                }
            } catch (error) {
                console.error('Authentication error:', error);
                updateSyncStatus('Authentication failed', 'error');
            }
        }
        
        // Project Management Functions
        
        // Load list of available projects from Google Drive
        async function loadAvailableProjects() {
            try {
                await ensureValidToken();
                const params = new URLSearchParams({
                    q: "name contains 'spatial-notes-' and name contains '.json' and trashed=false",
                    spaces: 'drive',
                    fields: 'files(id, name, modifiedTime)',
                    orderBy: 'modifiedTime desc'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${params}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to load projects:', response.statusText);
                    return [];
                }
                
                const result = await response.json();
                const projects = [];
                
                result.files.forEach(file => {
                    // Extract project name from filename: spatial-notes-PROJECT.json -> PROJECT
                    const match = file.name.match(/^spatial-notes-(.+)\.json$/);
                    if (match) {
                        projects.push({
                            name: match[1],
                            fileId: file.id,
                            lastModified: file.modifiedTime
                        });
                    }
                });
                
                availableProjects = projects;
                projectsLoaded = true;
                console.log('Loaded projects:', projects);
                return projects;
                
            } catch (error) {
                console.error('Error loading projects:', error);
                return [];
            }
        }
        
        // Switch to a different project
        async function switchProject(projectName) {
            if (projectName === currentProject) return;
            
            try {
                // Save current project first
                if (isSignedIn && accessToken) {
                    updateSyncStatus('Saving current project...', 'loading');
                    await saveToGoogleDrive();
                }
                
                // Switch to new project
                currentProject = projectName;
                
                // Save current project to localStorage immediately
                localStorage.setItem('google_current_project', currentProject);
                
                updateSyncStatus(`Switching to ${projectName}...`, 'loading');
                
                // Load the new project
                const success = await loadFromGoogleDrive();
                
                if (success) {
                    updateSyncStatus(`✅ Loaded ${projectName}`, 'success');
                } else {
                    // New project - start with empty board
                    cy.nodes().remove();
                    updateSyncStatus(`✅ New project: ${projectName}`, 'success');
                }
                
                // Update UI
                updateAuthStatus();
                
            } catch (error) {
                console.error('Error switching project:', error);
                updateSyncStatus('Failed to switch project', 'error');
            }
        }
        
        // Create a new project
        async function createNewProject(projectName) {
            if (!projectName || projectName.trim() === '') return;
            
            // Sanitize project name
            projectName = projectName.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
            
            // Check if project already exists
            const existingProject = availableProjects.find(p => p.name === projectName);
            if (existingProject) {
                alert(`Project "${projectName}" already exists!`);
                return;
            }
            
            // Switch to new project
            await switchProject(projectName);
        }
        
        // Get current project filename
        function getCurrentProjectFileName() {
            return `spatial-notes-${currentProject}.json`;
        }
        
        // Update node appearance after loading
        function updateNodeAppearance(node) {
            try {
                // Apply color if node has cardColor data
                const cardColor = node.data('cardColor');
                if (cardColor) {
                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                    node.style('background-color', colorValue);
                }
                
                // Apply pinned styling if needed
                const isPinned = node.data('isPinned');
                if (isPinned) {
                    node.addClass('pinned');
                    node.data('pinned', true);
                    node.ungrabify(); // Prevent dragging pinned cards
                } else {
                    node.grabify(); // Make sure non-pinned cards are draggable
                }
                
                // Update text content and height with delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        const heightInfo = getMeasuredTextHeight(node);
                        console.log(`Setting height for node ${node.id()}: ${heightInfo}px`);
                        node.style('height', heightInfo + 'px');
                    } catch (heightError) {
                        console.error('Error calculating height for node:', node.id(), heightError);
                        // Fallback to default height calculation with proper padding
                        const textLength = (node.data('text') || '').length;
                        const defaultHeight = Math.max(140, textLength * 0.8 + 60); // 140px minimum fallback
                        console.log(`Fallback height for ${node.id()}: ${defaultHeight}px`);
                        node.style('height', defaultHeight + 'px');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error updating node appearance:', error);
                // Continue without styling rather than failing
            }
        }
        
        // Update sync status display using the existing search results info area
        function updateSyncStatus(message, type = '') {
            const statusEl = document.querySelector('.search-results-info');
            
            if (!statusEl) {
                console.log('Status element not found');
                return;
            }
            
            // Show the status box and set message
            statusEl.textContent = message;
            statusEl.classList.add('visible');
            
            // Clear existing type classes
            statusEl.classList.remove('sync-success', 'sync-error', 'sync-loading', 'sync-info');
            
            // Add type-specific styling
            if (type) {
                statusEl.classList.add(`sync-${type}`);
            }
            
            // Auto-clear status after 5 seconds for non-permanent messages
            if (type === 'loading' || type === 'info') {
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-loading', 'sync-info');
                }, 5000);
            } else if (type === 'error') {
                // Keep error messages longer
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-error');
                }, 8000);
            } else if (type === 'success') {
                // Keep success messages for a medium time
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.classList.remove('visible', 'sync-success');
                }, 6000);
            }
        }
        
        // Save board to Google Drive
        async function saveToGoogleDrive() {
            try {
                // Ensure we have a valid token
                await ensureValidToken();
                
                console.log(`Saving project "${currentProject}" to Google Drive...`);
                updateSyncStatus('Saving to Google Drive...', 'loading');
                
                const cardCount = cy.nodes().length;
                console.log(`Preparing to save ${cardCount} cards`);
                
                const boardData = {
                    cards: cy.nodes().map(node => ({
                        id: node.id(),
                        title: node.data('title') || '',
                        text: node.data('text') || '',
                        tags: node.data('tags') || [],
                        hidden_tags: node.data('hidden_tags') || [],
                        x: node.position('x'),
                        y: node.position('y'),
                        cardColor: node.data('cardColor') || '',
                        export_source: node.data('export_source') || '',
                        source_file: node.data('source_file') || '',
                        matched_terms: node.data('matched_terms') || '',
                        isManualCard: node.data('isManualCard') || false,
                        isPinned: node.data('isPinned') || false,
                        pinned: node.hasClass('pinned') || false,
                        // Image data - CRITICAL for image persistence
                        type: node.data('type') || 'text',
                        isImageCard: node.data('isImageCard') || false,
                        imageData: node.data('imageData') || null,
                        imageWidth: node.data('imageWidth') || null,
                        imageHeight: node.data('imageHeight') || null,
                        displayWidth: node.data('displayWidth') || null,
                        displayHeight: node.data('displayHeight') || null,
                        calculatedHeight: node.data('calculatedHeight') || null,
                        originalFileName: node.data('originalFileName') || null,
                        imageNotes: node.data('imageNotes') || '',
                        annotation: node.data('annotation') || null,
                        searchableText: node.data('searchableText') || null,
                        // Annotation data - CRITICAL for shapes/text annotations
                        isAnnotation: node.data('isAnnotation') || false,
                        annotationType: node.data('annotationType') || null,
                        shape: node.data('shape') || null,
                        textSize: node.data('textSize') || null,
                        label: node.data('label') || null,
                        customWidth: node.data('customWidth') || null,
                        customHeight: node.data('customHeight') || null,
                        backgroundColor: node.style('background-color'),
                        fontSize: node.style('font-size'),
                        width: node.style('width'),
                        height: node.style('height'),
                        // Other metadata
                        export_timestamp: node.data('export_timestamp') || null,
                        export_session: node.data('export_session') || null,
                        page_number: node.data('page_number') || null,
                        card_index: node.data('card_index') || null
                    })),
                    edges: cy.edges().map(edge => ({
                        source: edge.source().id(),
                        target: edge.target().id(),
                        // Save edge styling
                        lineColor: edge.style('line-color'),
                        targetArrowColor: edge.style('target-arrow-color'),
                        targetArrowShape: edge.style('target-arrow-shape'),
                        width: edge.style('width'),
                        arrowScale: edge.style('arrow-scale'),
                        curveStyle: edge.style('curve-style'),
                        // Save edge metadata
                        isAnnotation: edge.data('isAnnotation') || false,
                        annotationType: edge.data('annotationType') || null,
                        connectionType: edge.data('connectionType') || null
                    })),
                    timestamp: new Date().toISOString(),
                    version: '2.0'
                };
                
                const fileContent = JSON.stringify(boardData, null, 2);
                const fileName = getCurrentProjectFileName();
                
                console.log(`File to save: ${fileName}`);
                console.log(`Content length: ${fileContent.length} characters`);
                console.log(`Board data:`, boardData);
                
                // Check if file already exists
                console.log('Checking if file exists...');
                const existingFileId = await findSpatialNotesFile();
                console.log('Existing file ID:', existingFileId);
                
                if (existingFileId) {
                    // Update existing file
                    const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFileId}?uploadType=media`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: fileContent
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to update file: ${response.statusText}`);
                    }
                } else {
                    // Create new file (simple approach)
                    const metadata = {
                        name: fileName
                    };
                    
                    // First create the file metadata
                    const createResponse = await fetch('https://www.googleapis.com/drive/v3/files', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(metadata)
                    });
                    
                    if (!createResponse.ok) {
                        throw new Error(`Failed to create file: ${createResponse.statusText}`);
                    }
                    
                    const fileInfo = await createResponse.json();
                    
                    // Then upload the content
                    const uploadResponse = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileInfo.id}?uploadType=media`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: fileContent
                    });
                    
                    if (!uploadResponse.ok) {
                        throw new Error(`Failed to upload content: ${uploadResponse.statusText}`);
                    }
                }
                
                updateSyncStatus('✅ Saved to Drive', 'success');
                return true;
            } catch (error) {
                console.error('Error saving to Google Drive:', error);
                
                // If error is auth-related, clear tokens and update UI
                if (error.message.includes('Not signed in') || error.message.includes('Token refresh failed')) {
                    clearSavedTokens();
                    updateAuthStatus();
                    updateSyncStatus('Please sign in to Google Drive', 'error');
                } else {
                    updateSyncStatus('Failed to save to Drive', 'error');
                }
                return false;
            }
        }
        
        // Load board from Google Drive
        async function loadFromGoogleDrive() {
            try {
                // Ensure we have a valid token
                await ensureValidToken();
                
                console.log(`Loading project "${currentProject}" from Google Drive...`);
                updateSyncStatus('Loading from Google Drive...', 'loading');
                
                const fileId = await findSpatialNotesFile();
                console.log('File search result:', fileId);
                
                if (!fileId) {
                    console.log(`No file found for project "${currentProject}"`);
                    updateSyncStatus(`No saved data for "${currentProject}"`, 'info');
                    return false;
                }
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                console.log('Drive API response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Drive API error:', errorText);
                    throw new Error(`Failed to load file: ${response.status} ${response.statusText}`);
                }
                
                const fileContent = await response.text();
                console.log('File content length:', fileContent.length);
                console.log('File content preview:', fileContent.substring(0, 200));
                
                const boardData = JSON.parse(fileContent);
                console.log('Parsed board data:', boardData);
                
                // Check if we already have cards loaded (from localStorage)
                const existingCards = cy.nodes().length;
                console.log(`Found ${existingCards} existing cards before Drive sync`);
                
                // Clear existing cards silently without visual updates during sync
                cy.batch(() => {
                    cy.nodes().remove();
                });
                
                // Add cards from Drive in a batch to minimize visual updates
                if (boardData.cards && boardData.cards.length > 0) {
                    console.log(`Loading ${boardData.cards.length} cards...`);
                    
                    // Batch all card additions to prevent visual jumping
                    cy.batch(() => {
                        boardData.cards.forEach((card, index) => {
                            console.log(`Adding card ${index + 1}:`, card.id, card.title?.substring(0, 30));
                            
                            const nodeData = {
                                id: card.id,
                                title: card.title || '',
                                text: card.text || '',
                                tags: card.tags || [],
                                hidden_tags: card.hidden_tags || [],
                                cardColor: card.cardColor || '',
                                export_source: card.export_source || '',
                                source_file: card.source_file || '',
                                matched_terms: card.matched_terms || '',
                                isManualCard: card.isManualCard || false,
                                isPinned: card.isPinned || false,
                                // IMAGE SUPPORT - Essential for preserving pasted images!
                                type: card.type || 'text',
                                isImageCard: card.isImageCard || false,
                                imageData: card.imageData || null,
                                imageWidth: card.imageWidth || null,
                                imageHeight: card.imageHeight || null,
                                calculatedHeight: card.calculatedHeight || null,
                                annotation: card.annotation || null,
                                searchableText: card.searchableText || null,
                                originalFileName: card.originalFileName || null,
                                imageNotes: card.imageNotes || '',
                                // ANNOTATION SUPPORT - Essential for preserving shapes/text annotations
                                isAnnotation: card.isAnnotation || false,
                                annotationType: card.annotationType || null,
                                shape: card.shape || null,
                                textSize: card.textSize || null,
                                label: card.label || null,
                                customWidth: card.customWidth || null,
                                customHeight: card.customHeight || null,
                                // Other metadata
                                export_timestamp: card.export_timestamp || null,
                                export_session: card.export_session || null,
                                page_number: card.page_number || null,
                                card_index: card.card_index || null
                            };
                            
                            const node = cy.add({
                                data: nodeData,
                                position: { x: card.x || 0, y: card.y || 0 }
                            });
                            
                            // Apply auto-gray coloring for #done tags
                            applyAutoDoneColoring(node);

                            // Apply image styling if this is an image node
                            if ((card.type === 'image' || card.isImageCard) && card.imageData) {
                                console.log('🖼️ Restoring image from Drive:', card.originalFileName || 'unknown');

                                // Use saved display width, or default to 300px
                                const displayWidth = card.displayWidth || 300;
                                const ratio = card.imageHeight / card.imageWidth;
                                const displayHeight = Math.round(displayWidth * ratio);

                                node.style({
                                    'background-image': card.imageData,
                                    'background-fit': 'cover',
                                    'background-position': 'center',
                                    'width': displayWidth + 'px',
                                    'height': displayHeight + 'px'
                                });

                                // Store display dimensions in data for future saves
                                node.data('displayWidth', displayWidth);
                                node.data('displayHeight', displayHeight);
                            }

                            // Restore annotation styling if this is an annotation
                            if (card.isAnnotation && card.annotationType === 'shape') {
                                console.log('🔷 Restoring shape annotation:', card.id, card.shape);
                                node.addClass('annotation-shape');

                                // Restore shape data
                                if (card.shape) node.data('shape', card.shape);
                                if (card.label) node.data('label', card.label);
                                if (card.customWidth) node.data('customWidth', card.customWidth);
                                if (card.customHeight) node.data('customHeight', card.customHeight);

                                // Restore ALL styling in one call (like edges)
                                node.style({
                                    'background-color': card.backgroundColor || '#ff0000',
                                    'width': card.width || '200px',
                                    'height': card.height || '200px'
                                });
                                console.log(`  Restored shape: color=${card.backgroundColor}, size=${card.width}x${card.height}`);
                            } else if (card.isAnnotation && card.annotationType === 'text') {
                                console.log('📝 Restoring text annotation:', card.id);
                                node.addClass('annotation-text');

                                // Restore text annotation data
                                if (card.textSize) node.data('textSize', card.textSize);
                                if (card.label) node.data('label', card.label);
                                if (card.customWidth) node.data('customWidth', card.customWidth);
                                if (card.customHeight) node.data('customHeight', card.customHeight);

                                // Restore ALL styling in one call (like edges)
                                node.style({
                                    'background-color': card.backgroundColor || '#ff0000',
                                    'font-size': card.fontSize || '32px',
                                    'width': card.width || '200px',
                                    'height': card.height || '100px'
                                });
                                console.log(`  Restored text: color=${card.backgroundColor}, size=${card.width}x${card.height}`);
                            } else {
                                // Only apply cardColor styling for NON-annotations
                                const cardColor = node.data('cardColor');
                                if (cardColor) {
                                    const colorValue = getCardColorValue(cardColor, getCurrentTheme());
                                    node.style('background-color', colorValue);
                                }
                            }

                            // Handle both isPinned and pinned (for backwards compatibility)
                            if (node.data('isPinned') || card.pinned) {
                                node.addClass('pinned');
                                node.data('pinned', true);
                                node.ungrabify(); // Prevent dragging pinned cards
                            } else {
                                node.grabify(); // Make sure non-pinned cards are draggable
                            }
                        });

                        // Load edges (connections between nodes)
                        if (boardData.edges && boardData.edges.length > 0) {
                            console.log(`Loading ${boardData.edges.length} edges...`);
                            boardData.edges.forEach(edgeData => {
                                const newEdge = cy.add({
                                    group: 'edges',
                                    data: {
                                        source: edgeData.source,
                                        target: edgeData.target,
                                        isAnnotation: edgeData.isAnnotation || false,
                                        annotationType: edgeData.annotationType || null,
                                        connectionType: edgeData.connectionType || null
                                    }
                                });

                                // Restore edge styling if available
                                if (edgeData.lineColor || edgeData.targetArrowColor) {
                                    newEdge.style({
                                        'line-color': edgeData.lineColor || '#999',
                                        'target-arrow-color': edgeData.targetArrowColor || '#999',
                                        'target-arrow-shape': edgeData.targetArrowShape || 'triangle',
                                        'width': edgeData.width || 5,
                                        'arrow-scale': edgeData.arrowScale || 1.8,
                                        'curve-style': edgeData.curveStyle || 'bezier'
                                    });
                                    console.log(`🎨 Restored edge styling: ${edgeData.lineColor}`);
                                }
                            });
                            console.log('✅ All edges loaded with styling');
                        }
                    });

                    console.log('All cards and edges loaded successfully');
                    updateSyncStatus(`✅ Loaded ${boardData.cards.length} cards from "${currentProject}"`, 'success');
                    
                    // Skip height updates if cards were already loaded from localStorage 
                    // to prevent visual jumping during Drive sync
                    if (existingCards === 0) {
                        // Only update heights for first load (no localStorage data)
                        console.log('First load - applying height calculations');
                        setTimeout(() => {
                            cy.batch(() => {
                                cy.nodes().forEach(node => {
                                    try {
                                        const heightInfo = getMeasuredTextHeight(node);
                                        node.style('height', heightInfo + 'px');
                                    } catch (error) {
                                        const textLength = (node.data('text') || '').length;
                                        const fallbackHeight = Math.max(140, textLength * 0.8 + 60);
                                        node.style('height', fallbackHeight + 'px');
                                    }
                                });
                            });
                            console.log(`Height calculations applied to ${cy.nodes().length} cards`);
                        }, 150);
                    } else {
                        console.log('Skipped height updates - cards already properly sized from localStorage');
                    }
                    
                    // Auto-save to localStorage as backup
                    setTimeout(() => saveBoard(), 500);
                    
                    return true;
                } else {
                    console.log('No cards found in board data');
                    updateSyncStatus(`Empty project: "${currentProject}"`, 'info');
                    return false;
                }
            } catch (error) {
                console.error('Error loading from Google Drive:', error);
                
                // If error is auth-related, clear tokens and update UI
                if (error.message.includes('Not signed in') || error.message.includes('Token refresh failed')) {
                    clearSavedTokens();
                    updateAuthStatus();
                    updateSyncStatus('Please sign in to Google Drive', 'error');
                } else {
                    updateSyncStatus('Failed to load from Drive', 'error');
                }
                return false;
            }
        }
        
        // Find existing spatial notes file in Google Drive
        async function findSpatialNotesFile() {
            try {
                const fileName = getCurrentProjectFileName();
                const params = new URLSearchParams({
                    q: `name='${fileName}' and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)'
                });
                
                const response = await fetch(`https://www.googleapis.com/drive/v3/files?${params}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to search files: ${response.statusText}`);
                }
                
                const result = await response.json();
                const files = result.files;
                return files && files.length > 0 ? files[0].id : null;
            } catch (error) {
                console.error('Error searching for spatial notes file:', error);
                return null;
            }
        }
        
        // Show project manager modal
        async function showProjectManager() {
            if (!isSignedIn || !accessToken) {
                alert('Please sign in to Google Drive first!');
                return;
            }
            
            // Load latest projects
            await loadAvailableProjects();
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="closeProjectManager(event)">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation();">
                        <h2 style="margin-top: 0; text-align: center;">📁 Project Manager</h2>
                        
                        <div style="margin-bottom: 20px;">
                            <strong>Current Project:</strong> <span style="color: #007acc;">${currentProject}</span>
                        </div>
                        
                        <h3>Available Projects:</h3>
                        <div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
            `;
            
            if (availableProjects.length === 0) {
                html += '<p style="text-align: center; color: #666;">No projects found. Create your first project below!</p>';
            } else {
                availableProjects.forEach(project => {
                    const isCurrentProject = project.name === currentProject;
                    const lastModified = new Date(project.lastModified);
                    const date = lastModified.toLocaleDateString('sv-SE'); // YYYY-MM-DD format
                    const time = lastModified.toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }); // HH:MM format
                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; ${isCurrentProject ? 'background: #f0f8ff;' : ''}">
                            <div>
                                <strong>${project.name}</strong> ${isCurrentProject ? '(current)' : ''}
                                <br><small style="color: #666;">Sparad: ${date} kl. ${time}</small>
                            </div>
                            <div>
                                ${!isCurrentProject ? `<button onclick="switchToProject('${project.name}')" style="margin-right: 5px; padding: 4px 8px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer;">Switch</button>` : ''}
                                <button onclick="deleteProject('${project.name}')" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    `;
                });
            }
            
            html += `
                        </div>
                        
                        <h3 style="margin-top: 25px;">Create New Project:</h3>
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <input type="text" id="newProjectName" placeholder="Project name..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <button onclick="createProject()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create</button>
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button onclick="closeProjectManager()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            const modal = document.createElement('div');
            modal.id = 'projectManagerModal';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        // Close project manager modal
        function closeProjectManager(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('projectManagerModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        // Switch to project from modal
        async function switchToProject(projectName) {
            closeProjectManager();
            await switchProject(projectName);
        }
        
        // Create project from modal
        async function createProject() {
            const input = document.getElementById('newProjectName');
            const projectName = input.value.trim();
            
            if (!projectName) {
                alert('Please enter a project name!');
                return;
            }
            
            closeProjectManager();
            await createNewProject(projectName);
        }
        
        // Delete project
        async function deleteProject(projectName) {
            if (projectName === currentProject) {
                alert('Cannot delete the current project! Switch to another project first.');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete project "${projectName}"? This cannot be undone!`)) {
                return;
            }
            
            try {
                // Find and delete the project file
                const project = availableProjects.find(p => p.name === projectName);
                if (project) {
                    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${project.fileId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });
                    
                    if (response.ok) {
                        // Refresh project list and modal
                        await loadAvailableProjects();
                        closeProjectManager();
                        setTimeout(() => showProjectManager(), 100);
                        updateSyncStatus(`Deleted project: ${projectName}`, 'info');
                    } else {
                        alert('Failed to delete project: ' + response.statusText);
                    }
                }
            } catch (error) {
                console.error('Error deleting project:', error);
                alert('Error deleting project: ' + error.message);
            }
        }
        
        // Auto-sync functionality
        let autoSyncInterval;
        function startAutoSync() {
            if (!isSignedIn || !accessToken) return;
            
            // Auto-save to Drive every 20 minutes when signed in
            autoSyncInterval = setInterval(async () => {
                if (isSignedIn && accessToken) {
                    await saveToGoogleDrive();
                }
            }, 20 * 60 * 1000);
        }
        
        function stopAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
                autoSyncInterval = null;
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initCytoscape();
            loadSavedTheme(); // Load theme before anything else
            
            // Check for potential conflicts on startup
            checkStartupConflicts();
            
            // Start autosave system
            startAutosave();
            
            // Add change tracking to Cytoscape events
            cy.on('add remove position', function(evt) {
                markChanged();
            });
            
            // Also track manual edits through existing edit functions
            // (editCard, editCodeCard, etc. already call saveBoard which resets hasChanges)
            
            // Load current project from localStorage even without Google login
            const savedProject = localStorage.getItem('google_current_project');
            if (savedProject) {
                currentProject = savedProject;
                console.log(`Restored current project: ${currentProject}`);
            }
            
            // Initialize Google Drive API (wait for gapi to load)
            setTimeout(() => initializeGoogleAPI(), 3000);
            
            // Initialize project name UI
            initializeProjectName();
            
            // Initialize simplified toolbar state
            updateToolbarDisplay();

            // ➕ button long-press functionality for iPad clipboard paste
            const newCardBtn = document.querySelector('.new-card-btn');
            if (newCardBtn) {
                let longPressTimer = null;
                let isLongPress = false;

                newCardBtn.addEventListener('touchstart', function(e) {
                    isLongPress = false;
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        // Long press detected - show image source menu
                        // This works better on iPad than clipboard API (which has strict permission requirements)
                        const touch = e.touches[0];
                        if (touch) {
                            showImageSourceMenu(touch.clientX, touch.clientY);
                        }
                    }, 800); // 800ms for long press
                });

                newCardBtn.addEventListener('touchend', function(e) {
                    clearTimeout(longPressTimer);
                    if (isLongPress) {
                        e.preventDefault(); // Prevent normal click if it was a long press
                    }
                });

                newCardBtn.addEventListener('touchcancel', function(e) {
                    clearTimeout(longPressTimer);
                });
            }

            // Enhanced save function that includes Drive sync (after original function is defined)
            setTimeout(() => {
                const originalSaveBoard = window.saveBoard;
                window.saveBoard = function() {
                    // Always save to localStorage first
                    if (originalSaveBoard) {
                        originalSaveBoard();
                    }
                    
                    // Update column view if active (for markdown and other changes)
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                    
                    // Also save to Drive if signed in
                    if (isSignedIn && accessToken) {
                        saveToGoogleDrive();
                    }
                }
            }, 100);
            
            // Auto-load from localStorage if data exists (silent load)
            setTimeout(() => {
                const savedData = localStorage.getItem('spatial-notes-board');
                if (savedData) {
                    try {
                        const boardData = JSON.parse(savedData);
                        if (boardData.cards && boardData.cards.length > 0) {
                            console.log(`Auto-loading ${boardData.cards.length} cards from localStorage...`);
                            
                            // Clear any existing content first
                            cy.nodes().remove();
                            cy.edges().remove();
                            
                            // Use the full loadBoard functionality but suppress alerts
                            const originalAlert = window.alert;
                            window.alert = () => {}; // Temporarily disable alerts
                            
                            // Manually trigger the full load process
                            loadBoardFromData(boardData);
                            
                            // Restore alert function
                            window.alert = originalAlert;
                            
                            console.log(`✅ Auto-loaded ${boardData.cards.length} cards and ${(boardData.edges || []).length} edges from localStorage`);
                            
                            // Apply temporal markings after loading
                            setTimeout(() => {
                                applyTemporalMarkings();
                            }, 500);
                        }
                    } catch (e) {
                        console.log('Error auto-loading:', e);
                    }
                }
            }, 100);
            
            const searchInput = document.getElementById('searchInput');
            let searchTimeout;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    performSearch(this.value);
                }, 300);
            });
            
            // Make status info clickable to close (especially useful on mobile)
            const searchInfo = document.getElementById('searchInfo');
            searchInfo.addEventListener('click', function() {
                this.classList.remove('visible');
            });
            
            // Clear search when input is empty
            searchInput.addEventListener('keyup', function() {
                if (!this.value.trim()) {
                    clearSearch();
                }
            });
            
            // Handle Enter key to convert search matches to selected cards
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const searchMatches = cy.$('.search-match');
                    console.log('Enter in search box, found matches by class:', searchMatches.length);
                    if (searchMatches.length > 0) {
                        // Convert search matches to selected cards
                        searchMatches.select();
                        console.log('Selected search matches, now clearing search visual');
                        
                        // Clear search visuals but keep cards selected
                        searchActive = false;
                        cy.nodes().removeClass('search-match');
                        cy.nodes().removeClass('search-non-match'); // Remove blur
                        cy.nodes().data('searchMatch', false);
                        // Don't unselect cards like clearSearch() does
                        
                        const searchInfo = document.getElementById('searchInfo');
                        searchInfo.classList.remove('visible');
                        
                        // Blur the search input so keyboard shortcuts work
                        this.blur();
                        e.preventDefault();
                    }
                }
            });
            
            // Tag filter functionality
            const tagFilterInput = document.getElementById('tagFilterInput');
            let tagFilterTimeout;
            
            tagFilterInput.addEventListener('input', function() {
                clearTimeout(tagFilterTimeout);
                tagFilterTimeout = setTimeout(() => {
                    performTagFilter(this.value);
                }, 300);
            });
            
            tagFilterInput.addEventListener('keyup', function() {
                if (!this.value.trim()) {
                    clearTagFilter();
                }
            });
            
            // Handle Enter key to convert tag filter matches to selected cards
            tagFilterInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    // For tag filtering, matches are nodes WITHOUT .tag-filtered class
                    const tagMatches = cy.nodes().not('.tag-filtered');
                    console.log('Enter in tag filter box, found tag matches:', tagMatches.length);
                    if (tagMatches.length > 0) {
                        // Convert tag filter matches to selected cards
                        tagMatches.select();
                        console.log('Selected tag filter matches, now clearing tag filter visual');
                        
                        // Clear tag filter visuals but keep cards selected
                        clearTagFilter();
                        
                        // Remove focus from input so keyboard shortcuts work
                        this.blur();
                        
                        e.preventDefault();
                    }
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // ESC: Show all cards (reset AI filter)
                if (e.key === 'Escape' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !e.target.isContentEditable) {
                    e.preventDefault();
                    showAllCards();
                    return;
                }

                // Skip keyboard shortcuts if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                    return;
                }

                // Enkla kortkommandon (bara om inte i input-fält)

                // N för ny anteckning (vår nya textarea-version)
                if (e.key === 'n' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    addNewCard();
                }
                
                // C för kopiera markerade kort
                if (e.key === 'c' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    copySelectedCards();
                }
                
                // (Delete-tangenten hanteras längre ner)
                
                // S för spara - Smart save with Google Drive integration
                if (e.key === 's' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    smartSave();
                }
                
                // L för ladda sparad bräda
                if (e.key === 'l' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    loadBoard();
                }

                // Z för Zotero HTML import
                if (e.key === 'z' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('zoteroHtmlInput').click();
                }

                // F för fokusera sökrutan
                if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('searchInput').focus();
                }
                
                // D för Draw (toggle annotation toolbar)
                if (e.key === 'd' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    toggleAnnotationToolbar();
                }
                
                // A för Arrow (aktivera pil-verktyg direkt från vilken läge som helst)
                if (e.key === 'a' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    // Öppna toolbar om den inte är öppen
                    if (!annotationToolbarVisible) {
                        toggleAnnotationToolbar();
                    }
                    // Vänta en kort stund för att toolbar ska öppnas, sedan aktivera arrow
                    setTimeout(() => {
                        const arrowTool = document.querySelector('[data-tool="arrow"]');
                        if (arrowTool) {
                            // Ta bort active från alla verktyg
                            document.querySelectorAll('.annotation-tool').forEach(tool => {
                                tool.classList.remove('active');
                            });
                            // Aktivera arrow tool
                            arrowTool.classList.add('active');
                            arrowTool.click();
                            console.log('✨ Arrow tool aktiverat med A-tangent');
                        }
                    }, 100);
                }
                
                // Ctrl+S för spara (behåll som backup)
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    saveBoard();
                }
                
                // Ctrl+Z för undo - MINIMAL IMPLEMENTATION
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    if (undoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        redoStack.push(currentState);
                        
                        const previousState = undoStack.pop();
                        restoreState(previousState);
                        console.log('Undo performed');
                    }
                }
                
                // Ctrl+Y för redo - MINIMAL IMPLEMENTATION  
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    if (redoStack.length > 0) {
                        const currentState = {
                            cards: cy.nodes().map(node => ({
                                id: node.id(),
                                position: { x: node.position().x, y: node.position().y },
                                selected: node.selected()
                            }))
                        };
                        undoStack.push(currentState);
                        
                        const nextState = redoStack.pop();
                        restoreState(nextState);
                        console.log('Redo performed');
                    }
                }
                
                // Ctrl+O för ladda (behåll som backup)
                if (e.ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    loadBoard();
                }
                
                // Multi-selection shortcuts
                // P för pin selected cards
                if (e.key === 'p' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    pinSelectedCards();
                }
                
                // U för unpin selected cards
                if (e.key === 'u' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    unpinSelectedCards();
                }
                
                // Delete för ta bort markerade kort
                if (e.key === 'Delete') {
                    e.preventDefault();
                    deleteSelectedCards();
                }
                
                // Ctrl+A för markera alla opinnde kort (pinnade kort påverkas inte)
                if (e.ctrlKey && e.key === 'a') {
                    e.preventDefault();
                    cy.nodes().not('.pinned').select();
                }
                
                // DEBUG: Ctrl+Shift+D för att dumpa alla kort-positioner
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    console.log('\n=== KORT POSITIONER DEBUG ===');
                    cy.nodes().forEach(node => {
                        const pos = node.position();
                        const title = node.data('title') || 'Untitled';
                        console.log(`${node.id()}: x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)} - "${title}"`);
                    });
                    console.log('=== SLUT DEBUG ===\n');
                    
                    // Visa också på skärmen
                    const searchInfo = document.getElementById('searchInfo');
                    if (searchInfo) {
                        searchInfo.textContent = 'Kort-positioner dumpade till console (F12)';
                        searchInfo.classList.add('visible');
                        setTimeout(() => {
                            searchInfo.classList.remove('visible');
                        }, 3000);
                    }
                }
                
                // Enter för att konvertera sökträffar till markerade kort
                if (e.key === 'Enter') {
                    const searchMatches = cy.$('node[searchMatch="true"]');
                    console.log('Enter pressed, found search matches:', searchMatches.length);
                    if (searchMatches.length > 0) {
                        // Konvertera sökträffar till riktigt markerade kort
                        searchMatches.select();
                        console.log('Selected search matches, now clearing search');
                        // Rensa sökmarkering men behåll som markerade
                        clearSearch();
                        e.preventDefault();
                    }
                }
                
                // Escape för rensa sökning och avmarkera alla kort
                if (e.key === 'Escape') {
                    if (cy.$('node[searchMatch="true"]').length > 0) {
                        clearSearch(); // Rensa sökning
                    } else {
                        cy.nodes().unselect(); // Avmarkera alla kort
                    }
                }
                
                
                // Track keys for combination detection
                window.keysPressed = window.keysPressed || new Set();
                window.keysPressed.add(e.key.toLowerCase());
                
                // Handle G+V, G+H, G+T combinations (grid variants for selected cards)
                if (window.keysPressed.has('g') && window.keysPressed.has('v')) {
                    e.preventDefault();
                    arrangeSelectedGridVerticalColumns();
                    return;
                }
                if (window.keysPressed.has('g') && window.keysPressed.has('h')) {
                    e.preventDefault();
                    arrangeSelectedGridHorizontalPacked();
                    return;
                }
                if (window.keysPressed.has('g') && window.keysPressed.has('t')) {
                    e.preventDefault();
                    console.log('G+T pressed, mouse position:', lastMousePosition);
                    arrangeSelectedGridTopAligned();
                    return;
                }
                
                // V för vertikal kolumn (markerade kort) - only if G is not pressed
                if (e.key === 'v' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    arrangeSelectedInColumn();
                    return;
                }
                
                // H för horisontell rad top-aligned (markerade kort)  
                if (e.key === 'h' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    arrangeSelectedInRow();
                }
                
                // T för färgval (markerade kort) - only if G is not pressed
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !e.shiftKey && !window.keysPressed.has('g')) {
                    e.preventDefault();
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        // Create fake event with screen center position
                        const fakeEvent = {
                            clientX: window.innerWidth / 2,
                            clientY: window.innerHeight / 2
                        };
                        showColorPicker(fakeEvent, selectedNodes);
                    }
                }
                
                // Shift+T för att växla förenklad/full toolbar
                if (e.shiftKey && e.key === 'T' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    toggleSimplifiedToolbar();
                }
                
                // Siffertangenter 1-8 för direktfärgning
                if (['1', '2', '3', '4', '5', '6', '7', '8'].includes(e.key) && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        e.preventDefault();
                        const colorNumber = parseInt(e.key);
                        const colorId = `card-color-${colorNumber}`;
                        console.log(`Direct color shortcut ${colorNumber}, applying to ${selectedNodes.length} cards`);

                        // Apply color to all selected nodes
                        selectedNodes.forEach(node => {
                            node.data('cardColor', colorId);
                            const colorValue = getCardColorValue(colorId, getCurrentTheme());
                            node.style('background-color', colorValue);
                        });

                        // Save immediately to prevent data loss from autosave/Drive sync
                        saveBoard();

                        console.log(`Applied color ${colorNumber} to ${selectedNodes.length} cards via shortcut`);
                    }
                }
                
                // 0 för att ta bort färg (återställa)
                if (e.key === '0' && !e.ctrlKey && !e.altKey && !window.keysPressed.has('g')) {
                    const selectedNodes = cy.$('node:selected');
                    if (selectedNodes.length > 0) {
                        e.preventDefault();
                        console.log(`Remove color shortcut, removing from ${selectedNodes.length} cards`);

                        // Remove color from all selected nodes
                        selectedNodes.forEach(node => {
                            removeCardColor(node);
                        });

                        // Save immediately to prevent data loss from autosave/Drive sync
                        saveBoard();

                        console.log(`Removed color from ${selectedNodes.length} cards via shortcut`);
                    }
                }
                
                
                // Q toggles between cluster (ruffig) and stack (prydlig) - infinite loop
                if (e.key === 'q' && !e.ctrlKey && !e.altKey) {
                    const now = Date.now();
                    const lastQTime = window.lastQPress || 0;
                    
                    e.preventDefault();
                    
                    if (now - lastQTime < 500) {
                        // Recent Q press - toggle to the other arrangement
                        const wasCluster = window.lastQWasCluster || true;
                        if (wasCluster) {
                            console.log('Q toggle: cluster → stack');
                            stackSelectedCards();
                            window.lastQWasCluster = false;
                        } else {
                            console.log('Q toggle: stack → cluster');
                            clusterSelectedCards();
                            window.lastQWasCluster = true;
                        }
                        window.lastQPress = now; // Continue the chain
                    } else {
                        // First Q or timeout - always start with cluster
                        console.log('Q start: cluster');
                        clusterSelectedCards();
                        window.lastQWasCluster = true;
                        window.lastQPress = now;
                    }
                }
                
                // Alt+S för neat stack (samma som N)
                if (e.key === 's' && e.altKey && !e.ctrlKey) {
                    e.preventDefault();
                    stackSelectedCards();
                }
                
                // Gamla arrangement shortcuts 1,2,3 borttagna för färgfunktionen
                // Använd istället V (kolumn), H (rad), Q (rutnät)
                
                // Column view specific shortcuts
                // I för importance sorting (äldsta datum + #todo först) - endast i kolumnvy
                if (e.key === 'i' && !e.ctrlKey && !e.altKey && isColumnView) {
                    e.preventDefault();
                    setColumnViewSort('importance');
                }
                
                // W för background-color sorting (röd→blå) - endast i kolumnvy
                if (e.key === 'w' && !e.ctrlKey && !e.altKey && isColumnView) {
                    e.preventDefault();
                    setColumnViewSort('background-color');
                }
                
                // M för multi-card paste (öppna dialog)
                if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    showMultiCardPasteDialog();
                }
                
                // K för toggla mellan bräd och kolumnvy
                if (e.key === 'k' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    toggleView();
                }
                
            });
            
            // Clear pressed keys on keyup for combination detection
            document.addEventListener('keyup', function(e) {
                if (window.keysPressed) {
                    window.keysPressed.delete(e.key.toLowerCase());
                }
            });
            
            // Handle mobile dropdown menus (touch/click to activate)
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                const button = dropdown.querySelector('.menu-button');
                
                button.addEventListener('click', function(e) {
                    e.stopPropagation();
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.menu-dropdown').forEach(otherDropdown => {
                        if (otherDropdown !== dropdown) {
                            otherDropdown.classList.remove('active');
                        }
                    });
                    
                    // Toggle this dropdown
                    dropdown.classList.toggle('active');
                });
                
            });
            
            // Close dropdowns when clicking inside dropdown buttons (Android fix)
            document.querySelectorAll('.dropdown-content button').forEach(button => {
                button.addEventListener('click', function(e) {
                    // Close all dropdowns when any dropdown button is clicked
                    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('active');
                    });
                });
            });
            
            // Close dropdowns when clicking outside or on cytoscape canvas
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.menu-dropdown')) {
                    document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('active');
                    });
                }
            });
            
        });

        // Column View Implementation
        let isColumnView = false;
        let columnCardStates = new Map(); // Track which cards show text vs image

        function toggleView() {
            isColumnView = !isColumnView;
            const btn = document.getElementById('viewToggleBtn');
            const cyContainer = document.getElementById('cy');
            const columnContainer = document.getElementById('columnView');
            
            if (isColumnView) {
                // Switch to column view
                btn.innerHTML = '🗺️ Brädvy';
                btn.title = 'Växla tillbaka till brädvy';
                cyContainer.style.display = 'none';
                columnContainer.style.display = 'block';
                renderColumnViewDebounced();
            } else {
                // Switch to board view
                btn.innerHTML = '📋 Kolumnvy';
                btn.title = 'Växla till kolumnvy';
                cyContainer.style.display = 'block';
                columnContainer.style.display = 'none';
            }
            
            // Save view state to localStorage
            localStorage.setItem('spatial-notes-view', isColumnView ? 'column' : 'board');
        }

        function convertMarkdownToHtml(text) {
            if (!text) return '';
            
            let html = text;
            // Convert markdown to HTML (opposite of what Cytoscape does)
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>'); // ### H3
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>'); // ## H2
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>'); // # H1
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // **bold**
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>'); // *italic*
            html = html.replace(/`(.*?)`/g, '<code>$1</code>'); // `code`
            html = html.replace(/~~(.*?)~~/g, '<del>$1</del>'); // ~~strikethrough~~
            // Convert markdown links [text](url) to clickable links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" style="color: #007acc; text-decoration: underline;" onclick="event.stopPropagation();">$1</a>');
            html = html.replace(/^- /gm, '• '); // Convert - to bullets
            html = html.replace(/\n/g, '<br>'); // Line breaks
            
            return html;
        }

        // Debounced render to avoid excessive updates
        // Setup column view background handlers (one time only)
        let columnBackgroundHandlersSetup = false;
        function setupColumnBackgroundHandlers() {
            if (columnBackgroundHandlersSetup) return;
            columnBackgroundHandlersSetup = true;
            
            const container = document.getElementById('columnContainer');
            
            if (isMobileDevice()) {
                let columnBackgroundTimer = null;
                let columnTouchPos = null;
                
                container.addEventListener('touchstart', (e) => {
                    // Only trigger if touching the background (not a card or card content)
                    const isCard = e.target.closest('.column-card');
                    const isBackground = !isCard && (e.target === container || 
                                        e.target.classList.contains('column-view') ||
                                        e.target.classList.contains('column-container') ||
                                        e.target.id === 'columnContainer');
                    console.log('DEBUG column background touchstart:', e.target, 'isBackground:', isBackground);
                    
                    if (isBackground) {
                        e.preventDefault(); // Prevent text selection on iPad
                        columnTouchPos = { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                        console.log('DEBUG column background touch detected, pos:', columnTouchPos);
                        let backgroundTouchStartTime = Date.now();
                        
                        columnBackgroundTimer = setTimeout(() => {
                            const selectedNodes = cy.$('node:selected');
                            console.log('DEBUG column background LONG PRESS timeout fired, selected nodes:', selectedNodes.length);
                            if (selectedNodes.length > 0 && columnTouchPos) {
                                // Show mobile card menu for selected cards
                                console.log('DEBUG calling showMobileCardMenu from column background');
                                showMobileCardMenu(columnTouchPos, selectedNodes[0].id());
                            }
                        }, 750);
                        
                        // Handle short tap on background to deselect all
                        const handleBackgroundTouchEnd = (endEvent) => {
                            if (columnBackgroundTimer) {
                                clearTimeout(columnBackgroundTimer);
                                columnBackgroundTimer = null;
                            }
                            
                            const tapDuration = Date.now() - backgroundTouchStartTime;
                            console.log('DEBUG background touch end, duration:', tapDuration);
                            
                            if (tapDuration < 300) { // Short tap
                                console.log('DEBUG background short tap - deselecting all cards');
                                cy.nodes().unselect();
                                document.querySelectorAll('.column-card').forEach(card => {
                                    card.classList.remove('selected');
                                });
                            }
                            
                            columnTouchPos = null;
                            container.removeEventListener('touchend', handleBackgroundTouchEnd);
                            container.removeEventListener('touchmove', handleBackgroundTouchEnd);
                        };
                        
                        container.addEventListener('touchend', handleBackgroundTouchEnd, { once: true });
                        container.addEventListener('touchmove', handleBackgroundTouchEnd, { once: true });
                    }
                }, { passive: false });
            } else {
                // Desktop: Simple click handler for background
                container.addEventListener('click', (e) => {
                    const isCard = e.target.closest('.column-card');
                    if (!isCard) {
                        console.log('DEBUG desktop background click - deselecting all cards');
                        cy.nodes().unselect();
                        document.querySelectorAll('.column-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                    }
                });
            }
        }

        let renderColumnViewTimeout = null;
        function renderColumnView() {
            const container = document.getElementById('columnContainer');
            container.innerHTML = '';
            
            
            // Setup background handlers once
            setupColumnBackgroundHandlers();
            
            if (!cy) return;
            
            // Apply temporal markings before rendering
            if (typeof applyTemporalMarkings === 'function') {
                applyTemporalMarkings();
            }
            
            // Get all nodes and apply automatic sorting
            let nodes = cy.nodes().stdFilter(function(node) {
                return !node.data('isAnnotation'); // Exclude annotation nodes
            });
            
            // Apply sorting based on current sort preference
            nodes = sortColumnViewNodes(nodes);
            
            // Use document fragment for better performance
            const fragment = document.createDocumentFragment();
            nodes.forEach(node => {
                const cardDiv = createColumnCard(node);
                fragment.appendChild(cardDiv);
            });
            container.appendChild(fragment);
            
            // Apply current search highlighting
            updateColumnViewSearch();
        }
        
        function renderColumnViewDebounced() {
            if (renderColumnViewTimeout) {
                clearTimeout(renderColumnViewTimeout);
            }
            renderColumnViewTimeout = setTimeout(renderColumnView, 16); // ~60fps
        }

        // Column view sorting function
        let currentColumnSort = 'creation'; // default sort
        function sortColumnViewNodes(nodes) {
            const nodeArray = nodes.toArray();
            
            switch(currentColumnSort) {
                case 'alphabetical':
                    return nodeArray.sort((a, b) => {
                        const aText = (a.data('title') || a.data('text') || '').toLowerCase();
                        const bText = (b.data('title') || b.data('text') || '').toLowerCase();
                        return aText.localeCompare(bText);
                    });
                
                case 'reverse-alphabetical':
                    return nodeArray.sort((a, b) => {
                        const aText = (a.data('title') || a.data('text') || '').toLowerCase();
                        const bText = (b.data('title') || b.data('text') || '').toLowerCase();
                        return bText.localeCompare(aText);
                    });
                
                case 'creation':
                    return nodeArray.sort((a, b) => {
                        // Sort by ID (assuming timestamp-based IDs)
                        return a.id().localeCompare(b.id());
                    });
                
                case 'reverse-creation':
                    return nodeArray.sort((a, b) => {
                        return b.id().localeCompare(a.id());
                    });
                
                case 'tags':
                    return nodeArray.sort((a, b) => {
                        const aTags = (a.data('tags') || []).join(' ').toLowerCase();
                        const bTags = (b.data('tags') || []).join(' ').toLowerCase();
                        return aTags.localeCompare(bTags);
                    });

                case 'color':
                    return nodeArray.sort((a, b) => {
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Same color order as background-color: röd, orange, gul, lila, blå, vit, grön, grå
                        const colorOrder = {
                            'card-color-3': 1, // röd
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // blå
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // grön
                            'card-color-7': 8, // grå
                            '': 9              // ofärgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        return aPriority - bPriority;
                    });

                case 'tagged-date':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '999999'; // No date = last
                        const bDate = bDateMatch ? bDateMatch[1] : '999999';
                        
                        return aDate.localeCompare(bDate);
                    });

                case 'reverse-tagged-date':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '000000'; // No date = first
                        const bDate = bDateMatch ? bDateMatch[1] : '000000';
                        
                        return bDate.localeCompare(aDate);
                    });

                case 'importance':
                    return nodeArray.sort((a, b) => {
                        const aText = a.data('title') + ' ' + a.data('text');
                        const bText = b.data('title') + ' ' + b.data('text');
                        const aTags = a.data('tags') || [];
                        const bTags = b.data('tags') || [];
                        
                        // Check for search matches OR selected cards (after Enter)
                        const aIsSearchMatch = a.hasClass('search-match') || a.data('searchMatch') || a.selected();
                        const bIsSearchMatch = b.hasClass('search-match') || b.data('searchMatch') || b.selected();
                        
                        // Prioritize search matches and selected cards
                        if (aIsSearchMatch && !bIsSearchMatch) return -1;
                        if (!aIsSearchMatch && bIsSearchMatch) return 1;
                        
                        // Check for #todo tag
                        const aHasTodo = aTags.some(tag => tag.toLowerCase() === 'todo');
                        const bHasTodo = bTags.some(tag => tag.toLowerCase() === 'todo');
                        
                        // Extract @yymmdd dates
                        const aDateMatch = aText.match(/@(\d{6})/);
                        const bDateMatch = bText.match(/@(\d{6})/);
                        
                        const aDate = aDateMatch ? aDateMatch[1] : '999999'; // No date = last
                        const bDate = bDateMatch ? bDateMatch[1] : '999999';
                        
                        // Priority: oldest date + #todo first, then by date, then no date
                        if (aHasTodo && !bHasTodo) return -1; // a has todo, b doesn't
                        if (!aHasTodo && bHasTodo) return 1;  // b has todo, a doesn't
                        
                        // Both have todo or both don't have todo - sort by date (oldest first)
                        return aDate.localeCompare(bDate);
                    });

                case 'background-color':
                    return nodeArray.sort((a, b) => {
                        // Check for search matches OR selected cards (after Enter)
                        const aIsSearchMatch = a.hasClass('search-match') || a.data('searchMatch') || a.selected();
                        const bIsSearchMatch = b.hasClass('search-match') || b.data('searchMatch') || b.selected();
                        
                        // Prioritize search matches and selected cards
                        if (aIsSearchMatch && !bIsSearchMatch) return -1;
                        if (!aIsSearchMatch && bIsSearchMatch) return 1;
                        
                        const aColor = a.data('cardColor') || '';
                        const bColor = b.data('cardColor') || '';
                        
                        // Color priority: röd, orange, gul, lila, blå, vit, grön, grå
                        const colorOrder = {
                            'card-color-3': 1, // röd
                            'card-color-2': 2, // orange  
                            'card-color-4': 3, // gul
                            'card-color-5': 4, // lila
                            'card-color-6': 5, // blå
                            'card-color-8': 6, // vit
                            'card-color-1': 7, // grön
                            'card-color-7': 8, // grå
                            '': 9              // ofärgad (kommer sist)
                        };
                        
                        const aPriority = colorOrder[aColor] || 9;
                        const bPriority = colorOrder[bColor] || 9;
                        
                        return aPriority - bPriority;
                    });

                case 'today-first':
                    return nodeArray.sort((a, b) => {
                        const aTodayScore = getTodayScore(a);
                        const bTodayScore = getTodayScore(b);
                        return bTodayScore - aTodayScore; // Higher score = today content = first
                    });
                
                default:
                    return nodeArray;
            }
        }

        // Function to change column view sorting
        function setColumnViewSort(sortType) {
            currentColumnSort = sortType;
            console.log('Column view sort set to:', sortType);
            
            if (isColumnView) {
                renderColumnViewDebounced();
                
                // Show feedback
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    let sortName = 'Okänd sortering';
                    switch(sortType) {
                        case 'alphabetical': sortName = 'A → Z'; break;
                        case 'reverse-alphabetical': sortName = 'Z → A'; break;
                        case 'creation': sortName = 'Äldst → Nyast'; break;
                        case 'reverse-creation': sortName = 'Nyast → Äldst'; break;
                        case 'tags': sortName = 'Sorterat efter taggar'; break;
                        case 'color': sortName = 'Färg 1→6'; break;
                        case 'tagged-date': sortName = '@datum Äldst → Nyast'; break;
                        case 'reverse-tagged-date': sortName = '@datum Nyast → Äldst'; break;
                        case 'importance': sortName = 'Viktighet (äldsta #todo först)'; break;
                        case 'background-color': sortName = 'Bakgrundsfärg (röd→grå)'; break;
                        case 'today-first': sortName = 'Idag först'; break;
                    }
                    statusDiv.textContent = `Kolumnvy sorterad: ${sortName}`;
                    statusDiv.classList.add('visible');
                    
                    // Auto-hide after 3 seconds
                    setTimeout(() => {
                        statusDiv.classList.remove('visible');
                    }, 3000);
                }
            }
            
            // Close sort menu
            closeSortMenu();
        }

        function createColumnCard(node) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'column-card';
            cardDiv.dataset.nodeId = node.id();
            
            // Apply current state classes
            if (node.hasClass('search-match')) {
                cardDiv.classList.add('search-match');
            }
            if (node.selected()) {
                cardDiv.classList.add('selected');
            }
            
            // Apply card color if it exists
            const cardColor = node.data('cardColor');
            if (cardColor) {
                const currentTheme = getCurrentTheme();
                const color = getCardColorValue(cardColor, currentTheme);
                if (color) {
                    cardDiv.style.backgroundColor = color;
                }
            }

            // Apply temporal markings if they exist
            const temporalBorderWidth = node.data('temporalBorderWidth');
            const temporalBorderColor = node.data('temporalBorderColor');
            if (temporalBorderWidth && temporalBorderColor) {
                cardDiv.style.borderWidth = temporalBorderWidth + 'px';
                cardDiv.style.borderColor = temporalBorderColor;
                cardDiv.style.borderStyle = 'solid';
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'column-card-content';
            
            // Check if card should show image or text
            const nodeId = node.id();
            const showText = columnCardStates.get(nodeId) || false;
            const hasImage = node.data('imageData');
            
            if (hasImage && !showText) {
                // Show image ONLY - no text/annotation in image mode
                const img = document.createElement('img');
                img.src = node.data('imageData');
                img.className = 'column-card-image';
                img.alt = node.data('originalFileName') || 'Bild';
                contentDiv.appendChild(img);
            } else if (hasImage && showText) {
                // Show text/annotation ONLY - no image in text mode
                const annotation = node.data('annotation');
                if (annotation) {
                    const displayText = convertMarkdownToHtml(annotation);
                    contentDiv.innerHTML = displayText;
                }
            } else {
                // Show text content
                const title = node.data('title') || '';
                const text = node.data('text') || '';
                const isManualCard = node.data('isManualCard') || false;
                
                let displayText = '';
                if (title && !isManualCard) {
                    displayText = `<strong>${title}</strong><br><br>`;
                }
                displayText += convertMarkdownToHtml(text);
                
                contentDiv.innerHTML = displayText;
            }
            
            // Add tags
            const tags = node.data('tags') || [];
            if (tags.length > 0) {
                const visibleTags = tags.filter(tag => {
                    const pdfPattern = /^[A-Za-z\-]+\-\d{4}\-[a-z\-]+$/;
                    return !pdfPattern.test(tag);
                });
                
                if (visibleTags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'column-card-tags';
                    visibleTags.forEach(tag => {
                        const tagSpan = document.createElement('span');
                        tagSpan.className = 'tag';
                        tagSpan.textContent = '#' + tag;
                        tagsDiv.appendChild(tagSpan);
                    });
                    contentDiv.appendChild(tagsDiv);
                }
            }
            
            // Create wrapper for content and selection area
            const cardWrapper = document.createElement('div');
            cardWrapper.style.cssText = `
                display: flex;
                width: 100%;
                min-height: 100%;
            `;
            
            // Content takes most of the space
            contentDiv.style.cssText = `
                flex: 1;
                min-width: 0;
                user-select: text;
                -webkit-user-select: text;
            `;
            
            // Create selection area on the right (40px wide)
            const selectionArea = document.createElement('div');
            selectionArea.className = 'column-card-selection-area';
            selectionArea.style.cssText = `
                width: 40px;
                min-height: 60px;
                background: transparent;
                cursor: pointer;
                flex-shrink: 0;
                user-select: none;
                -webkit-user-select: none;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0.3;
                transition: opacity 0.2s;
            `;
            
            // Add visual indicator that changes based on selection state
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                width: 12px; 
                height: 12px; 
                border-radius: 50%; 
                border: 2px solid currentColor;
                background: ${node.selected() ? 'currentColor' : 'transparent'};
                transition: all 0.2s;
            `;
            selectionArea.appendChild(indicator);
            
            // Update indicator when selection changes
            const updateIndicator = () => {
                if (cardDiv.classList.contains('selected')) {
                    indicator.style.background = 'currentColor';
                    selectionArea.style.opacity = '0.8';
                } else {
                    indicator.style.background = 'transparent';
                    selectionArea.style.opacity = '0.3';
                }
            };
            
            // Initial state
            updateIndicator();
            
            // Hover effect for desktop
            selectionArea.addEventListener('mouseenter', () => {
                selectionArea.style.opacity = '0.8';
            });
            selectionArea.addEventListener('mouseleave', updateIndicator);
            
            cardWrapper.appendChild(contentDiv);
            cardWrapper.appendChild(selectionArea);
            cardDiv.appendChild(cardWrapper);
            
            // Add selection click handler to the selection area
            selectionArea.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                console.log('DEBUG selection area click:', node.id(), 'isMobileDevice():', isMobileDevice());
                console.log('DEBUG mobile tap -> toggleColumnCardSelection');
                toggleColumnCardSelection(node.id(), cardDiv);
            });
            
            // Add click handlers for content area (desktop functionality)
            contentDiv.addEventListener('click', (e) => {
                if (!isMobileDevice()) {
                    console.log('DEBUG content area click (desktop):', node.id(), 'ctrlKey:', e.ctrlKey, 'metaKey:', e.metaKey);
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+click for multi-select (desktop)
                        console.log('DEBUG ctrl+click -> toggleColumnCardSelection');
                        toggleColumnCardSelection(node.id(), cardDiv);
                    } else if (hasImage) {
                        // Desktop: Toggle between image and text for image cards
                        const currentState = columnCardStates.get(nodeId) || false;
                        columnCardStates.set(nodeId, !currentState);
                        
                        // Re-render just this card
                        const newCard = createColumnCard(node);
                        cardDiv.parentNode.replaceChild(newCard, cardDiv);
                    } else {
                        // Desktop: Select single card
                        selectColumnCard(node.id(), cardDiv);
                    }
                }
                // On mobile, content area clicks do nothing (avoid text selection conflicts)
            });
            
            // Add double-click handler for editing
            cardDiv.addEventListener('dblclick', (e) => {
                e.preventDefault();
                editCard(node); // Reuse existing edit function
            });

            // Add right-click context menu
            cardDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showColumnContextMenu(e, node.id());
            });
            
            // Add iPad/mobile long-press functionality for tagging and color change
            let longPressTimer = null;
            let touchStartTime = 0;
            let touchMoved = false;
            
            cardDiv.addEventListener('touchstart', (e) => {
                console.log('DEBUG column touchstart:', node.id(), 'touches:', e.touches?.length);
                touchStartTime = Date.now();
                touchMoved = false;
                
                // Set up long press detection (800ms)
                longPressTimer = setTimeout(() => {
                    console.log('DEBUG column long press timeout fired, touchMoved:', touchMoved);
                    if (!touchMoved) {
                        e.preventDefault();
                        // Show combined tag/color context menu for iPad
                        console.log('DEBUG calling showMobileCardMenu from column long press:', e.touches[0], node.id());
                        showMobileCardMenu(e.touches[0], node.id());
                    }
                }, 800);
            }, { passive: false });
            
            cardDiv.addEventListener('touchmove', () => {
                touchMoved = true;
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
            
            cardDiv.addEventListener('touchend', (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // If it was a quick tap (< 200ms) and didn't move, treat as normal click
                if (!touchMoved && (Date.now() - touchStartTime) < 200) {
                    // Trigger normal click behavior
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        clientX: e.changedTouches[0].clientX,
                        clientY: e.changedTouches[0].clientY
                    });
                    cardDiv.dispatchEvent(clickEvent);
                }
            });
            
            return cardDiv;
        }

        // Mobile/iPad context menu with tagging and color options
        function showMobileCardMenu(touch, nodeId) {
            console.log('DEBUG showMobileCardMenu called with touch:', touch, 'nodeId:', nodeId);
            // Remove any existing mobile menu
            const existingMenu = document.getElementById('mobileCardMenu');
            if (existingMenu) {
                document.body.removeChild(existingMenu);
                console.log('DEBUG removed existing menu');
            }
            
            const node = cy.getElementById(nodeId);
            
            // Ensure the target node is selected for tag operations
            if (!node.selected()) {
                console.log('DEBUG target node not selected, selecting it');
                node.select();
                // Update column view visual selection
                if (isColumnView) {
                    const cardDiv = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (cardDiv) {
                        cardDiv.classList.add('selected');
                    }
                }
            }
            
            const selectedNodes = cy.$('node:selected');
            const isMultipleSelected = selectedNodes.length > 1;
            const targetNodes = isMultipleSelected ? selectedNodes : cy.$(`#${nodeId}`);
            console.log('DEBUG node found:', !!node, 'selectedNodes.length:', selectedNodes.length, 'isMultipleSelected:', isMultipleSelected);
            
            // Create mobile menu
            const menu = document.createElement('div');
            menu.id = 'mobileCardMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${Math.min(touch.clientX, window.innerWidth - 280)}px;
                top: ${Math.min(touch.clientY, window.innerHeight - 400)}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 260px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 16px;
                padding: 12px 0;
            `;
            
            const targetText = isMultipleSelected ? `${selectedNodes.length} kort` : '1 kort';
            
            menu.innerHTML = `
                <div style="padding: 8px 16px; font-weight: bold; color: #666; border-bottom: 1px solid #eee;">
                    ${targetText}
                </div>
                
                <!-- Color Section -->
                <div style="padding: 12px 16px; border-bottom: 1px solid #eee;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #333;">Färg</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;" id="mobileColorGrid">
                    </div>
                    <div style="margin-top: 8px;">
                        <div class="mobile-clear-color" style="background: #f5f5f5; padding: 6px 12px; border-radius: 16px; text-align: center; cursor: pointer; border: 1px solid #ddd;">Ta bort färg</div>
                    </div>
                </div>
                
                <!-- Tags Section -->
                <div style="padding: 12px 16px; border-bottom: 1px solid #eee;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #333;">Taggar</div>
                    <div class="mobile-menu-item" data-action="add-tag" style="padding: 8px 12px; cursor: pointer; border-radius: 8px; margin-bottom: 4px;">➕ Lägg till tagg</div>
                    <div class="mobile-menu-item" data-action="remove-tag" style="padding: 8px 12px; cursor: pointer; border-radius: 8px;">➖ Ta bort tagg</div>
                </div>

                <!-- Pin Section -->
                <div style="padding: 12px 16px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #333;">Pinning</div>
                    <div class="mobile-menu-item" data-action="toggle-pin" id="mobilePinToggle" style="padding: 8px 12px; cursor: pointer; border-radius: 8px;">📌 Pinna kort</div>
                </div>
            `;
            
            document.body.appendChild(menu);

            // Update pin button text based on current state
            const pinToggleBtn = menu.querySelector('#mobilePinToggle');
            const anyPinned = targetNodes.some(node => node.hasClass('pinned'));
            if (anyPinned) {
                pinToggleBtn.innerHTML = '📌 Ta bort pinning';
            } else {
                pinToggleBtn.innerHTML = '📌 Pinna kort';
            }

            // Create color dots dynamically with real colors
            const colorGrid = menu.querySelector('#mobileColorGrid');
            const currentTheme = getCurrentTheme();
            
            for (let i = 1; i <= 8; i++) {
                const colorValue = getCardColorValue(`card-color-${i}`, currentTheme);
                const colorDot = document.createElement('div');
                colorDot.className = 'mobile-color-dot';
                colorDot.dataset.color = i;
                colorDot.style.cssText = `
                    background: ${colorValue};
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    color: ${currentTheme === 'light' ? '#333' : '#fff'};
                    cursor: pointer;
                    border: 2px solid #ddd;
                `;
                colorDot.textContent = i;
                colorGrid.appendChild(colorDot);
            }
            
            // Add color click handlers
            menu.querySelectorAll('.mobile-color-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    const colorNum = dot.dataset.color;
                    const colorId = `card-color-${colorNum}`;
                    
                    targetNodes.forEach(node => {
                        node.data('cardColor', colorId);
                        const colorValue = getCardColorValue(colorId, getCurrentTheme());
                        node.style('background-color', colorValue);
                    });
                    
                    // Update column view if active
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }

                    // Show feedback
                    const statusDiv = document.getElementById('selectionInfo');
                    if (statusDiv) {
                        statusDiv.textContent = `Färgade ${targetNodes.length} kort med färg ${colorNum}`;
                        statusDiv.classList.add('visible');
                        setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                    }

                    // Save immediately to prevent data loss from autosave/Drive sync
                    saveBoard();

                    document.body.removeChild(menu);
                });
            });
            
            // Clear color handler
            menu.querySelector('.mobile-clear-color').addEventListener('click', () => {
                targetNodes.forEach(node => {
                    removeCardColor(node);
                });

                if (isColumnView) {
                    renderColumnViewDebounced();
                }

                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Tog bort färg från ${targetNodes.length} kort`;
                    statusDiv.classList.add('visible');
                    setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                }

                // Save immediately to prevent data loss from autosave/Drive sync
                saveBoard();

                document.body.removeChild(menu);
            });
            
            // Tag and Pin action handlers
            menu.querySelectorAll('.mobile-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    console.log('DEBUG mobile menu item clicked:', action);
                    if (action === 'add-tag') {
                        console.log('DEBUG calling addTagToSelected from mobile menu');
                        addTagToSelected();
                    } else if (action === 'remove-tag') {
                        console.log('DEBUG calling removeTagFromSelected from mobile menu');
                        removeTagFromSelected();
                    } else if (action === 'toggle-pin') {
                        console.log('DEBUG toggling pin for selected cards');
                        const anyPinned = targetNodes.some(node => node.hasClass('pinned'));
                        targetNodes.forEach(node => {
                            if (anyPinned) {
                                unpinCard(node);
                                node.grabify(); // Make draggable again
                            } else {
                                pinCard(node);
                                node.ungrabify(); // Make undraggable
                            }
                        });

                        // Update column view if active
                        if (isColumnView) {
                            renderColumnViewDebounced();
                        }

                        // Show feedback
                        const statusDiv = document.getElementById('selectionInfo');
                        if (statusDiv) {
                            const action = anyPinned ? 'Tog bort pinning från' : 'Pinnade';
                            statusDiv.textContent = `${action} ${targetNodes.length} kort`;
                            statusDiv.classList.add('visible');
                            setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                        }

                        saveBoard();
                    }
                    document.body.removeChild(menu);
                });
            });
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', closeHandler);
                        document.removeEventListener('touchstart', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
                document.addEventListener('touchstart', closeHandler);
            }, 100);
        }

        function toggleColumnCardSelection(nodeId, cardDiv) {
            const node = cy.getElementById(nodeId);
            console.log('DEBUG toggleColumnCardSelection:', nodeId, 'was selected:', node.selected());
            if (node.selected()) {
                node.unselect();
                cardDiv.classList.remove('selected');
                console.log('DEBUG unselected', nodeId);
            } else {
                node.select();
                cardDiv.classList.add('selected');
                console.log('DEBUG selected', nodeId);
            }
            console.log('DEBUG total selected after toggle:', cy.$('node:selected').length);
        }

        function selectColumnCard(nodeId, cardDiv) {
            console.log('DEBUG selectColumnCard called:', nodeId, 'clearing all selections first');
            // Deselect all
            cy.nodes().unselect();
            document.querySelectorAll('.column-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Select this one
            const node = cy.getElementById(nodeId);
            node.select();
            cardDiv.classList.add('selected');
            console.log('DEBUG selectColumnCard completed, selected:', nodeId, 'total selected:', cy.$('node:selected').length);
        }

        function updateColumnViewSearch() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                
                if (node.hasClass('search-match')) {
                    cardDiv.classList.add('search-match');
                } else {
                    cardDiv.classList.remove('search-match');
                }
            });
        }

        function getCurrentTheme() {
            if (document.body.classList.contains('dark-theme')) return 'dark';
            if (document.body.classList.contains('sepia-theme')) return 'sepia';
            if (document.body.classList.contains('eink-theme')) return 'eink';
            return 'light';
        }

        // Hook into existing search functions to update column view
        const originalPerformSearch = performSearch;
        performSearch = function(query) {
            const result = originalPerformSearch.call(this, query);
            updateColumnViewSearch();
            return result;
        };

        const originalClearSearch = clearSearch;
        clearSearch = function() {
            const result = originalClearSearch.call(this);
            updateColumnViewSearch();
            return result;
        };

        const originalPerformTagFilter = performTagFilter;
        performTagFilter = function() {
            const result = originalPerformTagFilter.apply(this, arguments);
            updateColumnViewSearch();
            return result;
        };

        const originalClearTagFilter = clearTagFilter;
        clearTagFilter = function() {
            const result = originalClearTagFilter.call(this);
            updateColumnViewSearch();
            return result;
        };

        // Function to update column view colors immediately
        function updateColumnViewColors() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                const cardColor = node.data('cardColor');
                
                if (cardColor) {
                    const currentTheme = getCurrentTheme();
                    const color = getCardColorValue(cardColor, currentTheme);
                    if (color) {
                        cardDiv.style.backgroundColor = color;
                    }
                } else {
                    // Remove background color if no card color
                    cardDiv.style.backgroundColor = '';
                }
            });
        }

        // Function to update column view selections
        function updateColumnViewSelections() {
            if (!isColumnView) return;
            
            document.querySelectorAll('.column-card').forEach(cardDiv => {
                const nodeId = cardDiv.dataset.nodeId;
                const node = cy.getElementById(nodeId);
                
                if (node.selected()) {
                    cardDiv.classList.add('selected');
                } else {
                    cardDiv.classList.remove('selected');
                }
            });
        }

        // Hook into color functions - need to find where colors are applied
        // Override the color application functions to update column view
        setTimeout(() => {
            // Hook into the existing color functions after they're defined
            if (typeof applyColorToNodes === 'function') {
                const originalApplyColorToNodes = applyColorToNodes;
                applyColorToNodes = function() {
                    const result = originalApplyColorToNodes.apply(this, arguments);
                    updateColumnViewColors();
                    return result;
                };
            }

            // Hook into removeCardColor function
            if (typeof removeCardColor === 'function') {
                const originalRemoveCardColor = removeCardColor;
                removeCardColor = function(node) {
                    const result = originalRemoveCardColor.call(this, node);
                    updateColumnViewColors();
                    return result;
                };
            }

            // Hook into direct style updates via Cytoscape events
            if (cy) {
                cy.on('style', function(evt) {
                    // Update column view when any node style changes
                    setTimeout(updateColumnViewColors, 10);
                });
                
                cy.on('data', function(evt) {
                    // Update column view when node data changes (like cardColor)
                    setTimeout(updateColumnViewColors, 10);
                });

                // Hook into selection events
                cy.on('select unselect', function(evt) {
                    // Update column view when selections change
                    setTimeout(updateColumnViewSelections, 10);
                });

                // Hook into add/remove events to re-render column view
                cy.on('add remove', function(evt) {
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                });
            }
        }, 500);

        // Restore view state on page load
        setTimeout(() => {
            const savedView = localStorage.getItem('spatial-notes-view');
            if (savedView === 'column' && !isColumnView) {
                toggleView(); // Switch to column view if it was saved
            }
        }, 1000); // Wait a bit longer to ensure everything is initialized

        // Function to update column view for specific node after text changes
        function updateColumnViewCard(nodeId) {
            if (!isColumnView) return;
            
            const cardDiv = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (cardDiv) {
                const node = cy.getElementById(nodeId);
                const newCard = createColumnCard(node);
                cardDiv.parentNode.replaceChild(newCard, cardDiv);
            }
        }

        // Hook into edit dialogs to update column view on text changes
        // We'll monitor for text changes in edit dialogs
        let editDialogObserver = null;
        function watchEditDialogs() {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Check if edit dialog was added
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1 && node.querySelector && node.querySelector('textarea')) {
                                const textarea = node.querySelector('textarea');
                                const nodeId = node.dataset?.nodeId || getEditingNodeId();
                                
                                if (textarea && nodeId && isColumnView) {
                                    // Add input listener to textarea
                                    textarea.addEventListener('input', function() {
                                        // Update node data temporarily for preview
                                        const cyNode = cy.getElementById(nodeId);
                                        if (cyNode) {
                                            cyNode.data('text', this.value);
                                            setTimeout(() => updateColumnViewCard(nodeId), 10);
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            return observer;
        }

        // Helper function to get currently editing node ID (best effort)
        function getEditingNodeId() {
            // Try to find the node being edited by looking for selected nodes
            const selected = cy.$('node:selected');
            return selected.length > 0 ? selected[0].id() : null;
        }

        // Start watching for edit dialogs
        setTimeout(() => {
            editDialogObserver = watchEditDialogs();
        }, 2000);

        // Column view context menu
        function showColumnContextMenu(e, nodeId) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('columnContextMenu');
            if (existingMenu) {
                document.body.removeChild(existingMenu);
            }

            const selectedNodes = cy.$('node:selected');
            const isMultipleSelected = selectedNodes.length > 1;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'columnContextMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                min-width: 150px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
            `;

            const targetText = isMultipleSelected ? `${selectedNodes.length} kort` : '1 kort';

            menu.innerHTML = `
                <div style="padding: 8px 0; border-bottom: 1px solid #eee;">
                    <div style="padding: 4px 12px; font-weight: bold; color: #666;">Taggar för ${targetText}</div>
                </div>
                <div style="padding: 4px 0;">
                    <div class="context-menu-item" onclick="addTagToSelected()" style="padding: 8px 12px; cursor: pointer;">➕ Lägg till tagg</div>
                    <div class="context-menu-item" onclick="removeTagFromSelected()" style="padding: 8px 12px; cursor: pointer;">➖ Ta bort tagg</div>
                </div>
                <div style="padding: 8px 0; border-top: 1px solid #eee;">
                    <div style="padding: 4px 12px; font-weight: bold; color: #666;">Färger för ${targetText}</div>
                </div>
                <div style="padding: 4px 0;">
                    <div class="context-menu-item" onclick="showColumnColorPicker(event, '${nodeId}')" style="padding: 8px 12px; cursor: pointer;">🎨 Färga kort</div>
                    <div class="context-menu-item" onclick="removeColorFromSelected()" style="padding: 8px 12px; cursor: pointer;">❌ Ta bort färg</div>
                </div>
            `;

            // Add hover effects to menu items
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#f0f0f0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '';
                });
            });

            document.body.appendChild(menu);

            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    document.body.removeChild(menu);
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 10);
        }

        // Add tag to selected cards
        function addTagToSelected() {
            const selectedNodes = cy.$('node:selected');
            console.log('DEBUG addTagToSelected called, selected nodes:', selectedNodes.length);
            if (selectedNodes.length === 0) return;

            // Create iPad-friendly tag input dialog
            console.log('DEBUG calling showTagInputDialog');
            showTagInputDialog((tagName) => {
                if (!tagName || !tagName.trim()) return;

                const cleanTag = tagName.trim().replace(/^#/, ''); // Remove # if present

                selectedNodes.forEach(node => {
                    const currentTags = node.data('tags') || [];
                    if (!currentTags.includes(cleanTag)) {
                        currentTags.push(cleanTag);
                        node.data('tags', currentTags);
                    }
                });

                // Save and update views
                saveBoard();
                if (isColumnView) {
                    renderColumnViewDebounced();
                }
                
                // Show feedback
                const statusDiv = document.getElementById('selectionInfo');
                if (statusDiv) {
                    statusDiv.textContent = `Lade till tagg "${cleanTag}" på ${selectedNodes.length} kort`;
                    statusDiv.classList.add('visible');
                    setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                }
            });
        }

        // iPad-friendly tag input dialog
        function showTagInputDialog(callback) {
            console.log('DEBUG showTagInputDialog called');
            // Remove any existing dialog
            const existingDialog = document.querySelector('.tag-input-dialog');
            if (existingDialog) {
                existingDialog.remove();
                console.log('DEBUG removed existing tag dialog');
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'tag-input-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                width: 90%;
                max-width: 400px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">Lägg till tagg</h3>
                <input type="text" id="tagNameInput" placeholder="Taggnamn (utan #)" style="
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #ddd;
                    border-radius: 8px;
                    font-size: 16px;
                    box-sizing: border-box;
                    margin-bottom: 15px;
                " />
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancelTagInput" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">Avbryt</button>
                    <button id="confirmTagInput" style="
                        padding: 10px 20px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">Lägg till</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('DEBUG tag input dialog added to DOM');
            
            // Focus input
            const input = document.getElementById('tagNameInput');
            setTimeout(() => input.focus(), 100);
            
            // Event handlers
            const cleanup = () => {
                console.log('DEBUG tag dialog cleanup called');
                overlay.remove();
            };
            
            document.getElementById('cancelTagInput').onclick = () => {
                console.log('DEBUG cancel tag button clicked');
                cleanup();
            };
            
            document.getElementById('confirmTagInput').onclick = () => {
                const tagName = input.value.trim();
                console.log('DEBUG confirm tag button clicked, tagName:', tagName);
                cleanup();
                if (callback) callback(tagName);
            };
            
            // Enter key to confirm
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const tagName = input.value.trim();
                    cleanup();
                    if (callback) callback(tagName);
                } else if (e.key === 'Escape') {
                    cleanup();
                }
            });
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    cleanup();
                }
            });
        }

        // Remove tag from selected cards
        function removeTagFromSelected() {
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length === 0) return;

            // Collect all unique tags from selected nodes
            const allTags = new Set();
            selectedNodes.forEach(node => {
                const tags = node.data('tags') || [];
                tags.forEach(tag => allTags.add(tag));
            });

            if (allTags.size === 0) {
                alert('Inga taggar hittades på de markerade korten.');
                return;
            }

            const tagList = Array.from(allTags).sort();
            
            // Show iPad-friendly tag selection dialog
            showTagSelectionDialog(tagList, (selectedTag) => {
                if (!selectedTag) return;

                const cleanTag = selectedTag.trim().replace(/^#/, '');

                let removedCount = 0;
                selectedNodes.forEach(node => {
                    const currentTags = node.data('tags') || [];
                    const filteredTags = currentTags.filter(tag => tag !== cleanTag);
                    if (filteredTags.length !== currentTags.length) {
                        node.data('tags', filteredTags);
                        removedCount++;
                    }
                });

                if (removedCount > 0) {
                    // Save and update views
                    saveBoard();
                    if (isColumnView) {
                        renderColumnViewDebounced();
                    }
                    
                    // Show feedback
                    const statusDiv = document.getElementById('selectionInfo');
                    if (statusDiv) {
                        statusDiv.textContent = `Tog bort tagg "${cleanTag}" från ${removedCount} kort`;
                        statusDiv.classList.add('visible');
                        setTimeout(() => statusDiv.classList.remove('visible'), 2000);
                    }
                } else {
                    alert(`Taggen "${cleanTag}" hittades inte på de markerade korten.`);
                }
            });
        }

        // iPad-friendly tag selection dialog
        function showTagSelectionDialog(tagList, callback) {
            // Remove any existing dialog
            const existingDialog = document.querySelector('.tag-selection-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }
            
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.className = 'tag-selection-dialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog content
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                width: 90%;
                max-width: 400px;
                max-height: 70vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">Ta bort tagg</h3>
                <p style="margin: 0 0 15px 0; color: #666; text-align: center; font-size: 14px;">
                    Välj vilken tagg som ska tas bort:
                </p>
                <div id="tagSelectionList" style="margin-bottom: 15px;">
                    ${tagList.map(tag => `
                        <div class="tag-selection-item" data-tag="${tag}" style="
                            padding: 12px;
                            border: 1px solid #ddd;
                            border-radius: 8px;
                            margin-bottom: 8px;
                            cursor: pointer;
                            background: #f8f9fa;
                            text-align: center;
                            font-size: 16px;
                        ">${tag}</div>
                    `).join('')}
                </div>
                <div style="text-align: center;">
                    <button id="cancelTagSelection" style="
                        padding: 10px 20px;
                        border: 1px solid #ddd;
                        background: white;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">Avbryt</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Event handlers
            const cleanup = () => {
                overlay.remove();
            };
            
            // Tag selection handlers
            overlay.querySelectorAll('.tag-selection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const selectedTag = item.dataset.tag;
                    cleanup();
                    if (callback) callback(selectedTag);
                });
                
                // Hover effects
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#e9ecef';
                    item.style.borderColor = '#007bff';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '#f8f9fa';
                    item.style.borderColor = '#ddd';
                });
            });
            
            document.getElementById('cancelTagSelection').onclick = cleanup;
            
            // Close on click outside dialog
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    cleanup();
                }
            });
        }

        // Show color picker for column view cards
        function showColumnColorPicker(event, nodeId) {
            // Close context menu first
            const menu = document.getElementById('columnContextMenu');
            if (menu) document.body.removeChild(menu);

            // Get the clicked node and selected nodes
            const clickedNode = cy.getElementById(nodeId);
            const selectedNodes = cy.$('node:selected');
            
            // Determine nodes to color - same logic as regular context menu
            const nodesToColor = clickedNode.selected() && selectedNodes.length > 1 ? selectedNodes : [clickedNode];
            
            // Create a fake event object for showColorPicker
            const fakeEvent = {
                clientX: event.clientX || window.innerWidth / 2,
                clientY: event.clientY || window.innerHeight / 2,
                pageX: event.pageX || window.innerWidth / 2,
                pageY: event.pageY || window.innerHeight / 2
            };
            
            // Use the existing color picker
            showColorPicker(fakeEvent, nodesToColor);
        }

        // Remove color from selected cards in column view
        function removeColorFromSelected() {
            const selectedNodes = cy.$('node:selected');
            if (selectedNodes.length === 0) return;

            selectedNodes.forEach(node => {
                removeCardColor(node);
            });

            // Save and update views
            saveBoard();
            if (isColumnView) {
                renderColumnViewDebounced();
            }

            // Close context menu
            const menu = document.getElementById('columnContextMenu');
            if (menu) document.body.removeChild(menu);
        }

        // ====================================================================================================
        // 🔗 ZOTERO LINK BADGE SYSTEM
        // ====================================================================================================

        let linkBadgesContainer = null;

        function setupLinkBadges() {
            // Create container for link badges
            linkBadgesContainer = document.createElement('div');
            linkBadgesContainer.id = 'linkBadgesContainer';
            linkBadgesContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 100;
            `;
            document.getElementById('cy').appendChild(linkBadgesContainer);

            // Update badges whenever the view changes
            cy.on('pan zoom drag position', updateLinkBadges);
            cy.on('add remove', updateLinkBadges);

            // Initial render
            updateLinkBadges();
            console.log('🔗 Link badge system initialized');
        }

        function updateLinkBadges() {
            if (!linkBadgesContainer) return;

            // Clear existing badges
            linkBadgesContainer.innerHTML = '';

            // Get all nodes with zotero_url
            let badgeCount = 0;
            cy.nodes().forEach(node => {
                const zoteroUrl = node.data('zotero_url');
                if (!zoteroUrl) return;

                // Skip if node is not visible
                if (node.style('display') === 'none') return;

                badgeCount++;

                // Create badge
                const badge = document.createElement('div');
                badge.className = 'zotero-link-badge';
                badge.innerHTML = '🔗';
                badge.title = 'Öppna länk: ' + zoteroUrl;

                // Position badge at top-right corner of node
                const pos = node.renderedPosition();
                const width = node.renderedWidth();
                const height = node.renderedHeight();

                const leftPos = pos.x + width/2 - 15;
                const topPos = pos.y - height/2 - 5;

                badge.style.cssText = `
                    position: absolute;
                    left: ${leftPos}px;
                    top: ${topPos}px;
                    width: 30px;
                    height: 30px;
                    background: rgba(255, 255, 255, 0.95);
                    border: 2px solid #007acc;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 16px;
                    cursor: pointer;
                    pointer-events: auto;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                    transition: transform 0.1s ease;
                    user-select: none;
                `;

                // Hover effect
                badge.addEventListener('mouseenter', () => {
                    badge.style.transform = 'scale(1.15)';
                    badge.style.boxShadow = '0 4px 12px rgba(0,122,204,0.4)';
                });
                badge.addEventListener('mouseleave', () => {
                    badge.style.transform = 'scale(1)';
                    badge.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
                });

                // Click handler - open link in new tab
                badge.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    window.open(zoteroUrl, '_blank');
                    console.log('🔗 Opening Zotero link:', zoteroUrl);
                });

                // Touch support for mobile
                badge.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    window.open(zoteroUrl, '_blank');
                    console.log('🔗 Opening Zotero link (touch):', zoteroUrl);
                });

                linkBadgesContainer.appendChild(badge);
            });

            if (badgeCount > 0) {
                console.log(`✅ Updated ${badgeCount} link badge(s)`);
            }
        }

        // TEST FUNCTION - Create a test card with a Zotero link
        // Run in console: testZoteroLinkBadge()
        window.testZoteroLinkBadge = function() {
            const testCard = cy.add({
                group: 'nodes',
                data: {
                    id: 'test-zotero-link-' + Date.now(),
                    text: 'Test kort med Zotero-länk!\n\nKlicka på 🔗-ikonen för att öppna länken.',
                    tags: ['test'],
                    zotero_url: 'https://www.anthropic.com',
                    export_source: 'zotero'
                },
                position: { x: 400, y: 400 }
            });
            testCard.grabify();
            updateLinkBadges();
            console.log('✅ Test kort skapat! Leta efter 🔗-ikonen i övre högra hörnet.');
            return testCard;
        };

        // Initialize badge system after Cytoscape is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit for Cytoscape to fully initialize
            setTimeout(() => {
                if (typeof cy !== 'undefined' && cy) {
                    setupLinkBadges();
                } else {
                    console.warn('⚠️ Cytoscape not initialized, badges will not work');
                }
            }, 500);
        });
    </script>

</body>
</html>